<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::RecordFileWriter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_record_file_writer.html">RecordFileWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classvrs_1_1_record_file_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vrs::RecordFileWriter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class to create VRS files.  
 <a href="classvrs_1_1_record_file_writer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_record_file_writer_8h_source.html">RecordFileWriter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvrs_1_1_record_file_writer_1_1_sort_record.html">SortRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a58051ca8f940f7871c31bf337de6cfe1"><td class="memItemLeft" align="right" valign="top"><a id="a58051ca8f940f7871c31bf337de6cfe1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a58051ca8f940f7871c31bf337de6cfe1">RecordBatch</a> = vector&lt; pair&lt; <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>, list&lt; <a class="el" href="classvrs_1_1_record.html">Record</a> * &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a58051ca8f940f7871c31bf337de6cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch of records collected at one point in time, for each recordable. <br /></td></tr>
<tr class="separator:a58051ca8f940f7871c31bf337de6cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2781b1102194995a6e17171569e0bcdb"><td class="memItemLeft" align="right" valign="top"><a id="a2781b1102194995a6e17171569e0bcdb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a2781b1102194995a6e17171569e0bcdb">RecordBatches</a> = vector&lt; unique_ptr&lt; <a class="el" href="classvrs_1_1_record_file_writer.html#a58051ca8f940f7871c31bf337de6cfe1">RecordBatch</a> &gt; &gt;</td></tr>
<tr class="memdesc:a2781b1102194995a6e17171569e0bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series of record batches collected. <br /></td></tr>
<tr class="separator:a2781b1102194995a6e17171569e0bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b0906c714818a9887e09fb7f9189ea"><td class="memItemLeft" align="right" valign="top"><a id="af2b0906c714818a9887e09fb7f9189ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#af2b0906c714818a9887e09fb7f9189ea">SortedRecords</a> = deque&lt; <a class="el" href="structvrs_1_1_record_file_writer_1_1_sort_record.html">SortRecord</a> &gt;</td></tr>
<tr class="memdesc:af2b0906c714818a9887e09fb7f9189ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of records, sorted by time. <br /></td></tr>
<tr class="separator:af2b0906c714818a9887e09fb7f9189ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04814193ef6087cf3d36eaf1f4f509d2"><td class="memItemLeft" align="right" valign="top"><a id="a04814193ef6087cf3d36eaf1f4f509d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RecordFileWriter</b> (const <a class="el" href="classvrs_1_1_record_file_writer.html">RecordFileWriter</a> &amp;)=delete</td></tr>
<tr class="separator:a04814193ef6087cf3d36eaf1f4f509d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7fa1aec72c3feb2c828f2d3b86c787"><td class="memItemLeft" align="right" valign="top"><a id="acb7fa1aec72c3feb2c828f2d3b86c787"></a>
<a class="el" href="classvrs_1_1_record_file_writer.html">RecordFileWriter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classvrs_1_1_record_file_writer.html">RecordFileWriter</a> &amp;)=delete</td></tr>
<tr class="separator:acb7fa1aec72c3feb2c828f2d3b86c787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece09053cfb5ae3a9378db6e0ef9b180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#aece09053cfb5ae3a9378db6e0ef9b180">addRecordable</a> (<a class="el" href="classvrs_1_1_recordable.html">Recordable</a> *recordable)</td></tr>
<tr class="separator:aece09053cfb5ae3a9378db6e0ef9b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddaf6a011bb1a64bd827f6d5b30a3e4"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvrs_1_1_recordable.html">Recordable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a4ddaf6a011bb1a64bd827f6d5b30a3e4">getRecordables</a> () const</td></tr>
<tr class="separator:a4ddaf6a011bb1a64bd827f6d5b30a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906335888ed3769039c1b2be493959b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a906335888ed3769039c1b2be493959b3">setCompressionThreadPoolSize</a> (size_t size=kMaxThreadPoolSizeForHW)</td></tr>
<tr class="separator:a906335888ed3769039c1b2be493959b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ff88dda319f43410152dabcbad6959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a30ff88dda319f43410152dabcbad6959">setInitCreatedThreadCallback</a> (const <a class="el" href="namespacevrs.html#a142c4b247fe86fb372c27f77d46e96b4">InitCreatedThreadCallback</a> &amp;initCreatedThreadCallback)</td></tr>
<tr class="separator:a30ff88dda319f43410152dabcbad6959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a1faddddafd31345419dd1845533c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#ad3a1faddddafd31345419dd1845533c1">writeToFile</a> (const string &amp;filePath)</td></tr>
<tr class="separator:ad3a1faddddafd31345419dd1845533c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c39b244d61c2784ac96504c2da8c94d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a0c39b244d61c2784ac96504c2da8c94d">purgeOldRecords</a> (double maxTimestamp, bool recycleBuffers=true)</td></tr>
<tr class="separator:a0c39b244d61c2784ac96504c2da8c94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25ac696634369b6a4ed573876aeec45"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#af25ac696634369b6a4ed573876aeec45">createFileAsync</a> (const string &amp;filePath)</td></tr>
<tr class="separator:af25ac696634369b6a4ed573876aeec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961580b64a0d3e7b1e08cd1dbe542c5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a961580b64a0d3e7b1e08cd1dbe542c5b">createChunkedFile</a> (const string &amp;filePath, size_t maxChunkSizeMB=0, unique_ptr&lt; <a class="el" href="classvrs_1_1_new_chunk_handler.html">NewChunkHandler</a> &gt; &amp;&amp;chunkHandler=nullptr)</td></tr>
<tr class="separator:a961580b64a0d3e7b1e08cd1dbe542c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38efeed99dfff603efcb673de4c457b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a38efeed99dfff603efcb673de4c457b0">setMaxChunkSizeMB</a> (size_t maxChunkSizeMB)</td></tr>
<tr class="separator:a38efeed99dfff603efcb673de4c457b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d708366d44df51c9c500a2852279ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a71d708366d44df51c9c500a2852279ae">preallocateIndex</a> (unique_ptr&lt; deque&lt; <a class="el" href="structvrs_1_1_index_record_1_1_disk_record_info.html">IndexRecord::DiskRecordInfo</a> &gt;&gt; preliminaryIndex)</td></tr>
<tr class="separator:a71d708366d44df51c9c500a2852279ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd37c181ccb84adaba5e67f0868b717c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#abd37c181ccb84adaba5e67f0868b717c">writeRecordsAsync</a> (double maxTimestamp)</td></tr>
<tr class="separator:abd37c181ccb84adaba5e67f0868b717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3456d07552e4834d658ba92f2ee7272d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a3456d07552e4834d658ba92f2ee7272d">autoWriteRecordsAsync</a> (const function&lt; double()&gt; &amp;maxTimestampProvider, double delay)</td></tr>
<tr class="separator:a3456d07552e4834d658ba92f2ee7272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99522ed232b7179766420ef32819b954"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a99522ed232b7179766420ef32819b954">autoPurgeRecords</a> (const function&lt; double()&gt; &amp;maxTimestampProvider, double delay)</td></tr>
<tr class="separator:a99522ed232b7179766420ef32819b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3a7ed71bdec9326a781aba2789828f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#adf3a7ed71bdec9326a781aba2789828f">isWriting</a> () const</td></tr>
<tr class="separator:adf3a7ed71bdec9326a781aba2789828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13cabd33d9e7b2b7f7a97d52c13291a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#ae13cabd33d9e7b2b7f7a97d52c13291a">trackBackgroundThreadQueueByteSize</a> ()</td></tr>
<tr class="separator:ae13cabd33d9e7b2b7f7a97d52c13291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d5ba84186faf5026df2a6607d27da4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#ac7d5ba84186faf5026df2a6607d27da4">getBackgroundThreadQueueByteSize</a> ()</td></tr>
<tr class="separator:ac7d5ba84186faf5026df2a6607d27da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc62c321a72cb16c5fba1c128f16676"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#acfc62c321a72cb16c5fba1c128f16676">closeFileAsync</a> ()</td></tr>
<tr class="separator:acfc62c321a72cb16c5fba1c128f16676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f17115d0823c49cad9537a444175106"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a4f17115d0823c49cad9537a444175106">waitForFileClosed</a> ()</td></tr>
<tr class="separator:a4f17115d0823c49cad9537a444175106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245ce789938f697fb32802969a940439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a245ce789938f697fb32802969a940439">setTag</a> (const string &amp;tagName, const string &amp;tagValue)</td></tr>
<tr class="separator:a245ce789938f697fb32802969a940439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d20c53fcd9e5c5bb309c0ace6e581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#abb5d20c53fcd9e5c5bb309c0ace6e581">addTags</a> (const map&lt; string, string &gt; &amp;newTags)</td></tr>
<tr class="separator:abb5d20c53fcd9e5c5bb309c0ace6e581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8ffcbbd36d7e2017db94495173eb1d"><td class="memItemLeft" align="right" valign="top">const map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a0c8ffcbbd36d7e2017db94495173eb1d">getTags</a> () const</td></tr>
<tr class="separator:a0c8ffcbbd36d7e2017db94495173eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e731681018b1380df167bdf9821656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#ac9e731681018b1380df167bdf9821656">setWriteFileHandler</a> (unique_ptr&lt; <a class="el" href="classvrs_1_1_write_file_handler.html">WriteFileHandler</a> &gt; writeFileHandler)</td></tr>
<tr class="separator:ac9e731681018b1380df167bdf9821656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242da4ebbc9df6c8eb305855e49d3eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a242da4ebbc9df6c8eb305855e49d3eb8">backgroundWriterThreadActivity</a> ()</td></tr>
<tr class="separator:a242da4ebbc9df6c8eb305855e49d3eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d5061fcb4a9923169ab619741c0a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#ab4d5061fcb4a9923169ab619741c0a02">backgroundPurgeThreadActivity</a> ()</td></tr>
<tr class="separator:ab4d5061fcb4a9923169ab619741c0a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0c72ff93e13a557f5eed3e668f3de468"><td class="memItemLeft" align="right" valign="top"><a id="a0c72ff93e13a557f5eed3e668f3de468"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxThreadPoolSizeForHW</b> = UINT32_MAX</td></tr>
<tr class="separator:a0c72ff93e13a557f5eed3e668f3de468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa42829c98ee8c2f8317a641b5ee09daa"><td class="memItemLeft" align="right" valign="top"><a id="aa42829c98ee8c2f8317a641b5ee09daa"></a>
unique_ptr&lt; <a class="el" href="classvrs_1_1_write_file_handler.html">WriteFileHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#aa42829c98ee8c2f8317a641b5ee09daa">file_</a></td></tr>
<tr class="memdesc:aa42829c98ee8c2f8317a641b5ee09daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">data members valid while a file is being worked on <br /></td></tr>
<tr class="separator:aa42829c98ee8c2f8317a641b5ee09daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a490310a4d50f37b5cb7054b12b5ed"><td class="memItemLeft" align="right" valign="top"><a id="a45a490310a4d50f37b5cb7054b12b5ed"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxChunkSize_</b> {}</td></tr>
<tr class="separator:a45a490310a4d50f37b5cb7054b12b5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193b561b250c7d6691b22bb1a10d7993"><td class="memItemLeft" align="right" valign="top"><a id="a193b561b250c7d6691b22bb1a10d7993"></a>
unique_ptr&lt; <a class="el" href="classvrs_1_1_new_chunk_handler.html">NewChunkHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>newChunkHandler_</b></td></tr>
<tr class="separator:a193b561b250c7d6691b22bb1a10d7993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a809bf599a146dd331db0f6bc09fa64"><td class="memItemLeft" align="right" valign="top"><a id="a2a809bf599a146dd331db0f6bc09fa64"></a>
<a class="el" href="structvrs_1_1_file_format_1_1_file_header.html">FileFormat::FileHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fileHeader_</b></td></tr>
<tr class="separator:a2a809bf599a146dd331db0f6bc09fa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb551588a0ef6cd94d07505d49d0bab"><td class="memItemLeft" align="right" valign="top"><a id="a8eb551588a0ef6cd94d07505d49d0bab"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>lastRecordSize_</b> {}</td></tr>
<tr class="separator:a8eb551588a0ef6cd94d07505d49d0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9699a64582162cc76ae855379e5168d6"><td class="memItemLeft" align="right" valign="top"><a id="a9699a64582162cc76ae855379e5168d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortRecords_</b> {true}</td></tr>
<tr class="separator:a9699a64582162cc76ae855379e5168d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d63268827836fcf23a440603a7ed6f"><td class="memItemLeft" align="right" valign="top"><a id="a07d63268827836fcf23a440603a7ed6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>skipFinalizeIndexRecords_</b> = false</td></tr>
<tr class="separator:a07d63268827836fcf23a440603a7ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a11e3729395f1c8a9703f8328deb3ef"><td class="memItemLeft" align="right" valign="top"><a id="a0a11e3729395f1c8a9703f8328deb3ef"></a>
unique_ptr&lt; deque&lt; <a class="el" href="structvrs_1_1_index_record_1_1_disk_record_info.html">IndexRecord::DiskRecordInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>preliminaryIndex_</b></td></tr>
<tr class="separator:a0a11e3729395f1c8a9703f8328deb3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa861ea7a01c9e11987a38b184725328d"><td class="memItemLeft" align="right" valign="top"><a id="aa861ea7a01c9e11987a38b184725328d"></a>
<a class="el" href="classvrs_1_1_index_record_1_1_writer.html">IndexRecord::Writer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>indexRecordWriter_</b></td></tr>
<tr class="separator:aa861ea7a01c9e11987a38b184725328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd3352b265db9d7035d7e4ea8826608"><td class="memItemLeft" align="right" valign="top"><a id="a3bd3352b265db9d7035d7e4ea8826608"></a>
map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fileTags_</b></td></tr>
<tr class="separator:a3bd3352b265db9d7035d7e4ea8826608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03422126411c541e87e54099e3a990e9"><td class="memItemLeft" align="right" valign="top"><a id="a03422126411c541e87e54099e3a990e9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>compressionThreadPoolSize_</b> {}</td></tr>
<tr class="separator:a03422126411c541e87e54099e3a990e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804d2cc31fd910476563d445997d5505"><td class="memItemLeft" align="right" valign="top"><a id="a804d2cc31fd910476563d445997d5505"></a>
<a class="el" href="structvrs_1_1_record_file_writer___1_1_writer_thread_data.html">RecordFileWriter_::WriterThreadData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a804d2cc31fd910476563d445997d5505">writerThreadData_</a></td></tr>
<tr class="memdesc:a804d2cc31fd910476563d445997d5505"><td class="mdescLeft">&#160;</td><td class="mdescRight">when a background thread is active <br /></td></tr>
<tr class="separator:a804d2cc31fd910476563d445997d5505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af634c147db44f9cfbd811d85717c4d"><td class="memItemLeft" align="right" valign="top"><a id="a5af634c147db44f9cfbd811d85717c4d"></a>
std::unique_ptr&lt; std::atomic&lt; uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>queueByteSize_</b></td></tr>
<tr class="separator:a5af634c147db44f9cfbd811d85717c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625e8d8842c54f6c6b95242f3ef705a5"><td class="memItemLeft" align="right" valign="top"><a id="a625e8d8842c54f6c6b95242f3ef705a5"></a>
<a class="el" href="structvrs_1_1_record_file_writer___1_1_purge_thread_data.html">RecordFileWriter_::PurgeThreadData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_writer.html#a625e8d8842c54f6c6b95242f3ef705a5">purgeThreadData_</a></td></tr>
<tr class="memdesc:a625e8d8842c54f6c6b95242f3ef705a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">when a purge thread is active <br /></td></tr>
<tr class="separator:a625e8d8842c54f6c6b95242f3ef705a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020c4839ae3870b3242772bb10105d8d"><td class="memItemLeft" align="right" valign="top"><a id="a020c4839ae3870b3242772bb10105d8d"></a>
<a class="el" href="namespacevrs.html#a142c4b247fe86fb372c27f77d46e96b4">InitCreatedThreadCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><b>initCreatedThreadCallback_</b></td></tr>
<tr class="separator:a020c4839ae3870b3242772bb10105d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9a57217d29da279c507a4b4b9aa8d141"><td class="memItemLeft" align="right" valign="top"><a id="a9a57217d29da279c507a4b4b9aa8d141"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>::vrs::test::RecordFileWriterTester</b></td></tr>
<tr class="separator:a9a57217d29da279c507a4b4b9aa8d141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class to create VRS files. </p>
<p>There are different strategies to write a VRS file:</p>
<p>Write all the data of one or more recordables to a file synchronously in one shot:</p><ul>
<li>create a <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a>.</li>
<li>add the (active) recordables you want to record using <a class="el" href="classvrs_1_1_record_file_writer.html#aece09053cfb5ae3a9378db6e0ef9b180">addRecordable()</a>.</li>
<li>create all the records you want, as long as they fit in memory.</li>
<li>call <a class="el" href="classvrs_1_1_record_file_writer.html#ad3a1faddddafd31345419dd1845533c1">writeToFile()</a> with a filepath.</li>
<li>profit!</li>
</ul>
<p>To write the data of one or more recordables, progressively, while records are being generated, using a background thread:</p><ul>
<li>create a RecordFileWrite.</li>
<li>add the (active) recordables you want to record using <a class="el" href="classvrs_1_1_record_file_writer.html#aece09053cfb5ae3a9378db6e0ef9b180">addRecordable()</a>.</li>
<li>create the file using <a class="el" href="classvrs_1_1_record_file_writer.html#af25ac696634369b6a4ed573876aeec45">createFileAsync()</a>.This will create the file &amp; write a few bytes, but should be quite quick.</li>
<li>optional: call purgeOldData() to discard records that were created before what you really want to record.</li>
<li>call <a class="el" href="classvrs_1_1_record_file_writer.html#abd37c181ccb84adaba5e67f0868b717c">writeRecordsAsync()</a> regularly to write old enough records to disk in the background. (very fast call)</li>
<li>optional: call <a class="el" href="classvrs_1_1_record_file_writer.html#acfc62c321a72cb16c5fba1c128f16676">closeFileAsync()</a> to write the remaining unwritten records, in the background. (very fast call)</li>
<li>call <a class="el" href="classvrs_1_1_record_file_writer.html#a4f17115d0823c49cad9537a444175106">waitForFileClosed()</a> to write all the unwritten records &amp; wait for the file to be written &amp; closed. (blocking call).</li>
<li>profit! </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aece09053cfb5ae3a9378db6e0ef9b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece09053cfb5ae3a9378db6e0ef9b180">&#9670;&nbsp;</a></span>addRecordable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::addRecordable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_recordable.html">Recordable</a> *&#160;</td>
          <td class="paramname"><em>recordable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A record file holds data from various recordables, registered using this method. The ownership of the recordable is not transferred, and the caller is responsible for deleting the recordables after the <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> is deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordable</td><td><a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> object for the device to record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb5d20c53fcd9e5c5bb309c0ace6e581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5d20c53fcd9e5c5bb309c0ace6e581">&#9670;&nbsp;</a></span>addTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::addTags </td>
          <td>(</td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>newTags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add file tags in bulk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTags</td><td>A map of string name/value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99522ed232b7179766420ef32819b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99522ed232b7179766420ef32819b954">&#9670;&nbsp;</a></span>autoPurgeRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::autoPurgeRecords </td>
          <td>(</td>
          <td class="paramtype">const function&lt; double()&gt; &amp;&#160;</td>
          <td class="paramname"><em>maxTimestampProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To purge old records automatically, when no file is being written. Note: while writing a VRS file asynchronously, record purging will automatically be disabled when the file is created, and re-enabled when the file is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTimestampProvider</td><td>Function providing the timestamp of the newest record to be purged. </td></tr>
    <tr><td class="paramname">delay</td><td>Number of seconds between automated calls to purge records. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code: 0 if no error occurred, a file system error code otherwise. </dd></dl>

</div>
</div>
<a id="a3456d07552e4834d658ba92f2ee7272d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3456d07552e4834d658ba92f2ee7272d">&#9670;&nbsp;</a></span>autoWriteRecordsAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::autoWriteRecordsAsync </td>
          <td>(</td>
          <td class="paramtype">const function&lt; double()&gt; &amp;&#160;</td>
          <td class="paramname"><em>maxTimestampProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To collect &amp; write new records automatically after opening the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTimestampProvider</td><td>Function providing the timestamp of the newest record to be sent to the background thread(s) writing records to disk. All records sent to disk are older. </td></tr>
    <tr><td class="paramname">delay</td><td>Number of seconds between automated calls to send records for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code: 0 if no error occurred, a file system error code otherwise. </dd></dl>

</div>
</div>
<a id="ab4d5061fcb4a9923169ab619741c0a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d5061fcb4a9923169ab619741c0a02">&#9670;&nbsp;</a></span>backgroundPurgeThreadActivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::backgroundPurgeThreadActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Background threads implementation: do not call! </p>

</div>
</div>
<a id="a242da4ebbc9df6c8eb305855e49d3eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242da4ebbc9df6c8eb305855e49d3eb8">&#9670;&nbsp;</a></span>backgroundWriterThreadActivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::backgroundWriterThreadActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Background threads implementation: do not call! </p>

</div>
</div>
<a id="acfc62c321a72cb16c5fba1c128f16676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc62c321a72cb16c5fba1c128f16676">&#9670;&nbsp;</a></span>closeFileAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::closeFileAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request to close the file, when all data has been written, but don't wait for that. </p><dl class="section return"><dt>Returns</dt><dd>A status code: 0 if no error occurred, a file system error code otherwise. </dd></dl>

</div>
</div>
<a id="a961580b64a0d3e7b1e08cd1dbe542c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961580b64a0d3e7b1e08cd1dbe542c5b">&#9670;&nbsp;</a></span>createChunkedFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::createChunkedFile </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxChunkSizeMB</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classvrs_1_1_new_chunk_handler.html">NewChunkHandler</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>chunkHandler</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a VRS file to write to in a background thread, with a separate head file that will contain the file's header, and the description and index records only. All the user records will be written in one or more following chunks, that will be only written going forward, which makes them streaming friendly. The file's head will always be written using a DiskFile, and will be using updates/overwrites, which is not compatible with streaming, unless you can upload the file's head at the end, and prepend it to the previously uploaded user record chunk(s). A VRS file created this way will be efficient to stream when reading records in timestamp order with no seek backward or forward. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path relative or absolute of the VRS file to create. The user record chunks will be named using the name provided, with "_1", "_2", etc as suffix. Note: the file's &amp; recordables' tags will be written to disk before the call returns. Make sure to call this method only after you've added all your recordables and set all the tags. </td></tr>
    <tr><td class="paramname">maxChunkSizeMB</td><td>max size of a chunk. Note that the last chunk may actually be larger. If maxChunkSizeMB is 0, at least two chunks will be created: one for the file's records, one for the file's header and index. </td></tr>
    <tr><td class="paramname">chunkHandler</td><td>optional listener to be notified each time a chunk is complete, and when chunk handling should be completed (finalize uploads, maybe?). See NewChunkCallback's documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af25ac696634369b6a4ed573876aeec45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25ac696634369b6a4ed573876aeec45">&#9670;&nbsp;</a></span>createFileAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::createFileAsync </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a VRS file to write to in a background thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path relative or absolute of the VRS file to create. Note: the file's &amp; recordables' tags will be written to disk before the call returns. Make sure to call this method only after you've added all your recordables and set all the tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d5ba84186faf5026df2a6607d27da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d5ba84186faf5026df2a6607d27da4">&#9670;&nbsp;</a></span>getBackgroundThreadQueueByteSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vrs::RecordFileWriter::getBackgroundThreadQueueByteSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get how many record-bytes have been passed to the background thread, but not yet processed, which correlates with how much memory is being used by the queue. </p><dl class="section return"><dt>Returns</dt><dd>The number record bytes are waiting to be processed by the background thread. </dd></dl>

</div>
</div>
<a id="a4ddaf6a011bb1a64bd827f6d5b30a3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddaf6a011bb1a64bd827f6d5b30a3e4">&#9670;&nbsp;</a></span>getRecordables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvrs_1_1_recordable.html">Recordable</a> * &gt; vrs::RecordFileWriter::getRecordables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the recordables attached to this writer. </p><dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> pointers. </dd></dl>

</div>
</div>
<a id="a0c8ffcbbd36d7e2017db94495173eb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8ffcbbd36d7e2017db94495173eb1d">&#9670;&nbsp;</a></span>getTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt;string, string&gt;&amp; vrs::RecordFileWriter::getTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all the file tags at once. </p><dl class="section return"><dt>Returns</dt><dd>A map of all the tags associated with the file itself. </dd></dl>

</div>
</div>
<a id="adf3a7ed71bdec9326a781aba2789828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3a7ed71bdec9326a781aba2789828f">&#9670;&nbsp;</a></span>isWriting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileWriter::isWriting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if a disk file is being written. </p><dl class="section return"><dt>Returns</dt><dd>True is a file is being written by this <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> instance. </dd></dl>

</div>
</div>
<a id="a71d708366d44df51c9c500a2852279ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d708366d44df51c9c500a2852279ae">&#9670;&nbsp;</a></span>preallocateIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::preallocateIndex </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; deque&lt; <a class="el" href="structvrs_1_1_index_record_1_1_disk_record_info.html">IndexRecord::DiskRecordInfo</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>preliminaryIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pre-allocate space for an index similar to the one provided. Must be called <em>before</em> the file is created, but after all the recordables have been attached. Call this method just before creating the file using <a class="el" href="classvrs_1_1_record_file_writer.html#af25ac696634369b6a4ed573876aeec45">createFileAsync()</a>. The index should be as similar to the real thing as possible, as it will be used to guess the size of the actual index, compressed. This method is meant to be used for copy operations, so that a compressed index can be pre-allocated based on the index of the source file(s). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preliminaryIndex</td><td>an index that resembles the index of the final file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is the request is accepted. </dd></dl>

</div>
</div>
<a id="a0c39b244d61c2784ac96504c2da8c94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c39b244d61c2784ac96504c2da8c94d">&#9670;&nbsp;</a></span>purgeOldRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::purgeOldRecords </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recycleBuffers</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete all records older than a certain time (useful to trim a live buffer). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTimestamp</td><td>timestamp cutoff for the records to purge; all purged records have been created before that maxTimestamp. </td></tr>
    <tr><td class="paramname">recycleBuffer</td><td>Tell if the buffers should be recycled and the memory occupied by the records might not released immediately, or if the memory freed immediately. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a906335888ed3769039c1b2be493959b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906335888ed3769039c1b2be493959b3">&#9670;&nbsp;</a></span>setCompressionThreadPoolSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::setCompressionThreadPoolSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>kMaxThreadPoolSizeForHW</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set number of threads to use for background compression, or none will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of threads to compress records in parallel. The default value will make <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> use as many threads as there are cores in the system. If you do not set any value, <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> will use only a single thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ff88dda319f43410152dabcbad6959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ff88dda319f43410152dabcbad6959">&#9670;&nbsp;</a></span>setInitCreatedThreadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::setInitCreatedThreadCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevrs.html#a142c4b247fe86fb372c27f77d46e96b4">InitCreatedThreadCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>initCreatedThreadCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a callback that will be called when a Thread is created by this interface. This provides the user the opportunity to set the threads priority, name, etc... The new thread will use the callback so functions like gettid() can be used. This is an optional call, but must be performed before calling <a class="el" href="classvrs_1_1_record_file_writer.html#af25ac696634369b6a4ed573876aeec45">createFileAsync()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initCreatedThreadCallback</td><td>Callback that returns a reference to the thread created, the ThreadRole, and the thread index (only used for Compression threads) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38efeed99dfff603efcb673de4c457b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38efeed99dfff603efcb673de4c457b0">&#9670;&nbsp;</a></span>setMaxChunkSizeMB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::setMaxChunkSizeMB </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxChunkSizeMB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum chunk size, as a number of MB, 0 meaning no chunking (infinite limit). Must be called after calling <a class="el" href="classvrs_1_1_record_file_writer.html#af25ac696634369b6a4ed573876aeec45">createFileAsync()</a>, if it wasn't set then. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxChunkSizeMB</td><td>Max number of MB by chunk. Actual chunks might be a bit smaller, to avoid splitting records. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a245ce789938f697fb32802969a940439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245ce789938f697fb32802969a940439">&#9670;&nbsp;</a></span>setTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::setTag </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tagValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a tag value. Note: tags are written when the file is created! Changes made later will not be saved! Tags are written early, so that if the app crashes, or we run out of disk space, we don't loose them! An index can be rebuilt if it's missing in a truncated file, but tags need to be safe, or they're useless! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>The name of the tag. </td></tr>
    <tr><td class="paramname">tagValue</td><td>The value of the tag. Can be any string value, including a json message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e731681018b1380df167bdf9821656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e731681018b1380df167bdf9821656">&#9670;&nbsp;</a></span>setWriteFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::setWriteFileHandler </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classvrs_1_1_write_file_handler.html">WriteFileHandler</a> &gt;&#160;</td>
          <td class="paramname"><em>writeFileHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To use a different type of <a class="el" href="classvrs_1_1_write_file_handler.html" title="The WriteFileHandler interface adds write operations to the FileHandler interface.">WriteFileHandler</a> to generate the file. <a class="el" href="classvrs_1_1_write_file_handler.html" title="The WriteFileHandler interface adds write operations to the FileHandler interface.">WriteFileHandler</a> uses DiskFile by default, but you can use a different implementation if you need to. You might want to stream the data to the cloud, or override DiskFile to tweak file creation and initialize the file objects differently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeFileHandler</td><td>a specialized <a class="el" href="classvrs_1_1_write_file_handler.html" title="The WriteFileHandler interface adds write operations to the FileHandler interface.">WriteFileHandler</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error status, 0 meaning success. </dd></dl>

</div>
</div>
<a id="ae13cabd33d9e7b2b7f7a97d52c13291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13cabd33d9e7b2b7f7a97d52c13291a">&#9670;&nbsp;</a></span>trackBackgroundThreadQueueByteSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileWriter::trackBackgroundThreadQueueByteSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It can be useful/necessary to track how much buffer memory is used by the background threads, so as to report errors, stop recording, or simply wait that enough data has been processed. To avoid threading/cache invalidation costs, this feature needs to be enabled by calling this method before you start writing to disk. For race conditions, you need to call this before the background thread is active. To be safe, call it before creating the file. </p>

</div>
</div>
<a id="a4f17115d0823c49cad9537a444175106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f17115d0823c49cad9537a444175106">&#9670;&nbsp;</a></span>waitForFileClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::waitForFileClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start writing all the pending records, and wait for the file to be written &amp; closed. </p><dl class="section return"><dt>Returns</dt><dd>A status code: 0 if no error occurred, a file system error code otherwise. </dd></dl>

</div>
</div>
<a id="abd37c181ccb84adaba5e67f0868b717c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd37c181ccb84adaba5e67f0868b717c">&#9670;&nbsp;</a></span>writeRecordsAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::writeRecordsAsync </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxTimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send records older than the timestamp provided to be written to disk in a background thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTimestamp</td><td>Largest timestamp of the records sent to be written to disk, i.e. all records to be written are older. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code: 0 if no error occurred, a file system error code otherwise. </dd></dl>

</div>
</div>
<a id="ad3a1faddddafd31345419dd1845533c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a1faddddafd31345419dd1845533c1">&#9670;&nbsp;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileWriter::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take all the records of all the registered and <em>active</em> recordables, and write them all to disk. All synchronous, won't return until the file is closed. On error, a (partial) file may exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path relative or absolute where to write the VRS file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code: 0 if no error occurred, a file system error code otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_record_file_writer_8h_source.html">RecordFileWriter.h</a></li>
<li>vrs/RecordFileWriter.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

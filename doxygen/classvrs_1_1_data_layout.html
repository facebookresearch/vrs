<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::DataLayout Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classvrs_1_1_data_layout-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vrs::DataLayout Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> class describes the data stored inside a DataLayoutContentBlock.  
 <a href="classvrs_1_1_data_layout.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_data_layout_8h_source.html">DataLayout.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrs::DataLayout:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvrs_1_1_data_layout.png" usemap="#vrs::DataLayout_map" alt=""/>
  <map id="vrs::DataLayout_map" name="vrs::DataLayout_map">
<area href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format." alt="vrs::AutoDataLayout" shape="rect" coords="0,56,410,80"/>
<area href="classvrs_1_1_empty_data_layout.html" title="When you just need a placeholder for a DataLayout." alt="vrs::EmptyDataLayout" shape="rect" coords="420,56,830,80"/>
<area href="classvrs_1_1_manual_data_layout.html" title="Specialized DataLayout for programmatic DataLayout generation." alt="vrs::ManualDataLayout" shape="rect" coords="840,56,1250,80"/>
<area href="structvrs_1_1_tags_record.html" title="DataLayout definition used in tag records, which is a VRS internal record type." alt="vrs::TagsRecord" shape="rect" coords="420,112,830,136"/>
<area href="classvrs_1_1datalayout__conventions_1_1_audio_spec.html" title="DataLayout definitions use to describe what&#39;s in an audio content block." alt="vrs::datalayout_conventions::AudioSpec" shape="rect" coords="420,168,830,192"/>
<area href="classvrs_1_1datalayout__conventions_1_1_image_spec.html" title="DataLayout definitions use to describe what&#39;s in an image content block." alt="vrs::datalayout_conventions::ImageSpec" shape="rect" coords="420,224,830,248"/>
<area href="classvrs_1_1datalayout__conventions_1_1_next_audio_content_block_sample_count_spec.html" title="DataLayout only containing the number of audio samples in the audio content block following." alt="vrs::datalayout_conventions::NextAudioContentBlockSampleCountSpec" shape="rect" coords="420,280,830,304"/>
<area href="classvrs_1_1datalayout__conventions_1_1_next_content_block_size_spec.html" title="DataLayout only containing the size of the content block following." alt="vrs::datalayout_conventions::NextContentBlockSizeSpec" shape="rect" coords="420,336,830,360"/>
<area href="classvrs_1_1datalayout__conventions_1_1_video_frame_spec.html" title="DataLayout definitions use to describe a video image content block." alt="vrs::datalayout_conventions::VideoFrameSpec" shape="rect" coords="420,392,830,416"/>
<area href="structvrs__sample__apps_1_1_camera_stream_config.html" title="Sample metadata for configuration records of an image stream." alt="vrs_sample_apps::CameraStreamConfig" shape="rect" coords="420,448,830,472"/>
<area href="structvrs__sample__apps_1_1_camera_stream_data.html" title="Sample metadata for data records of an image stream." alt="vrs_sample_apps::CameraStreamData" shape="rect" coords="420,504,830,528"/>
<area href="structvrs__sample__apps_1_1_motion_stream_config.html" title="Sample metadata for configuration records of a metadata stream." alt="vrs_sample_apps::MotionStreamConfig" shape="rect" coords="420,560,830,584"/>
<area href="structvrs__sample__apps_1_1_motion_stream_data.html" title="Sample metadata for data records of a metadata stream." alt="vrs_sample_apps::MotionStreamData" shape="rect" coords="420,616,830,640"/>
<area href="classvrs__sample__code_1_1_my_camera_data_layout_configuration.html" title="Definition of the configuration records&#39; metadata." alt="vrs_sample_code::MyCameraDataLayoutConfiguration" shape="rect" coords="420,672,830,696"/>
<area href="classvrs__sample__code_1_1_my_camera_data_layout_data.html" title="Definition of the data records&#39; metadata." alt="vrs_sample_code::MyCameraDataLayoutData" shape="rect" coords="420,728,830,752"/>
<area href="classvrs__sample__code_1_1_my_camera_data_layout_legacy_data.html" title="Definition of some obsolete metadata." alt="vrs_sample_code::MyCameraDataLayoutLegacyData" shape="rect" coords="420,784,830,808"/>
<area href="classvrs__sample__code_1_1_my_metadata.html" title="Definition of some trivial metadata." alt="vrs_sample_code::MyMetadata" shape="rect" coords="420,840,830,864"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout_1_1_index_entry.html">IndexEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes where the data of a variable size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> is in the varData_ buffer.  <a href="classvrs_1_1_data_layout_1_1_index_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6faf8bbb1186b6d83aaaae497ee4e5e"><td class="memItemLeft" align="right" valign="top"><a id="ab6faf8bbb1186b6d83aaaae497ee4e5e"></a>
<a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;)=delete</td></tr>
<tr class="separator:ab6faf8bbb1186b6d83aaaae497ee4e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afc4d7268965b78151baa7900cd6603"><td class="memItemLeft" align="right" valign="top"><a id="a3afc4d7268965b78151baa7900cd6603"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DataLayout</b> (const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;)=delete</td></tr>
<tr class="separator:a3afc4d7268965b78151baa7900cd6603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b397a6aba99ed3279f685e65672738"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ab4b397a6aba99ed3279f685e65672738">~DataLayout</a> ()</td></tr>
<tr class="separator:ab4b397a6aba99ed3279f685e65672738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba3915c662bb4207b29b1549ce4eaeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_content_block.html">ContentBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a7ba3915c662bb4207b29b1549ce4eaeb">getContentBlock</a> () const</td></tr>
<tr class="separator:a7ba3915c662bb4207b29b1549ce4eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da451522713cb1621f4f19fd700798"><td class="memItemLeft" align="right" valign="top">vector&lt; int8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ab5da451522713cb1621f4f19fd700798">getFixedData</a> ()</td></tr>
<tr class="separator:ab5da451522713cb1621f4f19fd700798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d55915862aa73a896aa8872cb1425a"><td class="memItemLeft" align="right" valign="top">vector&lt; int8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#aa3d55915862aa73a896aa8872cb1425a">getVarData</a> ()</td></tr>
<tr class="separator:aa3d55915862aa73a896aa8872cb1425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9530bd3c929fa74584187082c62681c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a9530bd3c929fa74584187082c62681c6">getFixedDataSizeNeeded</a> () const</td></tr>
<tr class="separator:a9530bd3c929fa74584187082c62681c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a809ebc83c33ffc0cee816400598f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a26a809ebc83c33ffc0cee816400598f4">getVarDataSizeFromIndex</a> () const</td></tr>
<tr class="separator:a26a809ebc83c33ffc0cee816400598f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f678feccf08d032de31f630c18909e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ac7f678feccf08d032de31f630c18909e">getVarDataSizeNeeded</a> () const</td></tr>
<tr class="separator:ac7f678feccf08d032de31f630c18909e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9996c20a5c837693bdca551244345981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a9996c20a5c837693bdca551244345981">collectVariableDataAndUpdateIndex</a> ()</td></tr>
<tr class="separator:a9996c20a5c837693bdca551244345981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c65732cad53b2fdd41df6b2fba0a1b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a6c65732cad53b2fdd41df6b2fba0a1b9">collectVariableDataAndUpdateIndex</a> (void *destination)</td></tr>
<tr class="separator:a6c65732cad53b2fdd41df6b2fba0a1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca5cfc4c97bc2d3735de4814f529ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#adca5cfc4c97bc2d3735de4814f529ecd">getRawData</a> (vector&lt; int8_t &gt; &amp;outRawData) const</td></tr>
<tr class="separator:adca5cfc4c97bc2d3735de4814f529ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907d12434ea7849ba9df9b9f3e86313e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a907d12434ea7849ba9df9b9f3e86313e">stageCurrentValues</a> ()</td></tr>
<tr class="separator:a907d12434ea7849ba9df9b9f3e86313e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f18fa9b47bbf506a78478d1bdc3c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a79f18fa9b47bbf506a78478d1bdc3c66">copyClonedDataPieceValues</a> (const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;originalLayout)</td></tr>
<tr class="separator:a79f18fa9b47bbf506a78478d1bdc3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4518e893adf3740ca410f599423ba94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ad4518e893adf3740ca410f599423ba94">mapLayout</a> (<a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;targetLayout)</td></tr>
<tr class="separator:ad4518e893adf3740ca410f599423ba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad484922bc554f7589b9d90fc1d37b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a92ad484922bc554f7589b9d90fc1d37b">isMapped</a> () const</td></tr>
<tr class="separator:a92ad484922bc554f7589b9d90fc1d37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a4330636088850d075e9a384c3b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a175a4330636088850d075e9a384c3b04">hasAllRequiredPieces</a> () const</td></tr>
<tr class="separator:a175a4330636088850d075e9a384c3b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348e63174acddf99cf5bcdeb115152b"><td class="memItemLeft" align="right" valign="top"><a id="a4348e63174acddf99cf5bcdeb115152b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a4348e63174acddf99cf5bcdeb115152b">requireAllPieces</a> ()</td></tr>
<tr class="memdesc:a4348e63174acddf99cf5bcdeb115152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all the fields of the layout as required. <br /></td></tr>
<tr class="separator:a4348e63174acddf99cf5bcdeb115152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2cff196811d7183daab96236fe4e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#adc2cff196811d7183daab96236fe4e32">printLayout</a> (ostream &amp;out, const string &amp;indent=&quot;&quot;) const</td></tr>
<tr class="separator:adc2cff196811d7183daab96236fe4e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476d06cdb839d26cad1e2e3f1868c79c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a476d06cdb839d26cad1e2e3f1868c79c">printLayoutCompact</a> (ostream &amp;out, const string &amp;indent=&quot;&quot;) const</td></tr>
<tr class="separator:a476d06cdb839d26cad1e2e3f1868c79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09ce83ef49d3ddceed7399dedfaf108"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#af09ce83ef49d3ddceed7399dedfaf108">asJson</a> (<a class="el" href="namespacevrs.html#ab5a2876628d1cfe8288aa4d4b557d433">JsonFormatProfile</a> profile) const</td></tr>
<tr class="separator:af09ce83ef49d3ddceed7399dedfaf108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc2c897c4a70bdb4b17447a6e101e59"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a0bc2c897c4a70bdb4b17447a6e101e59">asJson</a> (const <a class="el" href="structvrs_1_1_json_format_profile_spec.html">JsonFormatProfileSpec</a> &amp;profile=<a class="el" href="structvrs_1_1_json_format_profile_spec.html">JsonFormatProfileSpec</a>()) const</td></tr>
<tr class="separator:a0bc2c897c4a70bdb4b17447a6e101e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8699303fb82de2f0f380fa7b09dcaafe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a8699303fb82de2f0f380fa7b09dcaafe">isSame</a> (const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;otherLayout) const</td></tr>
<tr class="separator:a8699303fb82de2f0f380fa7b09dcaafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d705e50213a587aa4a06c59a8f371ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1d705e50213a587aa4a06c59a8f371ed"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_data_piece_value.html">DataPieceValue</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a1d705e50213a587aa4a06c59a8f371ed">findDataPieceValue</a> (const string &amp;label) const</td></tr>
<tr class="separator:a1d705e50213a587aa4a06c59a8f371ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96568ada2925f658c82064c9b17b51"><td class="memTemplParams" colspan="2"><a id="a1b96568ada2925f658c82064c9b17b51"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b96568ada2925f658c82064c9b17b51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_data_piece_value.html">DataPieceValue</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findDataPieceValue</b> (const string &amp;label)</td></tr>
<tr class="separator:a1b96568ada2925f658c82064c9b17b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c292e7878552ee6eaf6878857275a7d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c292e7878552ee6eaf6878857275a7d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a4c292e7878552ee6eaf6878857275a7d">findDataPieceArray</a> (const string &amp;label, size_t arraySize) const</td></tr>
<tr class="separator:a4c292e7878552ee6eaf6878857275a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21de559e1731cb8b80c279866a93bb8"><td class="memTemplParams" colspan="2"><a id="ab21de559e1731cb8b80c279866a93bb8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab21de559e1731cb8b80c279866a93bb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findDataPieceArray</b> (const string &amp;label, size_t arraySize)</td></tr>
<tr class="separator:ab21de559e1731cb8b80c279866a93bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7727bd32b2c5f1a1dbc7ed6ed569afc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac7727bd32b2c5f1a1dbc7ed6ed569afc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_data_piece_vector.html">DataPieceVector</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ac7727bd32b2c5f1a1dbc7ed6ed569afc">findDataPieceVector</a> (const string &amp;label) const</td></tr>
<tr class="separator:ac7727bd32b2c5f1a1dbc7ed6ed569afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63344b0f3fbaa4e7c6cc00e1cf0a0759"><td class="memTemplParams" colspan="2"><a id="a63344b0f3fbaa4e7c6cc00e1cf0a0759"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a63344b0f3fbaa4e7c6cc00e1cf0a0759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_data_piece_vector.html">DataPieceVector</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findDataPieceVector</b> (const string &amp;label)</td></tr>
<tr class="separator:a63344b0f3fbaa4e7c6cc00e1cf0a0759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba42814893dcc0463425f266b5db756"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adba42814893dcc0463425f266b5db756"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_data_piece_string_map.html">DataPieceStringMap</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#adba42814893dcc0463425f266b5db756">findDataPieceStringMap</a> (const string &amp;label) const</td></tr>
<tr class="separator:adba42814893dcc0463425f266b5db756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a55343ef09b0c79491657c6d34fee"><td class="memTemplParams" colspan="2"><a id="a155a55343ef09b0c79491657c6d34fee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a155a55343ef09b0c79491657c6d34fee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_data_piece_string_map.html">DataPieceStringMap</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findDataPieceStringMap</b> (const string &amp;label)</td></tr>
<tr class="separator:a155a55343ef09b0c79491657c6d34fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd325dd774eaf4d39a583519a52497eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_data_piece_string.html">DataPieceString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#abd325dd774eaf4d39a583519a52497eb">findDataPieceString</a> (const string &amp;label) const</td></tr>
<tr class="separator:abd325dd774eaf4d39a583519a52497eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc76db27a54d055d9bd264db9a207edc"><td class="memItemLeft" align="right" valign="top"><a id="acc76db27a54d055d9bd264db9a207edc"></a>
<a class="el" href="classvrs_1_1_data_piece_string.html">DataPieceString</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>findDataPieceString</b> (const string &amp;label)</td></tr>
<tr class="separator:acc76db27a54d055d9bd264db9a207edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bae4f6fce9f01b89665c6684e39fc5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a3bae4f6fce9f01b89665c6684e39fc5d">forEachDataPiece</a> (const std::function&lt; void(const <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> *)&gt; &amp;, <a class="el" href="namespacevrs.html#afb0b040e753b40173e69f247afa430a2">DataPieceType</a> type=<a class="el" href="namespacevrs.html#afb0b040e753b40173e69f247afa430a2aec0fc0100c4fc1ce4eea230c3dc10360">DataPieceType::Undefined</a>) const</td></tr>
<tr class="separator:a3bae4f6fce9f01b89665c6684e39fc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fbcfd13435b589b2c1e3b5e4a70007"><td class="memItemLeft" align="right" valign="top"><a id="ae4fbcfd13435b589b2c1e3b5e4a70007"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ae4fbcfd13435b589b2c1e3b5e4a70007">forEachDataPiece</a> (const std::function&lt; void(<a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> *)&gt; &amp;, <a class="el" href="namespacevrs.html#afb0b040e753b40173e69f247afa430a2">DataPieceType</a> type=<a class="el" href="namespacevrs.html#afb0b040e753b40173e69f247afa430a2aec0fc0100c4fc1ce4eea230c3dc10360">DataPieceType::Undefined</a>)</td></tr>
<tr class="memdesc:ae4fbcfd13435b589b2c1e3b5e4a70007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but as a non-const version. <br /></td></tr>
<tr class="separator:ae4fbcfd13435b589b2c1e3b5e4a70007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02e21cb0c063a1bd598f1de3731f28a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#aa02e21cb0c063a1bd598f1de3731f28a">isVarDataIndexValid</a> () const</td></tr>
<tr class="separator:aa02e21cb0c063a1bd598f1de3731f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20858fc82bc6bb5905d4e9c2bef3d3e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ae20858fc82bc6bb5905d4e9c2bef3d3e">getDeclaredFixedDataPiecesCount</a> () const</td></tr>
<tr class="separator:ae20858fc82bc6bb5905d4e9c2bef3d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb9968e5dd02fdc88e8b4af2942e151"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#addb9968e5dd02fdc88e8b4af2942e151">getDeclaredVarDataPiecesCount</a> () const</td></tr>
<tr class="separator:addb9968e5dd02fdc88e8b4af2942e151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a146d8be64c1e0533c4b32f9aaa1ce9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a6a146d8be64c1e0533c4b32f9aaa1ce9">getAvailableFixedDataPiecesCount</a> () const</td></tr>
<tr class="separator:a6a146d8be64c1e0533c4b32f9aaa1ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b4974793ac022b5de99b84f13cdcd5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a74b4974793ac022b5de99b84f13cdcd5">getAvailableVarDataPiecesCount</a> () const</td></tr>
<tr class="separator:a74b4974793ac022b5de99b84f13cdcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07c244202d11ecb0c4f067b495c314ec"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a07c244202d11ecb0c4f067b495c314ec">makeFromJson</a> (const string &amp;json)</td></tr>
<tr class="separator:a07c244202d11ecb0c4f067b495c314ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa44c7b903f235a37f75b341c60c351a6"><td class="memItemLeft" align="right" valign="top"><a id="aa44c7b903f235a37f75b341c60c351a6"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#aa44c7b903f235a37f75b341c60c351a6">kNotFound</a> = numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="memdesc:aa44c7b903f235a37f75b341c60c351a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special OffsetAndLength offset value marking that a piece of data isn't available. <br /></td></tr>
<tr class="separator:aa44c7b903f235a37f75b341c60c351a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28316f2660ae5807081e9bf4ecd29fd3"><td class="memItemLeft" align="right" valign="top"><a id="a28316f2660ae5807081e9bf4ecd29fd3"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a28316f2660ae5807081e9bf4ecd29fd3">kVariableSize</a> = numeric_limits&lt;size_t&gt;::max() - 1</td></tr>
<tr class="memdesc:a28316f2660ae5807081e9bf4ecd29fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value used for a <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> size, telling that that <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> has a variable size. <br /></td></tr>
<tr class="separator:a28316f2660ae5807081e9bf4ecd29fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab6ae2e3dd02cdbad0753884a22cdecba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab6ae2e3dd02cdbad0753884a22cdecba"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ab6ae2e3dd02cdbad0753884a22cdecba">getFixedData</a> (size_t offset, size_t size)</td></tr>
<tr class="separator:ab6ae2e3dd02cdbad0753884a22cdecba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6298d164cb87da3ffef67081a88005"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_data_layout_1_1_index_entry.html">IndexEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a6f6298d164cb87da3ffef67081a88005">getVarSizeIndex</a> () const</td></tr>
<tr class="separator:a6f6298d164cb87da3ffef67081a88005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d5e5f17e2a7d4805a788101fceac15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_data_layout_1_1_index_entry.html">IndexEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#aa4d5e5f17e2a7d4805a788101fceac15">getVarSizeIndex</a> ()</td></tr>
<tr class="separator:aa4d5e5f17e2a7d4805a788101fceac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1998346c153423968acbcf53703c29cc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1998346c153423968acbcf53703c29cc"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a1998346c153423968acbcf53703c29cc">getVarData</a> (size_t varPieceIndex, size_t &amp;outCount)</td></tr>
<tr class="separator:a1998346c153423968acbcf53703c29cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c01f8d2c61225c4c481a90b8e8f496e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a0c01f8d2c61225c4c481a90b8e8f496e">initLayout</a> ()</td></tr>
<tr class="separator:a0c01f8d2c61225c4c481a90b8e8f496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a2d45a2e209fb2b3990f2ab91cfd412b2"><td class="memItemLeft" align="right" valign="top"><a id="a2d45a2e209fb2b3990f2ab91cfd412b2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>mapPieces</b> (const vector&lt; <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> * &gt; &amp;searchPieces, const vector&lt; <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> * &gt; &amp;givenPieces)</td></tr>
<tr class="separator:a2d45a2e209fb2b3990f2ab91cfd412b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a00a936b38940dffb5e55585323383941"><td class="memItemLeft" align="right" valign="top"><a id="a00a936b38940dffb5e55585323383941"></a>
vector&lt; <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a00a936b38940dffb5e55585323383941">fixedSizePieces_</a></td></tr>
<tr class="memdesc:a00a936b38940dffb5e55585323383941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered fixed-size DataPieces. <br /></td></tr>
<tr class="separator:a00a936b38940dffb5e55585323383941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fb3260920d79a73457a7838c3e37ad"><td class="memItemLeft" align="right" valign="top"><a id="a81fb3260920d79a73457a7838c3e37ad"></a>
vector&lt; <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a81fb3260920d79a73457a7838c3e37ad">varSizePieces_</a></td></tr>
<tr class="memdesc:a81fb3260920d79a73457a7838c3e37ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered variable-size DataPieces. <br /></td></tr>
<tr class="separator:a81fb3260920d79a73457a7838c3e37ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f698ad8cce282ebcacd849661f52c6"><td class="memItemLeft" align="right" valign="top"><a id="ae5f698ad8cce282ebcacd849661f52c6"></a>
vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#ae5f698ad8cce282ebcacd849661f52c6">fixedData_</a></td></tr>
<tr class="memdesc:ae5f698ad8cce282ebcacd849661f52c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer to hold fixed-size pieces, and the index of var size pieces (if any). <br /></td></tr>
<tr class="separator:ae5f698ad8cce282ebcacd849661f52c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272153eb22f0ebde6ad5d533db80142b"><td class="memItemLeft" align="right" valign="top"><a id="a272153eb22f0ebde6ad5d533db80142b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a272153eb22f0ebde6ad5d533db80142b">fixedDataSizeNeeded_</a> {}</td></tr>
<tr class="memdesc:a272153eb22f0ebde6ad5d533db80142b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte count for all the fixed size pieces + var size index. <br /></td></tr>
<tr class="separator:a272153eb22f0ebde6ad5d533db80142b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ca8e269a7366ae79464ab7d4b9f389"><td class="memItemLeft" align="right" valign="top"><a id="af3ca8e269a7366ae79464ab7d4b9f389"></a>
vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#af3ca8e269a7366ae79464ab7d4b9f389">varData_</a></td></tr>
<tr class="memdesc:af3ca8e269a7366ae79464ab7d4b9f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer holding variable-size pieces, after they've been collected, or read from disk. <br /></td></tr>
<tr class="separator:af3ca8e269a7366ae79464ab7d4b9f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876ccbe0a33909ca31813035554efd83"><td class="memItemLeft" align="right" valign="top"><a id="a876ccbe0a33909ca31813035554efd83"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#a876ccbe0a33909ca31813035554efd83">hasAllRequiredPieces_</a> {true}</td></tr>
<tr class="memdesc:a876ccbe0a33909ca31813035554efd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells all the required pieces have been mapped successfully. <br /></td></tr>
<tr class="separator:a876ccbe0a33909ca31813035554efd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07462306150f59648155162db10c7bb"><td class="memItemLeft" align="right" valign="top"><a id="af07462306150f59648155162db10c7bb"></a>
<a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_layout.html#af07462306150f59648155162db10c7bb">mappedDataLayout_</a> {}</td></tr>
<tr class="memdesc:af07462306150f59648155162db10c7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> this layout has been mapped to, if any. <br /></td></tr>
<tr class="separator:af07462306150f59648155162db10c7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac1253f0ce2dcfe7f11fd8e5a7249912b"><td class="memItemLeft" align="right" valign="top"><a id="ac1253f0ce2dcfe7f11fd8e5a7249912b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>internal::DataLayouter</b></td></tr>
<tr class="separator:ac1253f0ce2dcfe7f11fd8e5a7249912b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee33e854060cd2fc32c4042e6ff9296"><td class="memItemLeft" align="right" valign="top"><a id="a1ee33e854060cd2fc32c4042e6ff9296"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DataPiece</b></td></tr>
<tr class="separator:a1ee33e854060cd2fc32c4042e6ff9296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0ef4227e880d3f33ae2ff3860db586"><td class="memTemplParams" colspan="2"><a id="a6d0ef4227e880d3f33ae2ff3860db586"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d0ef4227e880d3f33ae2ff3860db586"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DataPieceValue</b></td></tr>
<tr class="separator:a6d0ef4227e880d3f33ae2ff3860db586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada671fa88bbe00dae9e9c521218a95e9"><td class="memTemplParams" colspan="2"><a id="ada671fa88bbe00dae9e9c521218a95e9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ada671fa88bbe00dae9e9c521218a95e9"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DataPieceArray</b></td></tr>
<tr class="separator:ada671fa88bbe00dae9e9c521218a95e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d58f6e6b24adcb60f376aa5fbfa3a"><td class="memTemplParams" colspan="2"><a id="a416d58f6e6b24adcb60f376aa5fbfa3a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a416d58f6e6b24adcb60f376aa5fbfa3a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DataPieceVector</b></td></tr>
<tr class="separator:a416d58f6e6b24adcb60f376aa5fbfa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2770adc7dd33e76f55d735b7078746a0"><td class="memTemplParams" colspan="2"><a id="a2770adc7dd33e76f55d735b7078746a0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2770adc7dd33e76f55d735b7078746a0"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DataPieceStringMap</b></td></tr>
<tr class="separator:a2770adc7dd33e76f55d735b7078746a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cf25ef1a8640cbf9f66bdff76876a1"><td class="memItemLeft" align="right" valign="top"><a id="a32cf25ef1a8640cbf9f66bdff76876a1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DataPieceString</b></td></tr>
<tr class="separator:a32cf25ef1a8640cbf9f66bdff76876a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> class describes the data stored inside a DataLayoutContentBlock. </p>
<p>A <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> object is usually constructed using <a class="el" href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format.">AutoDataLayout</a> and <a class="el" href="classvrs_1_1_auto_data_layout_end.html" title="For use within an AutoDataLayout class, to end the AutoDataLayout&#39;s construction.">AutoDataLayoutEnd</a> helpers. This method allows the easy &amp; safe definition of a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> in the form of a struct. The member variables of an <a class="el" href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format.">AutoDataLayout</a> allow the easy access of the individual pieces of content that make up a DataLayoutContentBlock, both for writing &amp; reading.</p>
<p>Note that though <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> objects may look like structs, constructing them is relatively expensive, and creating <a class="el" href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format.">AutoDataLayout</a> objects involve a synchronisation lock. Therefore, avoid creating &amp; destroying using short lived <a class="el" href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format.">AutoDataLayout</a> stack variables. Instead, prefer allocating the <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> objects you will need frequently as member variables of other classes that are long lived.</p>
<p>A <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> object can generate a json representation of itself, that is stored by VRS as an internal tag of a VRS record stream. This json data will be used when reading the VRS file to interpret the data of the corresponding DataLayoutContentBlock. The instantiation of a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> from a json message is meant for exclusive use by VRS itself, when reading a file. VRS is very careful to only do this json expensive deserialization once per type.</p>
<p>The key feature of <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> is the separation of the layout description saved once per stream, from the actual payload in each record, which can be minimal, containing only binary data. The <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> sections of records are not stored in json format.</p>
<p>Most methods of this class are meant for exclusive use by VRS itself, even if they are public.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Anatomy of a DataLayout</h1>
<p>A <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> is an ordered collection of individual pieces of data, all deriving from the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> abstract class. Classes deriving from <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> fall in two categories: Fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects, and variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects.</p>
<p>Fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects, use the same number of bytes, no matter the actual value:</p><ul>
<li>single values of the supported POD types.</li>
<li>fixed size arrays of the supported POD types.</li>
</ul>
<p><a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> supports the following POD types:</p><ul>
<li>native C/C++ types, like int8, int16, int32, int64, signed or unsigned, float &amp; double.</li>
<li><a class="el" href="classvrs_1_1_bool.html" title="Substitute for bool POD type, which can be used safely in DataPiece templates.">Bool</a>, which is a replacement for bool, because vector&lt;bool&gt; is not an STL container, see <a href="https://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container">https://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container</a></li>
<li>2, 3 &amp; 4 D points, 3 &amp; 4 D matrices, of types int32, float &amp; double, for instance: Point2Df: a 2 dimension point using float. Matrix4Dd: a 4 dimension matrix using double.</li>
</ul>
<p>DataPieceValue&lt;T&gt; and DataPieceArray&lt;T&gt; are the two fixed size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> template classes.</p>
<p>Note: You can not use <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> template types with your own POD types, because:</p><ol type="1">
<li><a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> needs a factory able to instantiate them, even when your code isn't around,</li>
<li>it would defeat the purpose of handling format changes, as any change made to your POD type would have to be versioned &amp; managed by hand.</li>
</ol>
<p>Variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects use a number of bytes that depends on their actual value:</p><ul>
<li>DataPieceVector&lt;T&gt;: a vector of any of the supported POD types, or std::string.</li>
<li>DataPieceStringMap&lt;T&gt;: a string map of any of the supported POD types, or std::string.</li>
<li><a class="el" href="classvrs_1_1_data_piece_string.html" title="DataPiece for variable length string.">DataPieceString</a>: an ASCII or utf8 text string.</li>
</ul>
<p>Internal representation (what you don't need to know unless you are working on <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>)</p>
<p>Because there is a known fixed number of fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects, each of known size, we can pre-allocate a buffer to hold the data values of all those <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects. Fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects reference their data using an offset and the size of their data. All read &amp; write value operations on fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects use that buffer, so that we can directly read from and write to disk that part of a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>'s data. That buffer is the first section of the fixedData_ byte vector.</p>
<p>For variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects, because the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> data has an unforeseeable size, data reads &amp; writes are not handled the same as for fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects. Variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects don't have setter methods, but "stage" methods, that set the value in a field of the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> object itself. The "stage" methods also allows to read the staged values. Once the value of all the variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects are staged, the staged values can be collected in a buffer, the varData_ byte vector. To interpret a variable size buffer read from disk, we need an index, to know where each piece starts, and their size. That's the variable size index. The size of that index is known ahead of time, since there is one index entry per variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a>, and we know up-front how many we have. The index is stored in the fixedData_ vector, after the data of fixed-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> values. The values of the index are set when the variable size data is collected. When reading the value of a variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a>, the varData_ buffer is used, if present.</p>
<p>To write a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> section, the 3 following operations are needed:</p><ol type="1">
<li>collect the variable-size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> values. That operations allocates the varData_ buffer, and updates the var data index in the fixedData_ buffer.</li>
<li>write the fixedData_ buffer.</li>
<li>write the varData_ buffer.</li>
</ol>
<p>Therefore, to read &amp; write the data of a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> from &amp; to disk, there is no encoding of the data, unlike with json, which guaranties the bit accuracy of your data. That can be critically important when using float &amp; double numbers.</p>
<p>Of course, all of this is the responsibility of VRS itself. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4b397a6aba99ed3279f685e65672738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b397a6aba99ed3279f685e65672738">&#9670;&nbsp;</a></span>~DataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vrs::DataLayout::~DataLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> has no virtual method, but it is used in containers, and some of its derived classes have important clean-up work to do in their destructor. Therefore, <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> requires a virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0bc2c897c4a70bdb4b17447a6e101e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc2c897c4a70bdb4b17447a6e101e59">&#9670;&nbsp;</a></span>asJson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrs::DataLayout::asJson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_json_format_profile_spec.html">JsonFormatProfileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>profile</em> = <code><a class="el" href="structvrs_1_1_json_format_profile_spec.html">JsonFormatProfileSpec</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate json representation of this layout, using a profile telling which fields to include, and other presentation options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profile</td><td>Formatting profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>json text string. </dd></dl>

</div>
</div>
<a id="af09ce83ef49d3ddceed7399dedfaf108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09ce83ef49d3ddceed7399dedfaf108">&#9670;&nbsp;</a></span>asJson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrs::DataLayout::asJson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ab5a2876628d1cfe8288aa4d4b557d433">JsonFormatProfile</a>&#160;</td>
          <td class="paramname"><em>profile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate json representation of this layout, using a profile telling which fields to include, and other presentation options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profile</td><td>Formatting profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>json text string. </dd></dl>

</div>
</div>
<a id="a9996c20a5c837693bdca551244345981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9996c20a5c837693bdca551244345981">&#9670;&nbsp;</a></span>collectVariableDataAndUpdateIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::collectVariableDataAndUpdateIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect all the variable-size fields in the varData_ buffer. </p>

</div>
</div>
<a id="a6c65732cad53b2fdd41df6b2fba0a1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c65732cad53b2fdd41df6b2fba0a1b9">&#9670;&nbsp;</a></span>collectVariableDataAndUpdateIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::collectVariableDataAndUpdateIndex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect variable-size data to the buffer specified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Pointer to the buffer. The buffer must be at least <a class="el" href="classvrs_1_1_data_layout.html#ac7f678feccf08d032de31f630c18909e">getVarDataSizeNeeded()</a> large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79f18fa9b47bbf506a78478d1bdc3c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f18fa9b47bbf506a78478d1bdc3c66">&#9670;&nbsp;</a></span>copyClonedDataPieceValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::DataLayout::copyClonedDataPieceValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>originalLayout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When a layout was cloned from another layout - this must be true -, this method will copy or stage all the data piece values from the original layout, so edits can be made and a new record generated with the <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>, using the values from originalLayout when possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalLayout</td><td>cloned datalayout from which <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> values need to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the copy was successful, false if the layout isn't a clone of originalLayout. </dd></dl>

</div>
</div>
<a id="a4c292e7878552ee6eaf6878857275a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c292e7878552ee6eaf6878857275a7d">&#9670;&nbsp;</a></span>findDataPieceArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a>&lt; T &gt; * vrs::DataLayout::findDataPieceArray </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a field of type DataPieceArray&lt;T&gt; by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text name of the field (not the variable name). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> found, or nullptr. </dd></dl>

</div>
</div>
<a id="abd325dd774eaf4d39a583519a52497eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd325dd774eaf4d39a583519a52497eb">&#9670;&nbsp;</a></span>findDataPieceString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrs_1_1_data_piece_string.html">DataPieceString</a> * vrs::DataLayout::findDataPieceString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a field of type <a class="el" href="classvrs_1_1_data_piece_string.html" title="DataPiece for variable length string.">DataPieceString</a> by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text name of the field (not the variable name). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> found, or nullptr. </dd></dl>

</div>
</div>
<a id="adba42814893dcc0463425f266b5db756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba42814893dcc0463425f266b5db756">&#9670;&nbsp;</a></span>findDataPieceStringMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template const <a class="el" href="classvrs_1_1_data_piece_string_map.html">DataPieceStringMap</a>&lt; string &gt; * vrs::DataLayout::findDataPieceStringMap&lt; string &gt; </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a field of type DataPieceStringMap&lt;T&gt; by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text name of the field (not the variable name). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> found, or nullptr. </dd></dl>

</div>
</div>
<a id="a1d705e50213a587aa4a06c59a8f371ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d705e50213a587aa4a06c59a8f371ed">&#9670;&nbsp;</a></span>findDataPieceValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrs_1_1_data_piece_value.html">DataPieceValue</a>&lt; T &gt; * vrs::DataLayout::findDataPieceValue </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a field of type DataPieceValue&lt;T&gt; by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text name of the field (not the variable name). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> found, or nullptr. </dd></dl>

</div>
</div>
<a id="ac7727bd32b2c5f1a1dbc7ed6ed569afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7727bd32b2c5f1a1dbc7ed6ed569afc">&#9670;&nbsp;</a></span>findDataPieceVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template const <a class="el" href="classvrs_1_1_data_piece_vector.html">DataPieceVector</a>&lt; string &gt; * vrs::DataLayout::findDataPieceVector&lt; string &gt; </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a field of type DataPieceVector&lt;T&gt; by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text name of the field (not the variable name). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> found, or nullptr. </dd></dl>

</div>
</div>
<a id="a3bae4f6fce9f01b89665c6684e39fc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bae4f6fce9f01b89665c6684e39fc5d">&#9670;&nbsp;</a></span>forEachDataPiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::forEachDataPiece </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> *)&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#afb0b040e753b40173e69f247afa430a2">DataPieceType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespacevrs.html#afb0b040e753b40173e69f247afa430a2aec0fc0100c4fc1ce4eea230c3dc10360">DataPieceType::Undefined</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the different data piece elements of a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a function to call for each element found. </td></tr>
    <tr><td class="paramname">type</td><td>filter to select only an element type, of UNDEFINED for no filtering. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a146d8be64c1e0533c4b32f9aaa1ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a146d8be64c1e0533c4b32f9aaa1ce9">&#9670;&nbsp;</a></span>getAvailableFixedDataPiecesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getAvailableFixedDataPiecesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For debugging: get the number of fixed size data pieces available. When a datalayout is mapped on another one (when reading from disk), some pieces might not be available, because the datalayout read from disk might not have them. </p><dl class="section return"><dt>Returns</dt><dd>The number of fixed size data pieces available in this datalayout. </dd></dl>

</div>
</div>
<a id="a74b4974793ac022b5de99b84f13cdcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b4974793ac022b5de99b84f13cdcd5">&#9670;&nbsp;</a></span>getAvailableVarDataPiecesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getAvailableVarDataPiecesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For debugging: get the number of variable size data pieces available. When a datalayout is mapped on another one (when reading from disk), some pieces might not be available, because the datalayout read from disk might not have them. </p><dl class="section return"><dt>Returns</dt><dd>The number of variable size data pieces available in this datalayout. </dd></dl>

</div>
</div>
<a id="a7ba3915c662bb4207b29b1549ce4eaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba3915c662bb4207b29b1549ce4eaeb">&#9670;&nbsp;</a></span>getContentBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_content_block.html">ContentBlock</a> vrs::DataLayout::getContentBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classvrs_1_1_content_block.html" title="Specification of a VRS record content block.">ContentBlock</a> object to build a <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> definition. </dd></dl>

</div>
</div>
<a id="ae20858fc82bc6bb5905d4e9c2bef3d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20858fc82bc6bb5905d4e9c2bef3d3e">&#9670;&nbsp;</a></span>getDeclaredFixedDataPiecesCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getDeclaredFixedDataPiecesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For debugging: get the number of fixed size data pieces declared. </p><dl class="section return"><dt>Returns</dt><dd>The number of fixed size data pieces declared in this datalayout. </dd></dl>

</div>
</div>
<a id="addb9968e5dd02fdc88e8b4af2942e151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb9968e5dd02fdc88e8b4af2942e151">&#9670;&nbsp;</a></span>getDeclaredVarDataPiecesCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getDeclaredVarDataPiecesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For debugging: get the number of variable size data pieces declared. </p><dl class="section return"><dt>Returns</dt><dd>The number of variable size data pieces declared in this datalayout. </dd></dl>

</div>
</div>
<a id="ab5da451522713cb1621f4f19fd700798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5da451522713cb1621f4f19fd700798">&#9670;&nbsp;</a></span>getFixedData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int8_t&gt;&amp; vrs::DataLayout::getFixedData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To access the buffer for fixed-size DataPieces. No need for a const version. </p>

</div>
</div>
<a id="ab6ae2e3dd02cdbad0753884a22cdecba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ae2e3dd02cdbad0753884a22cdecba">&#9670;&nbsp;</a></span>getFixedData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* vrs::DataLayout::getFixedData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get pointer to a section of raw memory, by offset &amp; size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset of the field in the fixed-size fields buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Byte count size of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer, or nullptr if the whole field won't fit in the buffer. </dd></dl>

</div>
</div>
<a id="a9530bd3c929fa74584187082c62681c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9530bd3c929fa74584187082c62681c6">&#9670;&nbsp;</a></span>getFixedDataSizeNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getFixedDataSizeNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size required to fit all fixed size data. </p>

</div>
</div>
<a id="adca5cfc4c97bc2d3735de4814f529ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca5cfc4c97bc2d3735de4814f529ecd">&#9670;&nbsp;</a></span>getRawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::getRawData </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>outRawData</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get this layout's raw data. Assumes no data needs to be collected (nothing was "staged"). In particular, can be used in <a class="el" href="classvrs_1_1_record_format_stream_player.html" title="Specialized StreamPlayer designed to handle records which format is managed by RecordFormat,...">RecordFormatStreamPlayer</a>'s callback to copy the layout verbatim. </p>

</div>
</div>
<a id="aa3d55915862aa73a896aa8872cb1425a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d55915862aa73a896aa8872cb1425a">&#9670;&nbsp;</a></span>getVarData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int8_t&gt;&amp; vrs::DataLayout::getVarData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To access the buffer for variable-size DataPices. No need for a const version. </p>

</div>
</div>
<a id="a1998346c153423968acbcf53703c29cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1998346c153423968acbcf53703c29cc">&#9670;&nbsp;</a></span>getVarData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* vrs::DataLayout::getVarData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>varPieceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get pointer &amp; size of a variable-size field's data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varPieceIndex</td><td>Index of the variable-size piece. </td></tr>
    <tr><td class="paramname">outCount</td><td>Reference to set to the size in bytes of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the variable-size data found, or nullptr. </dd></dl>

</div>
</div>
<a id="a26a809ebc83c33ffc0cee816400598f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a809ebc83c33ffc0cee816400598f4">&#9670;&nbsp;</a></span>getVarDataSizeFromIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getVarDataSizeFromIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve size of the var size pieces <em>from the index</em>.</p>
<p>Only really meaningful after variable-size pieces:</p><ul>
<li>have been collected, or</li>
<li>the layout's data has been read from disk, or</li>
<li>after the layout has been mapped onto another layout. <dl class="section return"><dt>Returns</dt><dd>Byte count. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ac7f678feccf08d032de31f630c18909e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f678feccf08d032de31f630c18909e">&#9670;&nbsp;</a></span>getVarDataSizeNeeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vrs::DataLayout::getVarDataSizeNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Size to fit the variable-size data written to its variable-size DataPieces fields. Won't match varData_'s size, unless <a class="el" href="classvrs_1_1_data_layout.html#a9996c20a5c837693bdca551244345981">collectVariableDataAndUpdateIndex()</a> was called. </dd></dl>

</div>
</div>
<a id="aa4d5e5f17e2a7d4805a788101fceac15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5e5f17e2a7d4805a788101fceac15">&#9670;&nbsp;</a></span>getVarSizeIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_data_layout_1_1_index_entry.html">DataLayout::IndexEntry</a> * vrs::DataLayout::getVarSizeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the var size index. </p><dl class="section return"><dt>Returns</dt><dd>The var-size index, non-const version. </dd></dl>

</div>
</div>
<a id="a6f6298d164cb87da3ffef67081a88005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6298d164cb87da3ffef67081a88005">&#9670;&nbsp;</a></span>getVarSizeIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrs_1_1_data_layout_1_1_index_entry.html">DataLayout::IndexEntry</a> * vrs::DataLayout::getVarSizeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the var size index. </p><dl class="section return"><dt>Returns</dt><dd>The var-size index, const version. </dd></dl>

</div>
</div>
<a id="a175a4330636088850d075e9a384c3b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175a4330636088850d075e9a384c3b04">&#9670;&nbsp;</a></span>hasAllRequiredPieces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::DataLayout::hasAllRequiredPieces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the layout is mapped to another layout, and all the fields marked required have been successfully mapped onto a field of the target layout. Also returns True if the layout isn't mapped to another layout but has been initialized successfully by dataLayoutEnd(), <a class="el" href="classvrs_1_1_data_layout.html#a0c01f8d2c61225c4c481a90b8e8f496e">initLayout()</a>, and, for subclasses of <a class="el" href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format.">AutoDataLayout</a>, by the customary extra <a class="el" href="classvrs_1_1_auto_data_layout_end.html" title="For use within an AutoDataLayout class, to end the AutoDataLayout&#39;s construction.">AutoDataLayoutEnd</a> field added to the end of every <a class="el" href="classvrs_1_1_auto_data_layout.html" title="Specialized DataLayout class to declare a DataLayout in struct format.">AutoDataLayout</a>. </dd></dl>

</div>
</div>
<a id="a0c01f8d2c61225c4c481a90b8e8f496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c01f8d2c61225c4c481a90b8e8f496e">&#9670;&nbsp;</a></span>initLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::initLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After construction of a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>, initializes/resets buffers to hold the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects that have been registered for this <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>. This is generally, done automatically by VRS, but this might be useful for client code to manage a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> creation manually. In common practice, this is probably only needed for VRS code itself. </p>

</div>
</div>
<a id="a92ad484922bc554f7589b9d90fc1d37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad484922bc554f7589b9d90fc1d37b">&#9670;&nbsp;</a></span>isMapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::DataLayout::isMapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the layout is mapped to another layout, in which case read values will come from the fields of the mapped layout. </dd></dl>

</div>
</div>
<a id="a8699303fb82de2f0f380fa7b09dcaafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8699303fb82de2f0f380fa7b09dcaafe">&#9670;&nbsp;</a></span>isSame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::DataLayout::isSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>otherLayout</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two layouts, and tells if all the pieces are in the same order, with the same properties (name, type, tags, etc). Does not compare actual values! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherLayout</td><td>Layout to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the layouts are equivalent. </dd></dl>

</div>
</div>
<a id="aa02e21cb0c063a1bd598f1de3731f28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02e21cb0c063a1bd598f1de3731f28a">&#9670;&nbsp;</a></span>isVarDataIndexValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::DataLayout::isVarDataIndexValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For debugging: validate that the index for the variable size data looks valid. If you think you need this in production code, please contact the VRS team... </p><dl class="section return"><dt>Returns</dt><dd>True if the index for the variable size data looks valid. </dd></dl>

</div>
</div>
<a id="a07c244202d11ecb0c4f067b495c314ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c244202d11ecb0c4f067b495c314ec">&#9670;&nbsp;</a></span>makeFromJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &gt; vrs::DataLayout::makeFromJson </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> from a json description generated with <a class="el" href="classvrs_1_1_data_layout.html#af09ce83ef49d3ddceed7399dedfaf108">asJson()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>json datalayout description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>, or nullptr in case of error. </dd></dl>

</div>
</div>
<a id="ad4518e893adf3740ca410f599423ba94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4518e893adf3740ca410f599423ba94">&#9670;&nbsp;</a></span>mapLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::DataLayout::mapLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>targetLayout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the data pieces of this layout to that of another layout, field by field. Note that this call is fairly expensive, and it is normally not necessary to call directly. In particular, in the callback <a class="el" href="classvrs_1_1_record_format_stream_player.html#a0a1b16d4ad7226eac26ebb119702d08f">RecordFormatStreamPlayer::onDataLayoutRead()</a>, calling <a class="el" href="classvrs_1_1_data_layout.html#ad4518e893adf3740ca410f599423ba94">mapLayout()</a> directly can usually be avoided by using the methods RecordFormatStreamPlayer::getExpectedLayout() and RecordFormatStreamPlayer::getLegacyLayout(), which will cache the mapping for you. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetLayout</td><td>Other <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> to map each <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> to. This is usually the layout that contains a record's actual data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all <em>required</em> DataPieces were found. When returning false, all possible matches are still made, and a false return value doesn't mean that the mapping "failed". It only means that some (or all) the DataPieces that have been explicitly marked as required have not been found in the target layout. This result value is cached and returned by <a class="el" href="classvrs_1_1_data_layout.html#a175a4330636088850d075e9a384c3b04">hasAllRequiredPieces()</a>. Again, DataPieces are NOT marked required by default, so you must call DataPiece::setRequired(true) for each <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> you require, or call <a class="el" href="classvrs_1_1_data_layout.html#a4348e63174acddf99cf5bcdeb115152b" title="Mark all the fields of the layout as required.">DataLayout::requireAllPieces()</a> to require them all in one shot. A good place to do this is probably your <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>'s constructor itself. </dd></dl>

</div>
</div>
<a id="adc2cff196811d7183daab96236fe4e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2cff196811d7183daab96236fe4e32">&#9670;&nbsp;</a></span>printLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::printLayout </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>indent</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the fields of this <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>, showing all known details &amp; values. If the layout is mapped, the values are that of the mapped fields. If a field of a mapped layout wasn't successfully mapped, no value is shown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Ostream to write to. </td></tr>
    <tr><td class="paramname">indent</td><td>Prefix to each output line, for nested presentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a476d06cdb839d26cad1e2e3f1868c79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476d06cdb839d26cad1e2e3f1868c79c">&#9670;&nbsp;</a></span>printLayoutCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::printLayoutCompact </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>indent</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the values of the fields of this datalayout, in a compact form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Ostream to write to. </td></tr>
    <tr><td class="paramname">indent</td><td>Prefix to each output line, for nested presentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a907d12434ea7849ba9df9b9f3e86313e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907d12434ea7849ba9df9b9f3e86313e">&#9670;&nbsp;</a></span>stageCurrentValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::DataLayout::stageCurrentValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the values of the variable size fields and stage them. This is basically the opposite of <a class="el" href="classvrs_1_1_data_layout.html#a9996c20a5c837693bdca551244345981">collectVariableDataAndUpdateIndex()</a>. This is useful if you have read a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> from disk, and want to edit some fields to write an edited version of the <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_data_layout_8h_source.html">DataLayout.h</a></li>
<li>vrs/DataLayout.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

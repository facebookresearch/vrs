<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::FileHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classvrs_1_1_file_handler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vrs::FileHandler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to abstract VRS file system operations, to enable support for alternate storage methods, in particular network/cloud storage implementations.  
 <a href="classvrs_1_1_file_handler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_file_handler_8h_source.html">FileHandler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrs::FileHandler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvrs_1_1_file_handler.png" usemap="#vrs::FileHandler_map" alt=""/>
  <map id="vrs::FileHandler_map" name="vrs::FileHandler_map">
<area href="classvrs_1_1_file_delegator.html" title="Class to abstract the delegate file open operation for VRS file." alt="vrs::FileDelegator" shape="rect" coords="0,0,169,24"/>
<area href="classvrs_1_1_write_file_handler.html" title="The WriteFileHandler interface adds write operations to the FileHandler interface." alt="vrs::WriteFileHandler" shape="rect" coords="0,112,169,136"/>
<area href="classvrs_1_1_disk_file_t.html" title="FileHandler implementation for disk files, with chunked file support." alt="vrs::DiskFileT&lt; FileChunk &gt;" shape="rect" coords="0,168,169,192"/>
<area href="classvrs_1_1_atomic_disk_file.html" alt="vrs::AtomicDiskFile" shape="rect" coords="0,224,169,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvrs_1_1_file_handler_1_1_cache_stats.html">CacheStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for cache.  <a href="structvrs_1_1_file_handler_1_1_cache_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4d90cd8352b33088933df68d02572fdb"><td class="memItemLeft" align="right" valign="top"><a id="a4d90cd8352b33088933df68d02572fdb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CacheStatsCallbackFunction</b> = std::function&lt; void(const <a class="el" href="structvrs_1_1_file_handler_1_1_cache_stats.html">CacheStats</a> &amp;stats)&gt;</td></tr>
<tr class="separator:a4d90cd8352b33088933df68d02572fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9e142b78b30f3e03cc6bfd4ac4aad5e"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ac9e142b78b30f3e03cc6bfd4ac4aad5e">makeNew</a> () const =0</td></tr>
<tr class="separator:ac9e142b78b30f3e03cc6bfd4ac4aad5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac5815963b947148709f7c8e8325ed0"><td class="memItemLeft" align="right" valign="top"><a id="a2ac5815963b947148709f7c8e8325ed0"></a>
virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getFileHandlerName</b> () const =0</td></tr>
<tr class="separator:a2ac5815963b947148709f7c8e8325ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8cce8cea6320affac819d063705d9b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#acc8cce8cea6320affac819d063705d9b">open</a> (const string &amp;filePath)</td></tr>
<tr class="separator:acc8cce8cea6320affac819d063705d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaafaf72028776e1868b6d69a1210902"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#aaaafaf72028776e1868b6d69a1210902">openSpec</a> (const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;fileSpec)=0</td></tr>
<tr class="separator:aaaafaf72028776e1868b6d69a1210902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c9ecdcaec465eded60d96890b23670"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a29c9ecdcaec465eded60d96890b23670">delegateOpen</a> (const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;fileSpec, unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt; &amp;outNewDelegate) override</td></tr>
<tr class="separator:a29c9ecdcaec465eded60d96890b23670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a506f20a4a8612d710fe5c57fee2e4e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a9a506f20a4a8612d710fe5c57fee2e4e">isOpened</a> () const =0</td></tr>
<tr class="separator:a9a506f20a4a8612d710fe5c57fee2e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2145daea7adfb70f991cf4d7cf1262e3"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a2145daea7adfb70f991cf4d7cf1262e3">getTotalSize</a> () const =0</td></tr>
<tr class="separator:a2145daea7adfb70f991cf4d7cf1262e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110dcfe731d9a1e1c6b2a8069271554"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ae110dcfe731d9a1e1c6b2a8069271554">close</a> ()=0</td></tr>
<tr class="separator:ae110dcfe731d9a1e1c6b2a8069271554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a6383b17a7a60d61a3ad6322f90c1b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a42a6383b17a7a60d61a3ad6322f90c1b">skipForward</a> (int64_t offset)=0</td></tr>
<tr class="separator:a42a6383b17a7a60d61a3ad6322f90c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd0d5b3926fbabf4a925e7b3b8d3eb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#aa5bd0d5b3926fbabf4a925e7b3b8d3eb">setPos</a> (int64_t offset)=0</td></tr>
<tr class="separator:aa5bd0d5b3926fbabf4a925e7b3b8d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084abde45300ff923db012709e3c9df6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a084abde45300ff923db012709e3c9df6">isAvailableOrPrefetch</a> (MAYBE_UNUSED size_t length)</td></tr>
<tr class="separator:a084abde45300ff923db012709e3c9df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089df90a7e403b784abe8d8c144459c7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a089df90a7e403b784abe8d8c144459c7">read</a> (void *buffer, size_t length)=0</td></tr>
<tr class="separator:a089df90a7e403b784abe8d8c144459c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ed4edd6b651c810c71593e4d2f6c1"><td class="memTemplParams" colspan="2"><a id="a862ed4edd6b651c810c71593e4d2f6c1"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_trivially_copyable&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a862ed4edd6b651c810c71593e4d2f6c1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a862ed4edd6b651c810c71593e4d2f6c1">read</a> (T &amp;object)</td></tr>
<tr class="memdesc:a862ed4edd6b651c810c71593e4d2f6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to read trivially copyable objects, in a chunk aware way. <br /></td></tr>
<tr class="separator:a862ed4edd6b651c810c71593e4d2f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2ac008404ab6a71f5b41a13c187e8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ac1c2ac008404ab6a71f5b41a13c187e8">getLastRWSize</a> () const =0</td></tr>
<tr class="separator:ac1c2ac008404ab6a71f5b41a13c187e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe53e88b396758690f2c8754bcb39556"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#afe53e88b396758690f2c8754bcb39556">isReadOnly</a> () const</td></tr>
<tr class="separator:afe53e88b396758690f2c8754bcb39556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8879cb6b12e2c4596590f4145cb15d6e"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; std::pair&lt; string, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a8879cb6b12e2c4596590f4145cb15d6e">getFileChunks</a> () const =0</td></tr>
<tr class="separator:a8879cb6b12e2c4596590f4145cb15d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9641d96edf6649b6662d335a9bac326"><td class="memItemLeft" align="right" valign="top"><a id="ab9641d96edf6649b6662d335a9bac326"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ab9641d96edf6649b6662d335a9bac326">forgetFurtherChunks</a> (int64_t maxSize)=0</td></tr>
<tr class="memdesc:ab9641d96edf6649b6662d335a9bac326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to forget any chunk beyond this file size. <br /></td></tr>
<tr class="separator:ab9641d96edf6649b6662d335a9bac326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eebf7e283161293853e035f7c2c5b5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#af7eebf7e283161293853e035f7c2c5b5">getLastError</a> () const =0</td></tr>
<tr class="separator:af7eebf7e283161293853e035f7c2c5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87363ee322c0b9f7eb2db54a4d816de2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a87363ee322c0b9f7eb2db54a4d816de2">isEof</a> () const =0</td></tr>
<tr class="separator:a87363ee322c0b9f7eb2db54a4d816de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b17626c35777f0b905c70793c032be"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a20b17626c35777f0b905c70793c032be">getPos</a> () const =0</td></tr>
<tr class="separator:a20b17626c35777f0b905c70793c032be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8165bbdead94ea6bc5abd51674b40fe"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#aa8165bbdead94ea6bc5abd51674b40fe">getChunkPos</a> () const =0</td></tr>
<tr class="separator:aa8165bbdead94ea6bc5abd51674b40fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d0cd3d17a0046debcbc37d49e5a084"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ac3d0cd3d17a0046debcbc37d49e5a084">getChunkRange</a> (int64_t &amp;outChunkOffset, int64_t &amp;outChunkSize) const =0</td></tr>
<tr class="separator:ac3d0cd3d17a0046debcbc37d49e5a084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ad8cb958456d4ff23b7103dcc100af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ae8ad8cb958456d4ff23b7103dcc100af">setCachingStrategy</a> (<a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>)</td></tr>
<tr class="separator:ae8ad8cb958456d4ff23b7103dcc100af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df905d36e9a89b467e542a8ae8d6fb4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a9df905d36e9a89b467e542a8ae8d6fb4">getCachingStrategy</a> () const</td></tr>
<tr class="separator:a9df905d36e9a89b467e542a8ae8d6fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde57d88f70a2542cf8139a72f801452"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#acde57d88f70a2542cf8139a72f801452">prefetchReadSequence</a> (MAYBE_UNUSED const vector&lt; std::pair&lt; size_t, size_t &gt;&gt; &amp;sequence, MAYBE_UNUSED bool clearSequence=true)</td></tr>
<tr class="separator:acde57d88f70a2542cf8139a72f801452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab581e6ffbabd7d4da0e991ac60ed4032"><td class="memItemLeft" align="right" valign="top"><a id="ab581e6ffbabd7d4da0e991ac60ed4032"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>setStatsCallback</b> (const CacheStatsCallbackFunction &amp;)</td></tr>
<tr class="separator:ab581e6ffbabd7d4da0e991ac60ed4032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49c80e3f6764c5f5627c61e8d00a3a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#ad49c80e3f6764c5f5627c61e8d00a3a3">purgeCache</a> ()</td></tr>
<tr class="separator:ad49c80e3f6764c5f5627c61e8d00a3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1a9e18368a77be359b1d23360c8ced"><td class="memItemLeft" align="right" valign="top"><a id="a8d1a9e18368a77be359b1d23360c8ced"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFileHandlerMatch</b> (const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;fileSpec) const</td></tr>
<tr class="separator:a8d1a9e18368a77be359b1d23360c8ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace0d5e85bc07729d92b88b8897ef4fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#aace0d5e85bc07729d92b88b8897ef4fd">isRemoteFileSystem</a> () const</td></tr>
<tr class="separator:aace0d5e85bc07729d92b88b8897ef4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9648c85d534485a206c519b931723ffd"><td class="memItemLeft" align="right" valign="top"><a id="a9648c85d534485a206c519b931723ffd"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_handler.html#a9648c85d534485a206c519b931723ffd">showProgress</a> () const</td></tr>
<tr class="memdesc:a9648c85d534485a206c519b931723ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the file handler is probably slow, and extra progress information might be useful. <br /></td></tr>
<tr class="separator:a9648c85d534485a206c519b931723ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvrs_1_1_file_delegator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvrs_1_1_file_delegator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvrs_1_1_file_delegator.html">vrs::FileDelegator</a></td></tr>
<tr class="memitem:a5845c233b0fd236b50b64989743332d7 inherit pub_methods_classvrs_1_1_file_delegator"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_file_delegator.html#a5845c233b0fd236b50b64989743332d7">parseUri</a> (<a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;inOutFileSpec, MAYBE_UNUSED size_t colonIndex) const</td></tr>
<tr class="separator:a5845c233b0fd236b50b64989743332d7 inherit pub_methods_classvrs_1_1_file_delegator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to abstract VRS file system operations, to enable support for alternate storage methods, in particular network/cloud storage implementations. </p>
<p>For simplicity, in this documentation, we will references "files", but they might be one or more data blobs on a network storage.</p>
<p>VRS file users probably only need to use <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> &amp; <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a>, but they have the option to use <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> directly to access files stored on remote file systems, same as VRS. Use <a class="el" href="classvrs_1_1_file_handler_factory.html#a8cc1b86d81f9a65dd1fc6a9caeaaa1e7">FileHandlerFactory::delegateOpen()</a> to find the proper <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> implementation and open a file. <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> only exposes read operations, because it's the most implementation, while <a class="el" href="classvrs_1_1_write_file_handler.html" title="The WriteFileHandler interface adds write operations to the FileHandler interface.">WriteFileHandler</a> extends <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> for write operations. Both are abstract classes.</p>
<p>'int' return values are status codes: 0 means success, while other values are error codes, which can always be converted to a human readable string using vrs::errorCodeToMessage(code). File sizes and offset are specified using int64_t, which is equivalent to the POSIX behavior. Byte counts use size_t. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae110dcfe731d9a1e1c6b2a8069271554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae110dcfe731d9a1e1c6b2a8069271554">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close the file &amp; free all the held resources, even if an error occurs. </p><dl class="section return"><dt>Returns</dt><dd>A status code for first error while closing, or 0, meaning success. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_atomic_disk_file.html#a0d9a0ead2a2bef7b8e6865aa6c8794a9">vrs::AtomicDiskFile</a>, and <a class="el" href="classvrs_1_1_disk_file_t.html#a0e417839a3458a28b044736c332112d6">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a29c9ecdcaec465eded60d96890b23670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c9ecdcaec465eded60d96890b23670">&#9670;&nbsp;</a></span>delegateOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::FileHandler::delegateOpen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outNewDelegate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a file, while giving the opportunity to the <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> to delegate the file operations to another <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a>. With this method, a <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> might decide that another <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> is the right one to open a file, after inspecting the spec, parsing of the path, or lookup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSpec</td><td>file specification. </td></tr>
    <tr><td class="paramname">outNewDelegate</td><td>If provided, might be a fallback <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> to use. On exit, may be set to a different <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> than the current object, if the current <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> was not ultimately the right one to handle the provided path, or cleared if the current <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> should be used to continue accessing the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. Use errorCodeToString() to get an error description. </dd></dl>

<p>Implements <a class="el" href="classvrs_1_1_file_delegator.html#a20ed43d0540c28802acdec6c33001cc6">vrs::FileDelegator</a>.</p>

</div>
</div>
<a id="a9df905d36e9a89b467e542a8ae8d6fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df905d36e9a89b467e542a8ae8d6fb4">&#9670;&nbsp;</a></span>getCachingStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a> vrs::FileHandler::getCachingStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get caching strategy. </p><dl class="section return"><dt>Returns</dt><dd>Caching strategy. </dd></dl>

</div>
</div>
<a id="aa8165bbdead94ea6bc5abd51674b40fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8165bbdead94ea6bc5abd51674b40fe">&#9670;&nbsp;</a></span>getChunkPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t vrs::FileHandler::getChunkPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get position in the current chunk. </p><dl class="section return"><dt>Returns</dt><dd>The current position in the current chunk. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a8a346c1ec887d83e7e29685e7fa7fe13">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="ac3d0cd3d17a0046debcbc37d49e5a084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d0cd3d17a0046debcbc37d49e5a084">&#9670;&nbsp;</a></span>getChunkRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::getChunkRange </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>outChunkOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>outChunkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get range of the current chunk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChunkOffset</td><td>index of the first byte of the chunk. </td></tr>
    <tr><td class="paramname">outChunkSize</td><td>number of bytes in the chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of 0 if the request succeeded, or some error code (no file is open...) </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#afdf2ff75c33f4a7f4637a25ebafb4a49">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a8879cb6b12e2c4596590f4145cb15d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8879cb6b12e2c4596590f4145cb15d6e">&#9670;&nbsp;</a></span>getFileChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual vector&lt;std::pair&lt;string, int64_t&gt; &gt; vrs::FileHandler::getFileChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the list of chunks, path + size. </p><dl class="section return"><dt>Returns</dt><dd>A succession of path-size pairs. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#aeafe76f680270ecfa38dcd4b8869009d">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="af7eebf7e283161293853e035f7c2c5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7eebf7e283161293853e035f7c2c5b5">&#9670;&nbsp;</a></span>getLastError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::getLastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the last error code. </p><dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a6c5ae58cc8b2da70e397ae52edaa4ffb">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="ac1c2ac008404ab6a71f5b41a13c187e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2ac008404ab6a71f5b41a13c187e8">&#9670;&nbsp;</a></span>getLastRWSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t vrs::FileHandler::getLastRWSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of bytes actually moved during the last read or write operation. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes last read or written during the last read or write call. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#ad155db5d5d3fe5285ddcb2aee5b6328d">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a20b17626c35777f0b905c70793c032be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b17626c35777f0b905c70793c032be">&#9670;&nbsp;</a></span>getPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t vrs::FileHandler::getPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the absolute position in the file, in a chunk aware way. </p><dl class="section return"><dt>Returns</dt><dd>The absolute position in the file, including all previous chunks. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#ad0d09bf1522a31e4bde4a3c7d8dc2af6">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a2145daea7adfb70f991cf4d7cf1262e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2145daea7adfb70f991cf4d7cf1262e3">&#9670;&nbsp;</a></span>getTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t vrs::FileHandler::getTotalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the total size of all the chunks considered. </p><dl class="section return"><dt>Returns</dt><dd>The total size of the open file, or 0. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a6c15fe9b8607de09125d9dbeb368a607">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a084abde45300ff923db012709e3c9df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084abde45300ff923db012709e3c9df6">&#9670;&nbsp;</a></span>isAvailableOrPrefetch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrs::FileHandler::isAvailableOrPrefetch </td>
          <td>(</td>
          <td class="paramtype">MAYBE_UNUSED size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a number of bytes are available for immediate return (e.g. on disk or in-cache) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of bytes to check availability of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if available, false if unavailable (e.g. requiring a network fetch) </dd></dl>

</div>
</div>
<a id="a87363ee322c0b9f7eb2db54a4d816de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87363ee322c0b9f7eb2db54a4d816de2">&#9670;&nbsp;</a></span>isEof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrs::FileHandler::isEof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if we are at the end of the last chunk. </p><dl class="section return"><dt>Returns</dt><dd>True if the read/write pointer is past the last byte of the file. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a5b59cde880a5f5c9c90766a36c43db79">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a9a506f20a4a8612d710fe5c57fee2e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a506f20a4a8612d710fe5c57fee2e4e">&#9670;&nbsp;</a></span>isOpened()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrs::FileHandler::isOpened </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if a file is actually open. </p><dl class="section return"><dt>Returns</dt><dd>True if a file is currently open. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a8d2b271cd3b4e4b8b715f1435e174473">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="afe53e88b396758690f2c8754bcb39556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe53e88b396758690f2c8754bcb39556">&#9670;&nbsp;</a></span>isReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::FileHandler::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find out if the file is currently open in read-only mode. </p><dl class="section return"><dt>Returns</dt><dd>True if the file is currently open in read-only mode. Undefined if no file is open. </dd></dl>

<p>Reimplemented in <a class="el" href="classvrs_1_1_write_file_handler.html#a92ad4b6d2cfaa9ceeb9424e49973e9b8">vrs::WriteFileHandler</a>, and <a class="el" href="classvrs_1_1_disk_file_t.html#ae6af25461ccaee83e1a7387210563311">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="aace0d5e85bc07729d92b88b8897ef4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace0d5e85bc07729d92b88b8897ef4fd">&#9670;&nbsp;</a></span>isRemoteFileSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::FileHandler::isRemoteFileSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if the file handler is handling remote data, that might need caching for instance. Because most custom file systems implementation are not local FS, defaults to true! </p>

<p>Reimplemented in <a class="el" href="classvrs_1_1_disk_file_t.html#ad54a270e44916ec092120a3e48e8b026">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="ac9e142b78b30f3e03cc6bfd4ac4aad5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e142b78b30f3e03cc6bfd4ac4aad5e">&#9670;&nbsp;</a></span>makeNew()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a>&gt; vrs::FileHandler::makeNew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a new instance of the concrete class implementing this interface in its default state, no matter what this object's state is, so that we can access more files using the same method. </p><dl class="section return"><dt>Returns</dt><dd>A new object of the concrete type, ready to be used to open a new file. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a72a7d7606866e169ac1f2de182f87e01">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="acc8cce8cea6320affac819d063705d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8cce8cea6320affac819d063705d9b">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::FileHandler::open </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a file in read-only mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>a disk path, or anything that the particular module recognizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. </dd></dl>

</div>
</div>
<a id="aaaafaf72028776e1868b6d69a1210902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaafaf72028776e1868b6d69a1210902">&#9670;&nbsp;</a></span>openSpec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::openSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSpec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a file in read-only mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSpec</td><td>a file spec supported by this file handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#a67d91cd298016f7af4d39bb6f9ef14a1">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="acde57d88f70a2542cf8139a72f801452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde57d88f70a2542cf8139a72f801452">&#9670;&nbsp;</a></span>prefetchReadSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrs::FileHandler::prefetchReadSequence </td>
          <td>(</td>
          <td class="paramtype">MAYBE_UNUSED const vector&lt; std::pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MAYBE_UNUSED bool&#160;</td>
          <td class="paramname"><em>clearSequence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell what read operations are going to happen, so that, if the file handler supports it, data can be cached ahead of time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>a series of (file_offset, length), ordered by anticipated request order. Read request must not happen exactly as described:<ul>
<li>each segment may be read in multiple successive requests</li>
<li>section or entire segments may be skipped entirely Warning: If a read request is made out of order (backward), or outside the sequence, the predictive cache may be disabled, in part or entirely. </li>
</ul>
</td></tr>
    <tr><td class="paramname">clearSequence</td><td>Flag on whether to cancel any pre-existing custom read sequence upon caching starts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file handler support custom read sequences. </dd></dl>

</div>
</div>
<a id="ad49c80e3f6764c5f5627c61e8d00a3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49c80e3f6764c5f5627c61e8d00a3a3">&#9670;&nbsp;</a></span>purgeCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrs::FileHandler::purgeCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Purge read cache buffer, if any. Sets the caching strategy to Passive, and clears any pending read sequence. </p><dl class="section return"><dt>Returns</dt><dd>True if the read caches were cleared (or there were none to begin with). </dd></dl>

</div>
</div>
<a id="a089df90a7e403b784abe8d8c144459c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089df90a7e403b784abe8d8c144459c7">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a number of bytes, in a chunk aware way. If fewer than length bytes can be read, an error code is returned, then use <a class="el" href="classvrs_1_1_file_handler.html#ac1c2ac008404ab6a71f5b41a13c187e8">getLastRWSize()</a> to know how many bytes were really read. If there are too few remaining bytes in the current chunk, then the new chunk is opened and read, until enough data can be read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a buffer to the bytes to write. </td></tr>
    <tr><td class="paramname">length</td><td>the number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success and length bytes were successfully read. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#ac48d2da9f56e2fe3653a8cea28c3fde1">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="ae8ad8cb958456d4ff23b7103dcc100af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ad8cb958456d4ff23b7103dcc100af">&#9670;&nbsp;</a></span>setCachingStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vrs::FileHandler::setCachingStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set caching strategy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CachingStrategy</td><td>Caching strategy desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the caching strategy was set. False if the file handler doesn't support the requested strategy, or any particular strategy. </dd></dl>

</div>
</div>
<a id="aa5bd0d5b3926fbabf4a925e7b3b8d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bd0d5b3926fbabf4a925e7b3b8d3eb">&#9670;&nbsp;</a></span>setPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::setPos </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the file position at an arbitrary position, in a chunk aware way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the absolute position to jump to, which may be forward or backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#acd2ce3f9b4711cc263a4ea5d23bcd4fc">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<a id="a42a6383b17a7a60d61a3ad6322f90c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a6383b17a7a60d61a3ad6322f90c1b">&#9670;&nbsp;</a></span>skipForward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vrs::FileHandler::skipForward </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip a number of bytes further in the file, in a chunk aware way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the number of bytes to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. </dd></dl>

<p>Implemented in <a class="el" href="classvrs_1_1_disk_file_t.html#ad52fbf650b868e0d2db8ac865c470c95">vrs::DiskFileT&lt; FileChunk &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_file_handler_8h_source.html">FileHandler.h</a></li>
<li>vrs/FileHandler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

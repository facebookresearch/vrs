<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::MultiRecordFileReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_multi_record_file_reader.html">MultiRecordFileReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classvrs_1_1_multi_record_file_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vrs::MultiRecordFileReader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Facilitates reading multiple VRS files simultaneously. Records are sorted by timestamps across all the files, therefore it is essential that *** all the files must have their timestamps in the same time domain. *** Operates in a manner similar to <code><a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a></code>, but with multiple files.  
 <a href="classvrs_1_1_multi_record_file_reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_multi_record_file_reader_8h_source.html">MultiRecordFileReader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95c324393b94d95ab8558c25d4c6a999"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> = <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a></td></tr>
<tr class="separator:a95c324393b94d95ab8558c25d4c6a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd667bfca6a0f64d85c6330771c89510"><td class="memItemLeft" align="right" valign="top"><a id="afd667bfca6a0f64d85c6330771c89510"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MultiRecordFileReader</b> (const <a class="el" href="classvrs_1_1_multi_record_file_reader.html">MultiRecordFileReader</a> &amp;)=delete</td></tr>
<tr class="separator:afd667bfca6a0f64d85c6330771c89510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf62d74d8e9ffbb58654da741bccc46"><td class="memItemLeft" align="right" valign="top"><a id="a9cf62d74d8e9ffbb58654da741bccc46"></a>
<a class="el" href="classvrs_1_1_multi_record_file_reader.html">MultiRecordFileReader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classvrs_1_1_multi_record_file_reader.html">MultiRecordFileReader</a> &amp;)=delete</td></tr>
<tr class="separator:a9cf62d74d8e9ffbb58654da741bccc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa871dab921f89d50038bd3bdaf355ba3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aa871dab921f89d50038bd3bdaf355ba3">open</a> (const std::vector&lt; std::string &gt; &amp;paths)</td></tr>
<tr class="separator:aa871dab921f89d50038bd3bdaf355ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11143a227cc23206fa7fbdc84f3c76cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a11143a227cc23206fa7fbdc84f3c76cb">open</a> (const std::vector&lt; <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &gt; &amp;fileSpecs)</td></tr>
<tr class="separator:a11143a227cc23206fa7fbdc84f3c76cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b8e10c675577a8a7d907fa4813af73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a37b8e10c675577a8a7d907fa4813af73">open</a> (const std::string &amp;path)</td></tr>
<tr class="separator:a37b8e10c675577a8a7d907fa4813af73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4edd3bbfb351c3aedd554feae96e77e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aa4edd3bbfb351c3aedd554feae96e77e">open</a> (const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;fileSpec)</td></tr>
<tr class="separator:aa4edd3bbfb351c3aedd554feae96e77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d0e7da59d14619bf2d47f4e9e257f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a80d0e7da59d14619bf2d47f4e9e257f3">close</a> ()</td></tr>
<tr class="separator:a80d0e7da59d14619bf2d47f4e9e257f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d2e06fac1b08114256872edfc7aae"><td class="memItemLeft" align="right" valign="top">const set&lt; <a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aea6d2e06fac1b08114256872edfc7aae">getStreams</a> () const</td></tr>
<tr class="separator:aea6d2e06fac1b08114256872edfc7aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8895c7cf63d0b186d016ed64af130b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a6a8895c7cf63d0b186d016ed64af130b">isOpened</a> () const</td></tr>
<tr class="separator:a6a8895c7cf63d0b186d016ed64af130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb934e64faefb7453ba01746b6285ea8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#afb934e64faefb7453ba01746b6285ea8">getRecordCount</a> () const</td></tr>
<tr class="separator:afb934e64faefb7453ba01746b6285ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191a68096fe97cbbbac17555c247876c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a191a68096fe97cbbbac17555c247876c">getRecordCount</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId) const</td></tr>
<tr class="separator:a191a68096fe97cbbbac17555c247876c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12b3915b19dab1bbff12a050f447322"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#ab12b3915b19dab1bbff12a050f447322">getRecordCount</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType) const</td></tr>
<tr class="separator:ab12b3915b19dab1bbff12a050f447322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30899bd56053e192b6406bf6b88e32b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a30899bd56053e192b6406bf6b88e32b0">getTags</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId) const</td></tr>
<tr class="separator:a30899bd56053e192b6406bf6b88e32b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0308f47472fc886156a613a738293c"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#ada0308f47472fc886156a613a738293c">getTag</a> (const string &amp;name) const</td></tr>
<tr class="separator:ada0308f47472fc886156a613a738293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13794f5958db361c8522cca25e3432cc"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a13794f5958db361c8522cca25e3432cc">getTag</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId, const string &amp;name) const</td></tr>
<tr class="separator:a13794f5958db361c8522cca25e3432cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ea57d1e6dfb6d34d2396841da63886"><td class="memItemLeft" align="right" valign="top">vector&lt; std::pair&lt; string, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#ac9ea57d1e6dfb6d34d2396841da63886">getFileChunks</a> () const</td></tr>
<tr class="separator:ac9ea57d1e6dfb6d34d2396841da63886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebcf4930b83715be9c1a69bb11bcc39"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#afebcf4930b83715be9c1a69bb11bcc39">getFlavor</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId) const</td></tr>
<tr class="separator:afebcf4930b83715be9c1a69bb11bcc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaaa87418f9c7a57b4b8ce4e461604e"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aaaaaa87418f9c7a57b4b8ce4e461604e">getSerialNumber</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId) const</td></tr>
<tr class="separator:aaaaaa87418f9c7a57b4b8ce4e461604e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0bbafddb032b92df48f8862ce12f13"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a4b0bbafddb032b92df48f8862ce12f13">getStreams</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, const string &amp;flavor={}) const</td></tr>
<tr class="separator:a4b0bbafddb032b92df48f8862ce12f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad584f3509b2ba0bfa77c6d3f4f1e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#adad584f3509b2ba0bfa77c6d3f4f1e71">getStreamForName</a> (const string &amp;name) const</td></tr>
<tr class="separator:adad584f3509b2ba0bfa77c6d3f4f1e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f07e2b49133a6c9514767bb3694839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a48f07e2b49133a6c9514767bb3694839">getStreamForTag</a> (const string &amp;tagName, const string &amp;tag, <a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId=<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360">RecordableTypeId::Undefined</a>) const</td></tr>
<tr class="separator:a48f07e2b49133a6c9514767bb3694839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a884be55f4fe7b1469515833fc312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aa17a884be55f4fe7b1469515833fc312">getStreamForSerialNumber</a> (const string &amp;serialNumber) const</td></tr>
<tr class="separator:aa17a884be55f4fe7b1469515833fc312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6dbf733277c8645819646a1585f6e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aaf6dbf733277c8645819646a1585f6e6">getRecordIndex</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *record) const</td></tr>
<tr class="separator:aaf6dbf733277c8645819646a1585f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051712405a9bbc475dda3e5fd01a1c2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aa051712405a9bbc475dda3e5fd01a1c2">getRecord</a> (uint32_t globalIndex) const</td></tr>
<tr class="separator:aa051712405a9bbc475dda3e5fd01a1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f70cf40de6f5c1120c84c709fde6bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a72f70cf40de6f5c1120c84c709fde6bc">getRecord</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId, uint32_t indexNumber) const</td></tr>
<tr class="separator:a72f70cf40de6f5c1120c84c709fde6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa152d4585a0e961077ca230a7c2fc3a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aa152d4585a0e961077ca230a7c2fc3a0">getRecord</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t indexNumber) const</td></tr>
<tr class="separator:aa152d4585a0e961077ca230a7c2fc3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f312cf34eea66355931e1865fc7157"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a71f312cf34eea66355931e1865fc7157">getLastRecord</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType) const</td></tr>
<tr class="separator:a71f312cf34eea66355931e1865fc7157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add7a79d8f60690ebc4574de8700d21"><td class="memItemLeft" align="right" valign="top">const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a7add7a79d8f60690ebc4574de8700d21">getIndex</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId) const</td></tr>
<tr class="separator:a7add7a79d8f60690ebc4574de8700d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f158709855c1aaf0bc58e6db53221f"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a64f158709855c1aaf0bc58e6db53221f">getOriginalRecordableTypeName</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId) const</td></tr>
<tr class="separator:a64f158709855c1aaf0bc58e6db53221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c388c49581ee495666167e68c2b13c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a86c388c49581ee495666167e68c2b13c">setStreamPlayer</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer)</td></tr>
<tr class="separator:a86c388c49581ee495666167e68c2b13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554b6e66413becf3f052ca074440e329"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a554b6e66413becf3f052ca074440e329">getRecordFormats</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId, <a class="el" href="namespacevrs.html#a04d155e698e82b4cd67ec9312fadefb0">RecordFormatMap</a> &amp;outFormats) const</td></tr>
<tr class="separator:a554b6e66413becf3f052ca074440e329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacca4fb96e7495cbe98fede2f301eb16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aacca4fb96e7495cbe98fede2f301eb16">readRecord</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;recordInfo)</td></tr>
<tr class="separator:aacca4fb96e7495cbe98fede2f301eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f20bf1635f99f7128dc7142b41282"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a437f20bf1635f99f7128dc7142b41282">readRecord</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;recordInfo, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *player, bool setupPlayer)</td></tr>
<tr class="separator:a437f20bf1635f99f7128dc7142b41282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b59a8b0be71cf99c84c806ab998c822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a3b59a8b0be71cf99c84c806ab998c822">setCachingStrategy</a> (<a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a> cachingStrategy)</td></tr>
<tr class="separator:a3b59a8b0be71cf99c84c806ab998c822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca088a2b7060e463b7cbd4b06309efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#adca088a2b7060e463b7cbd4b06309efc">getCachingStrategy</a> () const</td></tr>
<tr class="separator:adca088a2b7060e463b7cbd4b06309efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a7f1918e2a599e9b2cdc3d4349451c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a64a7f1918e2a599e9b2cdc3d4349451c">prefetchRecordSequence</a> (const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp;records, bool clearSequence=true)</td></tr>
<tr class="separator:a64a7f1918e2a599e9b2cdc3d4349451c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335628545d95143a04d74f3fb6cd87ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a335628545d95143a04d74f3fb6cd87ca">isRecordAvailableOrPrefetch</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;record) const</td></tr>
<tr class="separator:a335628545d95143a04d74f3fb6cd87ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c8eec112569f67ebb9a213f61178d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a36c8eec112569f67ebb9a213f61178d9">purgeFileCache</a> ()</td></tr>
<tr class="separator:a36c8eec112569f67ebb9a213f61178d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6722cc31e14463ee340c6fcb783358f7"><td class="memItemLeft" align="right" valign="top">const map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a6722cc31e14463ee340c6fcb783358f7">getTags</a> () const</td></tr>
<tr class="separator:a6722cc31e14463ee340c6fcb783358f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712d988af2c649c510e9323891a94223"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a712d988af2c649c510e9323891a94223">getFirstRecord</a> (<a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType) const</td></tr>
<tr class="separator:a712d988af2c649c510e9323891a94223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe784110e9ced6fdc5f2ab8c86f53e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aebe784110e9ced6fdc5f2ab8c86f53e8">getLastRecord</a> (<a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType) const</td></tr>
<tr class="separator:aebe784110e9ced6fdc5f2ab8c86f53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e52455f81858bd3f09655112ad513c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a15e52455f81858bd3f09655112ad513c">getRecordByTime</a> (double timestamp) const</td></tr>
<tr class="separator:a15e52455f81858bd3f09655112ad513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ce7e2786f5fe7d98dd9ef0fccb19b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a0a4ce7e2786f5fe7d98dd9ef0fccb19b">getRecordByTime</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> streamId, double timestamp) const</td></tr>
<tr class="separator:a0a4ce7e2786f5fe7d98dd9ef0fccb19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd496fba11f07e4919cf48a704d3097"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a5cd496fba11f07e4919cf48a704d3097">getRecordByTime</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, double timestamp) const</td></tr>
<tr class="separator:a5cd496fba11f07e4919cf48a704d3097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8cede54de2802bfb082a0b421f616b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a1d8cede54de2802bfb082a0b421f616b">getNearestRecordByTime</a> (double timestamp, double epsilon, <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId={}, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType=<a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2cea0db45d2a4141101bdfe48e3314cfbca3">Record::Type::UNDEFINED</a>) const</td></tr>
<tr class="separator:a1d8cede54de2802bfb082a0b421f616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b16e8bcfce6f5de6178736bb38bb105"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a4b16e8bcfce6f5de6178736bb38bb105">getFileHandler</a> () const</td></tr>
<tr class="separator:a4b16e8bcfce6f5de6178736bb38bb105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a066c279ebbcba58fa7679bde5e983e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a2a066c279ebbcba58fa7679bde5e983e">getUniqueStreamId</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *record) const</td></tr>
<tr class="separator:a2a066c279ebbcba58fa7679bde5e983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51de0d0a256e7d0f168db65a4768d8b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#ab51de0d0a256e7d0f168db65a4768d8b">getTotalSourceSize</a> () const</td></tr>
<tr class="separator:ab51de0d0a256e7d0f168db65a4768d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b08bc8b4239105b209d7b6afce85a63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a4b08bc8b4239105b209d7b6afce85a63">readFirstConfigurationRecord</a> (<a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> uniqueStreamId, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer=nullptr)</td></tr>
<tr class="separator:a4b08bc8b4239105b209d7b6afce85a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53c4c6b3b7972f2a81a2413910c9e10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#ad53c4c6b3b7972f2a81a2413910c9e10">readFirstConfigurationRecords</a> (<a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer=nullptr)</td></tr>
<tr class="separator:ad53c4c6b3b7972f2a81a2413910c9e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41bc5bb7b66a8789c3ec43c695fe166"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#ae41bc5bb7b66a8789c3ec43c695fe166">readFirstConfigurationRecordsForType</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer=nullptr)</td></tr>
<tr class="separator:ae41bc5bb7b66a8789c3ec43c695fe166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173ae403ddf10e480f2ec02464aca0ab"><td class="memItemLeft" align="right" valign="top"><a id="a173ae403ddf10e480f2ec02464aca0ab"></a>
const std::vector&lt; unique_ptr&lt; <a class="el" href="classvrs_1_1_record_file_reader.html">RecordFileReader</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a173ae403ddf10e480f2ec02464aca0ab">getReaders</a> () const</td></tr>
<tr class="memdesc:a173ae403ddf10e480f2ec02464aca0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> objects used to read all the streams. <br /></td></tr>
<tr class="separator:a173ae403ddf10e480f2ec02464aca0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aef6ee0a0207b4d827f1a1da04b1e402f"><td class="memItemLeft" align="right" valign="top">static const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#aef6ee0a0207b4d827f1a1da04b1e402f">kRelatedFileTags</a> []</td></tr>
<tr class="separator:aef6ee0a0207b4d827f1a1da04b1e402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Facilitates reading multiple VRS files simultaneously. Records are sorted by timestamps across all the files, therefore it is essential that *** all the files must have their timestamps in the same time domain. *** Operates in a manner similar to <code><a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a></code>, but with multiple files. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a95c324393b94d95ab8558c25d4c6a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c324393b94d95ab8558c25d4c6a999">&#9670;&nbsp;</a></span>UniqueStreamId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">vrs::MultiRecordFileReader::UniqueStreamId</a> =  <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External facing <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> which handles collisions between <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> across multiple files (RecordFileReaders). Since this is just an alias, it doesn't prevent misuse of using <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> in places where UniqueStreamId is expected. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a80d0e7da59d14619bf2d47f4e9e257f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d0e7da59d14619bf2d47f4e9e257f3">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the underlying files, if any are open. </p><dl class="section return"><dt>Returns</dt><dd>0 on success or if no file was open. Some file system error code upon encountering an error while closing any of the underlying files. </dd></dl>

</div>
</div>
<a id="adca088a2b7060e463b7cbd4b06309efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca088a2b7060e463b7cbd4b06309efc">&#9670;&nbsp;</a></span>getCachingStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a> vrs::MultiRecordFileReader::getCachingStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Caching strategy for all the underlying file handlers. The same strategy is supposed to be used by all file handlers. </p>

</div>
</div>
<a id="ac9ea57d1e6dfb6d34d2396841da63886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ea57d1e6dfb6d34d2396841da63886">&#9670;&nbsp;</a></span>getFileChunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; string, int64_t &gt; &gt; vrs::MultiRecordFileReader::getFileChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a list of the constituent paths + sizes (in bytes) across all files. When no file is open, an empty vector is returned. When a single file is open, the underlying chunks with their sizes are returned. When multiple files are open, file paths and their sizes are returned. </p><dl class="section return"><dt>Returns</dt><dd>A vector of pairs path-file size in bytes. </dd></dl>

</div>
</div>
<a id="a4b16e8bcfce6f5de6178736bb38bb105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b16e8bcfce6f5de6178736bb38bb105">&#9670;&nbsp;</a></span>getFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt; vrs::MultiRecordFileReader::getFileHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a clone of the current file handler, for use elsewhere. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the current file handler. nullptr may be returned if no underlying files are open yet. </dd></dl>

</div>
</div>
<a id="a712d988af2c649c510e9323891a94223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712d988af2c649c510e9323891a94223">&#9670;&nbsp;</a></span>getFirstRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getFirstRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the record with smallest timestamp across all streams and files, of a specified record type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordType</td><td>Type of record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first record of the specified type, or null if no records of the specified type exist. </dd></dl>

</div>
</div>
<a id="afebcf4930b83715be9c1a69bb11bcc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebcf4930b83715be9c1a69bb11bcc39">&#9670;&nbsp;</a></span>getFlavor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vrs::MultiRecordFileReader::getFlavor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Streams using &lt;&lt; <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> Class &gt;&gt; ids require a &lt;&lt; flavor &gt;&gt;, which must be provided when the stream was created. Use this API to get the recordable flavor provided, if any, when the stream was created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flavor for the corresponding RecordableTypeId, or an empty string, if no flavor was provided when the stream was created. </dd></dl>

</div>
</div>
<a id="a7add7a79d8f60690ebc4574de8700d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7add7a79d8f60690ebc4574de8700d21">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp; vrs::MultiRecordFileReader::getIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a record index limited to a specific stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the file, with all the records corresponding to the selected stream. </dd></dl>

</div>
</div>
<a id="aebe784110e9ced6fdc5f2ab8c86f53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe784110e9ced6fdc5f2ab8c86f53e8">&#9670;&nbsp;</a></span>getLastRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getLastRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the record with largest timestamp across all streams and files, of a specified record type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordType</td><td>Type of record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the last record of the specified type, or null if no records of the specified type exist. </dd></dl>

</div>
</div>
<a id="a71f312cf34eea66355931e1865fc7157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f312cf34eea66355931e1865fc7157">&#9670;&nbsp;</a></span>getLastRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getLastRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the last record for a specific stream and specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of the records to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr if the streamId or no record of the type was found. </dd></dl>

</div>
</div>
<a id="a1d8cede54de2802bfb082a0b421f616b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8cede54de2802bfb082a0b421f616b">&#9670;&nbsp;</a></span>getNearestRecordByTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getNearestRecordByTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em> = <code><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2cea0db45d2a4141101bdfe48e3314cfbca3">Record::Type::UNDEFINED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the nearest record of a specific stream within the range of (timestamp - epsilon) - (timestamp + epsilon). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
    <tr><td class="paramname">epsilon</td><td>the threshold we search for the index. </td></tr>
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the stream to consider. Leave undefined to search all streams </td></tr>
    <tr><td class="paramname">recordType</td><td>record type to find, or <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2cea0db45d2a4141101bdfe48e3314cfbca3" title="don&#39;t use.">Record::Type::UNDEFINED</a> for any record type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="a64f158709855c1aaf0bc58e6db53221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f158709855c1aaf0bc58e6db53221f">&#9670;&nbsp;</a></span>getOriginalRecordableTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; vrs::MultiRecordFileReader::getOriginalRecordableTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>RecordableTypeId text descriptions may change over time, so at the time of recording, we capture the text name, so that we can see what it was when the file was recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original text description for the corresponding RecordableTypeId. </dd></dl>

</div>
</div>
<a id="aa051712405a9bbc475dda3e5fd01a1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa051712405a9bbc475dda3e5fd01a1c2">&#9670;&nbsp;</a></span>getRecord() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getRecord </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>globalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the record corresponding to the given index position in the global index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalIndex</td><td>Position in the global index to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Corresponding record if present or nullptr if the given index is invalid. </dd></dl>

</div>
</div>
<a id="aa152d4585a0e961077ca230a7c2fc3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa152d4585a0e961077ca230a7c2fc3a0">&#9670;&nbsp;</a></span>getRecord() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a specific record for a specific stream and type, by index number. nullptr is returned if no record is found for that index number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of the records to consider. </td></tr>
    <tr><td class="paramname">indexNumber</td><td>Index of the record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr if the streamId or the indexNumber wasn't found for that specific type. </dd></dl>

</div>
</div>
<a id="a72f70cf40de6f5c1120c84c709fde6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f70cf40de6f5c1120c84c709fde6bc">&#9670;&nbsp;</a></span>getRecord() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a specific record for a specific stream, regardless of type, by index number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
    <tr><td class="paramname">indexNumber</td><td>Index position (for streamId - not global index) of the record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr if the streamId, or a record with the indexNumber wasn't found. </dd></dl>

</div>
</div>
<a id="a15e52455f81858bd3f09655112ad513c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e52455f81858bd3f09655112ad513c">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="a5cd496fba11f07e4919cf48a704d3097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd496fba11f07e4919cf48a704d3097">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record of a specific stream of a specific type at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>record type to find. </td></tr>
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="a0a4ce7e2786f5fe7d98dd9ef0fccb19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4ce7e2786f5fe7d98dd9ef0fccb19b">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::MultiRecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record of a specific stream at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the stream to consider. </td></tr>
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="afb934e64faefb7453ba01746b6285ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb934e64faefb7453ba01746b6285ea8">&#9670;&nbsp;</a></span>getRecordCount() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::MultiRecordFileReader::getRecordCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of records across all open files. </p><dl class="section return"><dt>Returns</dt><dd>The number of records across all open files, or 0, if no file is opened. </dd></dl>

</div>
</div>
<a id="a191a68096fe97cbbbac17555c247876c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191a68096fe97cbbbac17555c247876c">&#9670;&nbsp;</a></span>getRecordCount() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::MultiRecordFileReader::getRecordCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of records of a specific stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of records of the specified stream. </dd></dl>

</div>
</div>
<a id="ab12b3915b19dab1bbff12a050f447322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12b3915b19dab1bbff12a050f447322">&#9670;&nbsp;</a></span>getRecordCount() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::MultiRecordFileReader::getRecordCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of records for a specific stream and specific record type. Attention: this computation has a linear complexity, so cache the result! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of records to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of records for the specified stream id &amp; record type. </dd></dl>

</div>
</div>
<a id="a554b6e66413becf3f052ca074440e329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554b6e66413becf3f052ca074440e329">&#9670;&nbsp;</a></span>getRecordFormats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::MultiRecordFileReader::getRecordFormats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#a04d155e698e82b4cd67ec9312fadefb0">RecordFormatMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outFormats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> description used in this VRS file. Mostly useful for tools like VRStool &amp; VRSplayer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
    <tr><td class="paramname">outFormats</td><td>Reference to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of formats found. </dd></dl>

</div>
</div>
<a id="aaf6dbf733277c8645819646a1585f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6dbf733277c8645819646a1585f6e6">&#9670;&nbsp;</a></span>getRecordIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::MultiRecordFileReader::getRecordIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a record's index in the global index, which is ordered by timestamp across all open files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>Pointer of the record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in the global index, or <a class="el" href="classvrs_1_1_multi_record_file_reader.html#afb934e64faefb7453ba01746b6285ea8">getRecordCount()</a> is record is nullptr or an invalid pointer. </dd></dl>

</div>
</div>
<a id="aaaaaa87418f9c7a57b4b8ce4e461604e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaaa87418f9c7a57b4b8ce4e461604e">&#9670;&nbsp;</a></span>getSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vrs::MultiRecordFileReader::getSerialNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a stream's serial number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serial number, or an empty string if the stream wasn't found. </dd></dl>

</div>
</div>
<a id="adad584f3509b2ba0bfa77c6d3f4f1e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad584f3509b2ba0bfa77c6d3f4f1e71">&#9670;&nbsp;</a></span>getStreamForName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">MultiRecordFileReader::UniqueStreamId</a> vrs::MultiRecordFileReader::getStreamForName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a stream from an absolute or relative numeric name. Absolute numeric names are in the form &lt;numeric_recordable_type_id&gt;-&lt;instance_id&gt;, eg 1201-1 Relative numeric names are in the form &lt;numeric_recordable_type_id&gt;+&lt;instance_id&gt;, eg 1201+1 Relative numeric names have instance ids interpreted as the nth stream of that type, eg 1201+3 is the 3rd stream with the recordable type id 1201 (if there is such a stream). In all cases, use isValid() to verify that the stream was found in the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>an absolute or relative numeric name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>, valid only if the numeric name exists in the file. </dd></dl>

</div>
</div>
<a id="aa17a884be55f4fe7b1469515833fc312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a884be55f4fe7b1469515833fc312">&#9670;&nbsp;</a></span>getStreamForSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> vrs::MultiRecordFileReader::getStreamForSerialNumber </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>serialNumber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the stream with the given serial number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialNumber</td><td>the serial number to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UniqueStreamId. Call isValid() to know if a matching stream was actually found. </dd></dl>

</div>
</div>
<a id="a48f07e2b49133a6c9514767bb3694839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f07e2b49133a6c9514767bb3694839">&#9670;&nbsp;</a></span>getStreamForTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> vrs::MultiRecordFileReader::getStreamForTag </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em> = <code><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360">RecordableTypeId::Undefined</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first stream with given tag name + value pair and RecordableTypeId </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>The name of the tag to look for. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag value to look for. </td></tr>
    <tr><td class="paramname">typeId</td><td>The RecordableTypeId to limit the search to, or <a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360" title="Value used for default initializations and marking undefined situations.">RecordableTypeId::Undefined</a> to look for any device type. Note: if more than one streams match the criteria, the "first" one is returned, which means the one with the lowest RecordableTypeId enum value, or if equal, the one with the lowest UniqueStreamId instanceId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UniqueStreamId. Call isValid() to know if a matching stream was actually found. </dd></dl>

</div>
</div>
<a id="aea6d2e06fac1b08114256872edfc7aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6d2e06fac1b08114256872edfc7aae">&#9670;&nbsp;</a></span>getStreams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const set&lt; <a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> &gt; &amp; vrs::MultiRecordFileReader::getStreams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the set of <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> for all the streams across all the open files. In case the the same <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> is used in multiple files, this method generates UniqueStreamIds for disambiguation and uses those instead. </p><dl class="section return"><dt>Returns</dt><dd>The set of stream IDs for which there are records. </dd></dl>

</div>
</div>
<a id="a4b0bbafddb032b92df48f8862ce12f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0bbafddb032b92df48f8862ce12f13">&#9670;&nbsp;</a></span>getStreams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> &gt; vrs::MultiRecordFileReader::getStreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>flavor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a set of <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> for a specific type, and an optional flavor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>a recordable type id, maybe a <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> Class. Use <a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360" title="Value used for default initializations and marking undefined situations.">RecordableTypeId::Undefined</a> to match any recordable type. </td></tr>
    <tr><td class="paramname">flavor</td><td>an option flavor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of stream ids of the given type, and of the provided flavor (if any). </dd></dl>

</div>
</div>
<a id="ada0308f47472fc886156a613a738293c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0308f47472fc886156a613a738293c">&#9670;&nbsp;</a></span>getTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; vrs::MultiRecordFileReader::getTag </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a specific file tag by name. (Not to be confused with stream tags) If multiple files are opened and they have multiple values for the same tag name, one of the values is returned arbitrarily. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the tag to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag value, or the empty string if the tag wasn't found. </dd></dl>

</div>
</div>
<a id="a13794f5958db361c8522cca25e3432cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13794f5958db361c8522cca25e3432cc">&#9670;&nbsp;</a></span>getTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; vrs::MultiRecordFileReader::getTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a specific tag for a specific record stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the tag to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag value, or the empty string if the tag wasn't found. </dd></dl>

</div>
</div>
<a id="a6722cc31e14463ee340c6fcb783358f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6722cc31e14463ee340c6fcb783358f7">&#9670;&nbsp;</a></span>getTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt;string, string&gt;&amp; vrs::MultiRecordFileReader::getTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the tags map for all the underlying files. Does not include any stream tags. </p><dl class="section return"><dt>Returns</dt><dd>The tags map for all underlying files. </dd></dl>

</div>
</div>
<a id="a30899bd56053e192b6406bf6b88e32b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30899bd56053e192b6406bf6b88e32b0">&#9670;&nbsp;</a></span>getTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp; vrs::MultiRecordFileReader::getTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tags for a specific record stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tags for the stream. If the streamId doesn't exist in the file, the map returned will be an empty map. </dd></dl>

</div>
</div>
<a id="ab51de0d0a256e7d0f168db65a4768d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51de0d0a256e7d0f168db65a4768d8b">&#9670;&nbsp;</a></span>getTotalSourceSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrs::MultiRecordFileReader::getTotalSourceSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total size of all underlying files. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes of all the files combined. </dd></dl>

</div>
</div>
<a id="a2a066c279ebbcba58fa7679bde5e983e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a066c279ebbcba58fa7679bde5e983e">&#9670;&nbsp;</a></span>getUniqueStreamId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a> vrs::MultiRecordFileReader::getUniqueStreamId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get UniqueStreamId corresponding to the given record. This must be used as opposed to reading the <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> from RecordInfo directly since it handles <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> collisions between streams from multiple files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td><a class="el" href="classvrs_1_1_record.html" title="Essential VRS class holding a record&#39;s details and payload in memory during creation.">Record</a> whose UniqueStreamId is supposed to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UniqueStreamId corresponding to the given record. An invalid UniqueStreamId is returned for an illegal record. </dd></dl>

</div>
</div>
<a id="a6a8895c7cf63d0b186d016ed64af130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8895c7cf63d0b186d016ed64af130b">&#9670;&nbsp;</a></span>isOpened()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::isOpened </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if files are being read. Must be true for most operations. </p><dl class="section return"><dt>Returns</dt><dd>True if the file is opened. </dd></dl>

</div>
</div>
<a id="a335628545d95143a04d74f3fb6cd87ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335628545d95143a04d74f3fb6cd87ca">&#9670;&nbsp;</a></span>isRecordAvailableOrPrefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::isRecordAvailableOrPrefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a file record is available for immediate loading (e.g. on disk or in-cache). If not, begin background prefetching at the requested frame (but do not wait for results). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordInfo</td><td>RecordInfo reference of the record to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if available, false if unavailable (e.g. would require a network fetch). </dd></dl>

</div>
</div>
<a id="aa4edd3bbfb351c3aedd554feae96e77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4edd3bbfb351c3aedd554feae96e77e">&#9670;&nbsp;</a></span>open() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSpec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a single VRS file. This method is expected to be invoked only once per instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSpec</td><td>VRS fileSpec to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and you can read the file, or some non-zero error code, in which case, further read calls will fail. </dd></dl>

</div>
</div>
<a id="a37b8e10c675577a8a7d907fa4813af73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b8e10c675577a8a7d907fa4813af73">&#9670;&nbsp;</a></span>open() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a single VRS file. This method is expected to be invoked only once per instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>VRS file path to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and you can read the file, or some non-zero error code, in which case, further read calls will fail. </dd></dl>

</div>
</div>
<a id="a11143a227cc23206fa7fbdc84f3c76cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11143a227cc23206fa7fbdc84f3c76cb">&#9670;&nbsp;</a></span>open() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::open </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileSpecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the given VRS files. Only related files are allowed to be opened together. i.e. the files which have the same values for tags defined in <code>kRelatedFileTags</code>. If these tags are present, then the values must match. All the files must have their timestamps in the same time domain. This method is expected to be invoked only once per instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSpecs</td><td>VRS file specs to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and you can read all the files, or some non-zero error code, in which case, further read calls will fail. </dd></dl>

</div>
</div>
<a id="aa871dab921f89d50038bd3bdaf355ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa871dab921f89d50038bd3bdaf355ba3">&#9670;&nbsp;</a></span>open() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::open </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the given VRS files. Only related files are allowed to be opened together. i.e. the files which have the same values for tags defined in <code>kRelatedFileTags</code>. If these tags are present, then the values must match. All the files must have their timestamps in the same time domain. This method is expected to be invoked only once per instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>VRS file paths to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and you can read all the files, or some non-zero error code, in which case, further read calls will fail. </dd></dl>

</div>
</div>
<a id="a64a7f1918e2a599e9b2cdc3d4349451c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a7f1918e2a599e9b2cdc3d4349451c">&#9670;&nbsp;</a></span>prefetchRecordSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::prefetchRecordSequence </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearSequence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When streaming VRS files from the cloud, it may be very beneficial to tell before hand which records will be read, in order, so that the data can be prefetched optimally. Note the only some FileHandlers implement this, others will just ignore the request, which is always safe to make. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">records</td><td>a sequence of records in the exact order they will be read. It's ok to skip one or more records, but:<ul>
<li>don't try to read "past" records, or you'll confuse the caching strategy, possibly leading to much worse performance.</li>
<li>if you read a single record out of the sequence, the prefetch list will be cleared. You may call this method as often as you like, and any previous read sequence will be cleared, but whatever is already in the cache will remain. </li>
</ul>
</td></tr>
    <tr><td class="paramname">clearSequence</td><td>Flag on whether to cancel any pre-existing custom read sequence upon caching starts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file handler backend supports this request, false if it was ignored. </dd></dl>

</div>
</div>
<a id="a36c8eec112569f67ebb9a213f61178d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c8eec112569f67ebb9a213f61178d9">&#9670;&nbsp;</a></span>purgeFileCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::purgeFileCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the underlying file handler caches data on reads, purge its caches to free memory. Sets the caching strategy to Passive, and clears any pending read sequence. </p><dl class="section return"><dt>Returns</dt><dd>True if all the underlying caches were purged, false if they weren't for some reason. Note: this is a best effort. If transactions are pending, their cache blocks won't be cleared. </dd></dl>

</div>
</div>
<a id="a4b08bc8b4239105b209d7b6afce85a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b08bc8b4239105b209d7b6afce85a63">&#9670;&nbsp;</a></span>readFirstConfigurationRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::readFirstConfigurationRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>uniqueStreamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function: Read the first configuration record of a particular stream. This might be necessary to properly read records containing image or audio blocks, if their configuration is contained in the configuration record using datalayout conventions. Notes:</p><ul>
<li>a <a class="el" href="classvrs_1_1_record_format_stream_player.html" title="Specialized StreamPlayer designed to handle records which format is managed by RecordFormat,...">RecordFormatStreamPlayer</a> must be attached to the stream prior to making this call, because that's where the configuration data is being cached.</li>
<li>that this API reads the first configuration record of the stream, and if the stream contains more than one configuration record, that record may not be the right one for all your data records.</li>
<li>if you provide a stream player, the caching happens in that stream player, which won't solve the use case described above. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueStreamId</td><td>UniqueStreamId of the record stream to consider. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td>(optional): provide a streamPlayer that will receive the records. If provided, and a stream player is already registered to receive records for that stream, the provided stream player will get the data, and the registered stream player will not get anything. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a config record was read for the given stream. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ad53c4c6b3b7972f2a81a2413910c9e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53c4c6b3b7972f2a81a2413910c9e10">&#9670;&nbsp;</a></span>readFirstConfigurationRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::readFirstConfigurationRecords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function: Read the first configuration record of all the streams. This might be necessary to properly read records containing image or audio blocks, if their configuration is contained in the configuration record using datalayout conventions. Notes:</p><ul>
<li>a <a class="el" href="classvrs_1_1_record_format_stream_player.html" title="Specialized StreamPlayer designed to handle records which format is managed by RecordFormat,...">RecordFormatStreamPlayer</a> must be attached to the stream prior to making this call, because that's where the configuration data is being cached.</li>
<li>that this API reads the first configuration record of the stream, and if the stream contains more than one configuration record, that record may not be the right one for all your data records.</li>
<li>if you provide a stream player, the caching happens in that stream player, which won't solve the use case described above. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamPlayer</td><td>(optional): provide a stream player that will receive the records. If provided, and a stream player is already registered to receive records for that stream, the provided stream player will get the data, and the registered stream player will not get anything. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a config record was read for the given stream. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae41bc5bb7b66a8789c3ec43c695fe166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41bc5bb7b66a8789c3ec43c695fe166">&#9670;&nbsp;</a></span>readFirstConfigurationRecordsForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::readFirstConfigurationRecordsForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function: Read the first configuration record for all the streams of a particular recordable type. See <a class="el" href="classvrs_1_1_multi_record_file_reader.html#a4b08bc8b4239105b209d7b6afce85a63">readFirstConfigurationRecord()</a> for limitations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>The RecordableTypeId of the type of device to look for. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td>(optional): provide a stream player that will receive the records. If provided, and a stream player is already registered to receive records for that stream, the provided stream player will get the data, and the registered stream player will not get anything. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a configuration record was properly read for each matching stream. </dd></dl>

</div>
</div>
<a id="aacca4fb96e7495cbe98fede2f301eb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacca4fb96e7495cbe98fede2f301eb16">&#9670;&nbsp;</a></span>readRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::readRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>recordInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preferred way to read records. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordInfo</td><td>RecordInfo reference of the record to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a non-zero error code. If there is no <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> hooked up for the stream, no read operation is done and 0 is returned. </dd></dl>

</div>
</div>
<a id="a437f20bf1635f99f7128dc7142b41282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437f20bf1635f99f7128dc7142b41282">&#9670;&nbsp;</a></span>readRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::MultiRecordFileReader::readRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>recordInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setupPlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a record with a specific stream player. Attention! Unlike the <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> version of this API, do not read different streams with the same stream player, or you might get unexpected results. Stream players should not be used with different <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> objects, which this class might do. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordInfo</td><td>RecordInfo reference of the record to read. </td></tr>
    <tr><td class="paramname">setupPlayer</td><td>tell if the player should be initialized through its onAttachedToFileReader callback. This must happen at least once per player, the first time around. This operation can be expensive, so this should be done only once. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a non-zero error code. </dd></dl>

</div>
</div>
<a id="a3b59a8b0be71cf99c84c806ab998c822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b59a8b0be71cf99c84c806ab998c822">&#9670;&nbsp;</a></span>setCachingStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::MultiRecordFileReader::setCachingStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>&#160;</td>
          <td class="paramname"><em>cachingStrategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Caching strategy for all the underlying file handlers. This should be called <em>after</em> opening the files, as open might replace the file handler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachingStrategy</td><td>Caching strategy desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the caching strategy was set. False if any of the underlying file handlers doesn't support the requested strategy, or any particular strategy. </dd></dl>

</div>
</div>
<a id="a86c388c49581ee495666167e68c2b13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c388c49581ee495666167e68c2b13c">&#9670;&nbsp;</a></span>setStreamPlayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::MultiRecordFileReader::setStreamPlayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_multi_record_file_reader.html#a95c324393b94d95ab8558c25d4c6a999">UniqueStreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hook a stream player to a specific stream after opening a file and before reading records. The file player does <em>not</em> take ownership of the <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a>. Using the same <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> instance for multiple streams is supported. So the caller is responsible for deleting the <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> objects after the file is read. Disconnect the <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> by passing a nullptr for the stream id. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>UniqueStreamId to hook the stream player to. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td><a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> to attach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aef6ee0a0207b4d827f1a1da04b1e402f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6ee0a0207b4d827f1a1da04b1e402f">&#9670;&nbsp;</a></span>kRelatedFileTags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string vrs::MultiRecordFileReader::kRelatedFileTags[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">      tag_conventions::kCaptureTimeEpoch,</div>
<div class="line">      tag_conventions::kSessionId}</div>
</div><!-- fragment --><p>Tags which determine whether VRS files are related to each other. Related files are expected to have the same value for these tags. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_multi_record_file_reader_8h_source.html">MultiRecordFileReader.h</a></li>
<li>vrs/MultiRecordFileReader.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

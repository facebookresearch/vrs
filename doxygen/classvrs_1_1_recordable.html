<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::Recordable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_recordable.html">Recordable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classvrs_1_1_recordable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vrs::Recordable Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Class to override to implement a record producing device, or virtual device.  
 <a href="classvrs_1_1_recordable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_recordable_8h_source.html">Recordable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vrs::Recordable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvrs_1_1_recordable.png" usemap="#vrs::Recordable_map" alt=""/>
  <map id="vrs::Recordable_map" name="vrs::Recordable_map">
<area href="classvrs__sample__apps_1_1_audio_stream.html" title="Sample fake device showing how to produce records containing audio data (no metadata)." alt="vrs_sample_apps::AudioStream" shape="rect" coords="0,56,244,80"/>
<area href="classvrs__sample__apps_1_1_image_stream.html" title="Sample fake device showing how to produce records containing metadata and images." alt="vrs_sample_apps::ImageStream" shape="rect" coords="254,56,498,80"/>
<area href="classvrs__sample__apps_1_1_motion_stream.html" title="Sample fake device showing how to produce records containing metadata." alt="vrs_sample_apps::MotionStream" shape="rect" coords="508,56,752,80"/>
<area href="classvrs__sample__code_1_1_my_camera_recordable.html" title="Class to generate a stream of sample records." alt="vrs_sample_code::MyCameraRecordable" shape="rect" coords="762,56,1006,80"/>
<area href="classvrs__sample__code_1_1_recordable_demo.html" title="Sample device recording some trivial metadata." alt="vrs_sample_code::RecordableDemo" shape="rect" coords="1016,56,1260,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6fb72295d3b60cc1ed3e571c158dec2a" id="r_a6fb72295d3b60cc1ed3e571c158dec2a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a6fb72295d3b60cc1ed3e571c158dec2a">CreateRecordDelegate</a> = std::function&lt; const <a class="el" href="classvrs_1_1_record.html">Record</a> *(<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, double timestamp, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t recordFormatVersion, const <a class="el" href="classvrs_1_1_data_source.html">DataSource</a> &amp;data)&gt;</td></tr>
<tr class="separator:a6fb72295d3b60cc1ed3e571c158dec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67a9b03fc55c2cf14643ea06f204f21a" id="r_a67a9b03fc55c2cf14643ea06f204f21a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a67a9b03fc55c2cf14643ea06f204f21a">getRecordableName</a> () const</td></tr>
<tr class="separator:a67a9b03fc55c2cf14643ea06f204f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26e428b6a13f5a7dc37b63da0d21163" id="r_af26e428b6a13f5a7dc37b63da0d21163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#af26e428b6a13f5a7dc37b63da0d21163">getRecordableTypeId</a> () const</td></tr>
<tr class="separator:af26e428b6a13f5a7dc37b63da0d21163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8a44e8422a7369feb2567b434c5f8e" id="r_a4a8a44e8422a7369feb2567b434c5f8e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a4a8a44e8422a7369feb2567b434c5f8e">getRecordableInstanceId</a> () const</td></tr>
<tr class="separator:a4a8a44e8422a7369feb2567b434c5f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0974187373d6ec5d9054457de97303" id="r_a2e0974187373d6ec5d9054457de97303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a2e0974187373d6ec5d9054457de97303">getStreamId</a> () const</td></tr>
<tr class="separator:a2e0974187373d6ec5d9054457de97303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a297d0f8952d09aa7bb04fb4766fef5" id="r_a9a297d0f8952d09aa7bb04fb4766fef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a9a297d0f8952d09aa7bb04fb4766fef5">setRecordableIsActive</a> (bool isActive)</td></tr>
<tr class="separator:a9a297d0f8952d09aa7bb04fb4766fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac937546f2c6f8c2841c927362ac7bbe5" id="r_ac937546f2c6f8c2841c927362ac7bbe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#ac937546f2c6f8c2841c927362ac7bbe5">isRecordableActive</a> () const</td></tr>
<tr class="separator:ac937546f2c6f8c2841c927362ac7bbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797755d90703adc2e866df76c58fcce2" id="r_a797755d90703adc2e866df76c58fcce2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a797755d90703adc2e866df76c58fcce2">setCompression</a> (<a class="el" href="namespacevrs.html#a37a35edf18e8bb343398cb938d3e2b7b">CompressionPreset</a> preset)</td></tr>
<tr class="separator:a797755d90703adc2e866df76c58fcce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa801d89039dc4435461210f53e5c5c89" id="r_aa801d89039dc4435461210f53e5c5c89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#aa801d89039dc4435461210f53e5c5c89">addRecordFormat</a> (<a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t formatVersion, const <a class="el" href="classvrs_1_1_record_format.html">RecordFormat</a> &amp;format, const vector&lt; const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> * &gt; &amp;layouts={})</td></tr>
<tr class="separator:aa801d89039dc4435461210f53e5c5c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac819494065cc24d75c1d5de60766fece" id="r_ac819494065cc24d75c1d5de60766fece"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classvrs_1_1_record.html">Record</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#ac819494065cc24d75c1d5de60766fece">createConfigurationRecord</a> ()=0</td></tr>
<tr class="separator:ac819494065cc24d75c1d5de60766fece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac559c619aa7e41b9f08e235c83a7eee7" id="r_ac559c619aa7e41b9f08e235c83a7eee7"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classvrs_1_1_record.html">Record</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#ac559c619aa7e41b9f08e235c83a7eee7">createStateRecord</a> ()=0</td></tr>
<tr class="separator:ac559c619aa7e41b9f08e235c83a7eee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba87b5b80ab4a4536e0d80ebf7157c38" id="r_aba87b5b80ab4a4536e0d80ebf7157c38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#aba87b5b80ab4a4536e0d80ebf7157c38">setCreateRecordDelegate</a> (<a class="el" href="classvrs_1_1_recordable.html#a6fb72295d3b60cc1ed3e571c158dec2a">CreateRecordDelegate</a> delegate)</td></tr>
<tr class="separator:aba87b5b80ab4a4536e0d80ebf7157c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5dbb294126e32a8f63a7d7c9ce652" id="r_a56b5dbb294126e32a8f63a7d7c9ce652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a56b5dbb294126e32a8f63a7d7c9ce652">setTag</a> (const string &amp;tagName, const string &amp;tagValue)</td></tr>
<tr class="separator:a56b5dbb294126e32a8f63a7d7c9ce652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97c9ca729acf1dfe2673c114401c834" id="r_ac97c9ca729acf1dfe2673c114401c834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#ac97c9ca729acf1dfe2673c114401c834">addTags</a> (const map&lt; string, string &gt; &amp;newTags)</td></tr>
<tr class="separator:ac97c9ca729acf1dfe2673c114401c834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b438be2513c28ad26dcd70f0fa193" id="r_ae61b438be2513c28ad26dcd70f0fa193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#ae61b438be2513c28ad26dcd70f0fa193">addTags</a> (const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp;tags)</td></tr>
<tr class="separator:ae61b438be2513c28ad26dcd70f0fa193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af776759e061ce2a2d07d7e54ade40940" id="r_af776759e061ce2a2d07d7e54ade40940"><td class="memItemLeft" align="right" valign="top">const map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#af776759e061ce2a2d07d7e54ade40940">getTags</a> () const</td></tr>
<tr class="separator:af776759e061ce2a2d07d7e54ade40940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6809bc24ba26b3ad2b3db0c76dda3437" id="r_a6809bc24ba26b3ad2b3db0c76dda3437"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a6809bc24ba26b3ad2b3db0c76dda3437">getStreamTags</a> () const</td></tr>
<tr class="separator:a6809bc24ba26b3ad2b3db0c76dda3437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7819263192c0ed9ed98b753693428560" id="r_a7819263192c0ed9ed98b753693428560"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a7819263192c0ed9ed98b753693428560">getSerialNumber</a> () const</td></tr>
<tr class="separator:a7819263192c0ed9ed98b753693428560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ab82ec0c14c4ffe4cac67d845bb48" id="r_a641ab82ec0c14c4ffe4cac67d845bb48"><td class="memItemLeft" align="right" valign="top"><a id="a641ab82ec0c14c4ffe4cac67d845bb48" name="a641ab82ec0c14c4ffe4cac67d845bb48"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStreamFlavor</b> () const</td></tr>
<tr class="memdesc:a641ab82ec0c14c4ffe4cac67d845bb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream's flavor, if any. <br /></td></tr>
<tr class="separator:a641ab82ec0c14c4ffe4cac67d845bb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9954f74f6c403d6e6fc698658aebed5d" id="r_a9954f74f6c403d6e6fc698658aebed5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_record_manager.html">RecordManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a9954f74f6c403d6e6fc698658aebed5d">getRecordManager</a> ()</td></tr>
<tr class="separator:a9954f74f6c403d6e6fc698658aebed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abfd07eec2c8cbf66dd9ef72b4a8e7c9e" id="r_abfd07eec2c8cbf66dd9ef72b4a8e7c9e"><td class="memItemLeft" align="right" valign="top">static const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#abfd07eec2c8cbf66dd9ef72b4a8e7c9e">getOriginalNameTagName</a> ()</td></tr>
<tr class="separator:abfd07eec2c8cbf66dd9ef72b4a8e7c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adb6ad3449af962e5dd6984ece18291" id="r_a4adb6ad3449af962e5dd6984ece18291"><td class="memItemLeft" align="right" valign="top">static const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a4adb6ad3449af962e5dd6984ece18291">getFlavorTagName</a> ()</td></tr>
<tr class="separator:a4adb6ad3449af962e5dd6984ece18291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b021ba9e142144faab97fada28f140d" id="r_a6b021ba9e142144faab97fada28f140d"><td class="memItemLeft" align="right" valign="top"><a id="a6b021ba9e142144faab97fada28f140d" name="a6b021ba9e142144faab97fada28f140d"></a>
static const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSerialNumberTagName</b> ()</td></tr>
<tr class="memdesc:a6b021ba9e142144faab97fada28f140d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the VRS tag used to store the stream's serial number. <br /></td></tr>
<tr class="separator:a6b021ba9e142144faab97fada28f140d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7c86260e9094619a48601f41faabe2" id="r_a2a7c86260e9094619a48601f41faabe2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a2a7c86260e9094619a48601f41faabe2">resetNewInstanceIds</a> ()</td></tr>
<tr class="separator:a2a7c86260e9094619a48601f41faabe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a822a517531c5c44b21db59cde04eda09" id="r_a822a517531c5c44b21db59cde04eda09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a822a517531c5c44b21db59cde04eda09">Recordable</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, const string &amp;flavor={})</td></tr>
<tr class="separator:a822a517531c5c44b21db59cde04eda09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091810514fe0eef740fdff4f9a82b749" id="r_a091810514fe0eef740fdff4f9a82b749"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_record.html">Record</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a091810514fe0eef740fdff4f9a82b749">createRecord</a> (double timestampSec, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t formatVersion, const <a class="el" href="classvrs_1_1_data_source.html">DataSource</a> &amp;data=<a class="el" href="classvrs_1_1_data_source.html">DataSource</a>())</td></tr>
<tr class="separator:a091810514fe0eef740fdff4f9a82b749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847e02dac6276150b178a0d082b65e0c" id="r_a847e02dac6276150b178a0d082b65e0c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvrs_1_1_record.html">Record</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_recordable.html#a847e02dac6276150b178a0d082b65e0c">createUncompressedRecord</a> (double timestampSec, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t formatVersion, const <a class="el" href="classvrs_1_1_data_source.html">DataSource</a> &amp;data, std::unique_ptr&lt; <a class="el" href="classvrs_1_1_direct_write_record_data.html">DirectWriteRecordData</a> &gt; &amp;&amp;directWriteRecordData)</td></tr>
<tr class="separator:a847e02dac6276150b178a0d082b65e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccc03227f7ea793a1024219330902db" id="r_a7ccc03227f7ea793a1024219330902db"><td class="memItemLeft" align="right" valign="top"><a id="a7ccc03227f7ea793a1024219330902db" name="a7ccc03227f7ea793a1024219330902db"></a>
map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getVRSTags</b> ()</td></tr>
<tr class="memdesc:a7ccc03227f7ea793a1024219330902db"><td class="mdescLeft">&#160;</td><td class="mdescRight">When direct edits of VRS tags is convenient (record filters) <br /></td></tr>
<tr class="separator:a7ccc03227f7ea793a1024219330902db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1d340aa940b696eba6a21d2e4956a2c4" id="r_a1d340aa940b696eba6a21d2e4956a2c4"><td class="memItemLeft" align="right" valign="top"><a id="a1d340aa940b696eba6a21d2e4956a2c4" name="a1d340aa940b696eba6a21d2e4956a2c4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RecordFileWriter</b></td></tr>
<tr class="separator:a1d340aa940b696eba6a21d2e4956a2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to override to implement a record producing device, or virtual device. </p>
<p>Recordables are meant to be attached to a single <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a>, that will write its records. Each instance maps one-to-one with a <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a>'s record stream. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6fb72295d3b60cc1ed3e571c158dec2a" name="a6fb72295d3b60cc1ed3e571c158dec2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb72295d3b60cc1ed3e571c158dec2a">&#9670;&#160;</a></span>CreateRecordDelegate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvrs_1_1_recordable.html#a6fb72295d3b60cc1ed3e571c158dec2a">vrs::Recordable::CreateRecordDelegate</a> =  std::function&lt;const <a class="el" href="classvrs_1_1_record.html">Record</a>*( <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, double timestamp, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t recordFormatVersion, const <a class="el" href="classvrs_1_1_data_source.html">DataSource</a>&amp; data)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvrs_1_1_record.html" title="Essential VRS class holding a record&#39;s details and payload in memory during creation.">Record</a> creation delegate function, to change the record creation behavior without having to override the class. Note that it is valid to deny a record creation request by simply returning a nullptr. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a822a517531c5c44b21db59cde04eda09" name="a822a517531c5c44b21db59cde04eda09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822a517531c5c44b21db59cde04eda09">&#9670;&#160;</a></span>Recordable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vrs::Recordable::Recordable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>flavor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A recordable has a fixed recordable type id, set at construction and immutable. The instance id is generated by VRS and not user controlled. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>an id telling which type of stream this is. </td></tr>
    <tr><td class="paramname">flavor</td><td>a flavor required when using &lt;&lt; recordable class &gt;&gt; type ids. Note: you may always provide a flavor, but you are required to with &lt;&lt; recordable class&gt; ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa801d89039dc4435461210f53e5c5c89" name="aa801d89039dc4435461210f53e5c5c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa801d89039dc4435461210f53e5c5c89">&#9670;&#160;</a></span>addRecordFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::Recordable::addRecordFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>formatVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrs_1_1_record_format.html">RecordFormat</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>layouts</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To manage the records of this recordable with <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a>, define a <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> for each type of record. It is possible for the same recordable to produce multiple type of records of the same type, using a different formatVersion for each. For each, a different <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> must be defined.</p>
<p>Attention! when you provide a <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> for a record type &amp; formatVersion, all of the streams' records of that type &amp; formatVersion must comply with that <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordType</td><td>The <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> to define. </td></tr>
    <tr><td class="paramname">formatVersion</td><td>The format version to define. </td></tr>
    <tr><td class="paramname">format</td><td>The <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> for the records of the type and format version. </td></tr>
    <tr><td class="paramname">layouts</td><td>A vector of pointers to DataLayouts and nullptr. For each <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> content block of the <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a>, a pointer to a <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> must be provided for the matching index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> and the layouts match as expected. Otherwise, false is returned and errors will be logged to help debug the problem. </dd></dl>

</div>
</div>
<a id="ac97c9ca729acf1dfe2673c114401c834" name="ac97c9ca729acf1dfe2673c114401c834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97c9ca729acf1dfe2673c114401c834">&#9670;&#160;</a></span>addTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::addTags </td>
          <td>(</td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>newTags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add file tags in bulk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTags</td><td>A map of string name/value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61b438be2513c28ad26dcd70f0fa193" name="ae61b438be2513c28ad26dcd70f0fa193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61b438be2513c28ad26dcd70f0fa193">&#9670;&#160;</a></span>addTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::addTags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp;&#160;</td>
          <td class="paramname"><em>tags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add many tags at once, both internal &amp; user tags. This method is meant for record stream copy operations, when all the tags of a read record stream need to be copied to a recordable capturing the copy of the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>User and VRS tags to set, probably coming from RecordFileReader::getTag(id). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac819494065cc24d75c1d5de60766fece" name="ac819494065cc24d75c1d5de60766fece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac819494065cc24d75c1d5de60766fece">&#9670;&#160;</a></span>createConfigurationRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classvrs_1_1_record.html">Record</a> * vrs::Recordable::createConfigurationRecord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configuration records describe how the device recorded is configured/setup. The configuration of a recordable is probably not changed by data flowing through. A framerate, a resolution, are probably part of the configuration. An exposure setting as well, unless it is automatically adjusted as data flows through. The <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> will call this method to make sure a configuration record is captured, when a record file is created asynchronously. </p>

<p>Implemented in <a class="el" href="classvrs__sample__apps_1_1_image_stream.html#a692c75d040cccfc7ed70ac1bc51a323c">vrs_sample_apps::ImageStream</a>, <a class="el" href="classvrs__sample__apps_1_1_audio_stream.html#ad4d22c78b1478ec05b1b35c59dc18834">vrs_sample_apps::AudioStream</a>, <a class="el" href="classvrs__sample__apps_1_1_motion_stream.html#a113685418d74d3ce056794b4023b7883">vrs_sample_apps::MotionStream</a>, <a class="el" href="classvrs__sample__code_1_1_recordable_demo.html#a7b1162509b6513632dd15ff215ddcc2e">vrs_sample_code::RecordableDemo</a>, and <a class="el" href="classvrs__sample__code_1_1_my_camera_recordable.html#adc772d673632e2c823cee2754c7a1224">vrs_sample_code::MyCameraRecordable</a>.</p>

</div>
</div>
<a id="a091810514fe0eef740fdff4f9a82b749" name="a091810514fe0eef740fdff4f9a82b749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091810514fe0eef740fdff4f9a82b749">&#9670;&#160;</a></span>createRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrs_1_1_record.html">Record</a> * vrs::Recordable::createRecord </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestampSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>formatVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrs_1_1_data_source.html">DataSource</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="classvrs_1_1_data_source.html">DataSource</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new record for this recordable. That's the preferred API to create records.</p>
<p>When the call returns:</p><ul>
<li>a record has been created and is fully owned and managed by the recordable's <a class="el" href="classvrs_1_1_record_manager.html" title="VRS internal class to manage the records of a specific Recordable after their creation.">RecordManager</a>, despite returning a pointer to it.</li>
<li>the <a class="el" href="classvrs_1_1_data_source.html" title="A class referencing data to be captured in a record at creation.">DataSource</a> referenced by data has fully been copied in the record, so that the caller is immediately entirely free to reuse or delete the source data as desired.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestampSec</td><td>Timestamp of the record. <em>All the records of all the recordables</em> attached to the same <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> must have timestamps in <em>the same time domain</em>, or they won't be managed &amp; sorted in a sensible way. Respecting this requirement is essential, as records will be ordered on disk and played back sorted by their timestamp. Timestamps are a count of seconds since some arbitrary point in time, EPOCH or not (usually). </td></tr>
    <tr><td class="paramname">recordType</td><td>The type of the record. </td></tr>
    <tr><td class="paramname">formatVersion</td><td>Each record specifies how it encodes its data using a formatVersion. This format version may reference a <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> definition that has been provided using <a class="el" href="classvrs_1_1_record_format.html#a4bb88867e1f983ab46cf8cff83b4e69f">RecordFormat::addRecordFormat()</a> (new/better API), or reference a data format managed manually by the user of the API (early API, before <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> &amp; <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>). The version number only need to be unique for this device and record type, but needs to be carefully managed over time, or you won't be able to interpret files created in the past. </td></tr>
    <tr><td class="paramname">data</td><td>A <a class="el" href="classvrs_1_1_data_source.html" title="A class referencing data to be captured in a record at creation.">DataSource</a> that points to the record's actual data payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>record: A pointer to the created record, that's owned &amp; managed by the recordable's <a class="el" href="classvrs_1_1_record_manager.html" title="VRS internal class to manage the records of a specific Recordable after their creation.">RecordManager</a>. Client code probably shouldn't do much with that pointer. Attention! This pointer may be null, in particular when a delegate intercepts the request! </dd></dl>

</div>
</div>
<a id="ac559c619aa7e41b9f08e235c83a7eee7" name="ac559c619aa7e41b9f08e235c83a7eee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac559c619aa7e41b9f08e235c83a7eee7">&#9670;&#160;</a></span>createStateRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classvrs_1_1_record.html">Record</a> * vrs::Recordable::createStateRecord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State records describe the internal state of the device, if it's stateful. It is probably the result of previous calculation/processing of data.</p>
<p>State records should not to be confused with the configuration of the device. A position tracking algorithm probably has a state: the last position it determined, which will be used to calculate the next state when the next data come in. State data typically changes as data flows, according to that data. A camera probably has no state, but probably has a configuration. The <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> will call this method to make sure a configuration record is captured, when a record file is created asynchronously. </p>

<p>Implemented in <a class="el" href="classvrs__sample__apps_1_1_image_stream.html#a6a8acfc84db68126143b3424f575ed96">vrs_sample_apps::ImageStream</a>, <a class="el" href="classvrs__sample__apps_1_1_audio_stream.html#a644191e1701b9598d9c2e80ddd316963">vrs_sample_apps::AudioStream</a>, <a class="el" href="classvrs__sample__apps_1_1_motion_stream.html#ad9d08781f4b714d00b084dfa920f425c">vrs_sample_apps::MotionStream</a>, <a class="el" href="classvrs__sample__code_1_1_recordable_demo.html#a2ca2bdc54e43511435c63ee5efd44b70">vrs_sample_code::RecordableDemo</a>, and <a class="el" href="classvrs__sample__code_1_1_my_camera_recordable.html#a302ccaab585ecb270f830de8372dfc86">vrs_sample_code::MyCameraRecordable</a>.</p>

</div>
</div>
<a id="a847e02dac6276150b178a0d082b65e0c" name="a847e02dac6276150b178a0d082b65e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847e02dac6276150b178a0d082b65e0c">&#9670;&#160;</a></span>createUncompressedRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvrs_1_1_record.html">Record</a> * vrs::Recordable::createUncompressedRecord </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestampSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>formatVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvrs_1_1_data_source.html">DataSource</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classvrs_1_1_direct_write_record_data.html">DirectWriteRecordData</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>directWriteRecordData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a record which last part will be written directly to the file when the record is written to disk, therefore bypassing the record creation memory copy for that part. This API is designed for high bandwidth live recording situations, when we must avoid the record creation's memory copy to achieve the required performance.</p>
<p>Note: using a <a class="el" href="classvrs_1_1_direct_write_record_data.html" title="Class to hold data that is written directly in the file at the end of a record. Record data held by D...">DirectWriteRecordData</a> object prevents that record from being compressed by VRS, since that data is written directly to the file, hence the name of the API.</p>
<p>When the call returns:</p><ul>
<li>a record has been created and is fully owned and managed by the recordable's <a class="el" href="classvrs_1_1_record_manager.html" title="VRS internal class to manage the records of a specific Recordable after their creation.">RecordManager</a>, despite returning a pointer to it.</li>
<li>the data referenced by the <a class="el" href="classvrs_1_1_data_source.html" title="A class referencing data to be captured in a record at creation.">DataSource</a> has been fully copied in the record's internal buffer, so that the caller can free or modify that source data immediately. You probably want to use that <a class="el" href="classvrs_1_1_data_source.html" title="A class referencing data to be captured in a record at creation.">DataSource</a> to save the <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> part of the record.</li>
<li>the directWriteRecordData object will be owned by the record until it can be used to write its data directly at the end of the record, and deleted only then. Use that object to write the heavy payload of your record, such as the raw image data. directWriteRecordData's data MUST live long enough for the record to be written. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>Timestamp of the record, in seconds. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the record. </td></tr>
    <tr><td class="paramname">formatVersion</td><td>Version number of the format of the record, so that when the record is read, the data can be interpreted appropriately. </td></tr>
    <tr><td class="paramname">data</td><td>A <a class="el" href="classvrs_1_1_data_source.html" title="A class referencing data to be captured in a record at creation.">DataSource</a> that points to the payload to copy in the record immediately. </td></tr>
    <tr><td class="paramname">directWriteRecordData</td><td>data to write directly in the file at the end of the record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the record created. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a4adb6ad3449af962e5dd6984ece18291" name="a4adb6ad3449af962e5dd6984ece18291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adb6ad3449af962e5dd6984ece18291">&#9670;&#160;</a></span>getFlavorTagName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const string &amp; vrs::Recordable::getFlavorTagName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the VRS tag used to store recordable flavors. </p>

</div>
</div>
<a id="abfd07eec2c8cbf66dd9ef72b4a8e7c9e" name="abfd07eec2c8cbf66dd9ef72b4a8e7c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd07eec2c8cbf66dd9ef72b4a8e7c9e">&#9670;&#160;</a></span>getOriginalNameTagName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const string &amp; vrs::Recordable::getOriginalNameTagName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the VRS tag used to store the original name of the recordable. </p>

</div>
</div>
<a id="a4a8a44e8422a7369feb2567b434c5f8e" name="a4a8a44e8422a7369feb2567b434c5f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8a44e8422a7369feb2567b434c5f8e">&#9670;&#160;</a></span>getRecordableInstanceId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t vrs::Recordable::getRecordableInstanceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the unique instance id for this particular recordable. </p><dl class="section return"><dt>Returns</dt><dd>The object's instance id. </dd></dl>

</div>
</div>
<a id="a67a9b03fc55c2cf14643ea06f204f21a" name="a67a9b03fc55c2cf14643ea06f204f21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a9b03fc55c2cf14643ea06f204f21a">&#9670;&#160;</a></span>getRecordableName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vrs::Recordable::getRecordableName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a readable name for the recordable, based on its <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>. </p><dl class="section return"><dt>Returns</dt><dd>The instance's <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> name. </dd></dl>

</div>
</div>
<a id="af26e428b6a13f5a7dc37b63da0d21163" name="af26e428b6a13f5a7dc37b63da0d21163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26e428b6a13f5a7dc37b63da0d21163">&#9670;&#160;</a></span>getRecordableTypeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> vrs::Recordable::getRecordableTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get this instance's recordable type. Can never change for this instance. </p><dl class="section return"><dt>Returns</dt><dd>The instance's RecordableTypeId. </dd></dl>

</div>
</div>
<a id="a9954f74f6c403d6e6fc698658aebed5d" name="a9954f74f6c403d6e6fc698658aebed5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9954f74f6c403d6e6fc698658aebed5d">&#9670;&#160;</a></span>getRecordManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_record_manager.html">RecordManager</a> &amp; vrs::Recordable::getRecordManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the recordable's <a class="el" href="classvrs_1_1_record_manager.html" title="VRS internal class to manage the records of a specific Recordable after their creation.">RecordManager</a>. Not meant for client code use. </p>

</div>
</div>
<a id="a7819263192c0ed9ed98b753693428560" name="a7819263192c0ed9ed98b753693428560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7819263192c0ed9ed98b753693428560">&#9670;&#160;</a></span>getSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vrs::Recordable::getSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the stream's unique serial number generated on stream creation. That serial number is universally unique and it will be preserved during file copies, file processing, and other manipulations that preserve stream tags, whereas the stream's streamID may change. Note that VRS internal tags might be overwritten, in particular during file copy operations, so this serial number might be intentionally replaced (by design). </p>

</div>
</div>
<a id="a2e0974187373d6ec5d9054457de97303" name="a2e0974187373d6ec5d9054457de97303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0974187373d6ec5d9054457de97303">&#9670;&#160;</a></span>getStreamId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> vrs::Recordable::getStreamId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the recordable's <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>. </p><dl class="section return"><dt>Returns</dt><dd>The recordable's <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>. </dd></dl>

</div>
</div>
<a id="a6809bc24ba26b3ad2b3db0c76dda3437" name="a6809bc24ba26b3ad2b3db0c76dda3437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6809bc24ba26b3ad2b3db0c76dda3437">&#9670;&#160;</a></span>getStreamTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp; vrs::Recordable::getStreamTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all the tags at once, both internal &amp; user tags. </p><dl class="section return"><dt>Returns</dt><dd>All the user and VRS tags. </dd></dl>

</div>
</div>
<a id="af776759e061ce2a2d07d7e54ade40940" name="af776759e061ce2a2d07d7e54ade40940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af776759e061ce2a2d07d7e54ade40940">&#9670;&#160;</a></span>getTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt; string, string &gt; &amp; vrs::Recordable::getTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the user tags, all at once. </p><dl class="section return"><dt>Returns</dt><dd>Map of tag-name/tag-value pairs. </dd></dl>

</div>
</div>
<a id="ac937546f2c6f8c2841c927362ac7bbe5" name="ac937546f2c6f8c2841c927362ac7bbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac937546f2c6f8c2841c927362ac7bbe5">&#9670;&#160;</a></span>isRecordableActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::Recordable::isRecordableActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if the recordable is active for recording. </p><dl class="section return"><dt>Returns</dt><dd>True if records will be recorded the next time the record file writer will look for records to write. </dd></dl>

</div>
</div>
<a id="a2a7c86260e9094619a48601f41faabe2" name="a2a7c86260e9094619a48601f41faabe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7c86260e9094619a48601f41faabe2">&#9670;&#160;</a></span>resetNewInstanceIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::resetNewInstanceIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> instance ids are automatically assigned when <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> objects are created. This guarantees that each <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> gets a unique ID. WARNING! If your code relies on specific instance IDs, your design is weak, and you are setting up your project for a world of pain in the future. Use flavors and tag pairs to identify your streams instead. However, when many files are generated successively, it can lead to high instance id values, which can be confusing, and even problematic for unit tests. Use this API to reset the instance counters for each device type, so that the next devices will get an instance id of 1. ATTENTION! if you call this API at the wrong time, you can end up with multiple devices with the same id, and end up in a messy situation. Avoid this API if you can! </p>

</div>
</div>
<a id="a797755d90703adc2e866df76c58fcce2" name="a797755d90703adc2e866df76c58fcce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797755d90703adc2e866df76c58fcce2">&#9670;&#160;</a></span>setCompression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::setCompression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#a37a35edf18e8bb343398cb938d3e2b7b">CompressionPreset</a>&#160;</td>
          <td class="paramname"><em>preset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Override default compression preset for this recordable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>The compression preset to use when writing the next records. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba87b5b80ab4a4536e0d80ebf7157c38" name="aba87b5b80ab4a4536e0d80ebf7157c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba87b5b80ab4a4536e0d80ebf7157c38">&#9670;&#160;</a></span>setCreateRecordDelegate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::setCreateRecordDelegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_recordable.html#a6fb72295d3b60cc1ed3e571c158dec2a">CreateRecordDelegate</a>&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classvrs_1_1_record.html" title="Essential VRS class holding a record&#39;s details and payload in memory during creation.">Record</a> creation requests may be intercepted by setting a CreationRecordDelegate. Using this method, as opposed to making createRecord virtual, can allow interception of record creation requests, for instance, if you want to redirect record creations to another process, without having to change the class inheritance hierarchy. Note that you normally do not need to do this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delegate</td><td>an external function that will handed data when a record needs to be created. You can unset the delegate by using a empty function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a297d0f8952d09aa7bb04fb4766fef5" name="a9a297d0f8952d09aa7bb04fb4766fef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a297d0f8952d09aa7bb04fb4766fef5">&#9670;&#160;</a></span>setRecordableIsActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::setRecordableIsActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isActive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Activate a recordable to enable recording. Must be enabled for pre-record buffering. Recording a device's records can be enabled and disabled on the fly during recording. Recordables can't be added or removed from a <a class="el" href="classvrs_1_1_record_file_writer.html" title="The class to create VRS files.">RecordFileWriter</a> while a file is being written, but recordables can be activated and deactivated instead. </p>

</div>
</div>
<a id="a56b5dbb294126e32a8f63a7d7c9ce652" name="a56b5dbb294126e32a8f63a7d7c9ce652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b5dbb294126e32a8f63a7d7c9ce652">&#9670;&#160;</a></span>setTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::Recordable::setTag </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tagValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set tags for each <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a>, so that you reconfigure the system when reading. Note: tags are written when the file is <em>created</em>, so you need to create them early enough. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>The name of the tag. </td></tr>
    <tr><td class="paramname">tagValue</td><td>The value of the tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_recordable_8h_source.html">Recordable.h</a></li>
<li>vrs/<b>Recordable.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

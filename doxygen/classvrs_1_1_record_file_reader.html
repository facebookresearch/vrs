<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::RecordFileReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_record_file_reader.html">RecordFileReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvrs_1_1_record_file_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vrs::RecordFileReader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class to read VRS files.  
 <a href="classvrs_1_1_record_file_reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_record_file_reader_8h_source.html">RecordFileReader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader_1_1_record_type_counter.html">RecordTypeCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89008779b5bf34acc174e31295f33d57"><td class="memItemLeft" align="right" valign="top"><a id="a89008779b5bf34acc174e31295f33d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RecordFileReader</b> (const <a class="el" href="classvrs_1_1_record_file_reader.html">RecordFileReader</a> &amp;)=delete</td></tr>
<tr class="separator:a89008779b5bf34acc174e31295f33d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2ff2514dde0ce0574a835c6007bcf7"><td class="memItemLeft" align="right" valign="top"><a id="aeb2ff2514dde0ce0574a835c6007bcf7"></a>
<a class="el" href="classvrs_1_1_record_file_reader.html">RecordFileReader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classvrs_1_1_record_file_reader.html">RecordFileReader</a> &amp;)=delete</td></tr>
<tr class="separator:aeb2ff2514dde0ce0574a835c6007bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b4fb530ccc1076a1a342afdea7d6f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a12b4fb530ccc1076a1a342afdea7d6f0">isVrsFile</a> (const string &amp;filePath)</td></tr>
<tr class="separator:a12b4fb530ccc1076a1a342afdea7d6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc82245fcc52a27bc2dc8810316d798"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a1fc82245fcc52a27bc2dc8810316d798">isVrsFile</a> (const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;fileSpec)</td></tr>
<tr class="separator:a1fc82245fcc52a27bc2dc8810316d798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4610b633871a23d53b95e50310d23ad1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a4610b633871a23d53b95e50310d23ad1">openFile</a> (const string &amp;filePath, bool autoWriteFixedIndex=false)</td></tr>
<tr class="separator:a4610b633871a23d53b95e50310d23ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef03ae06668f360654370a86a8461e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#acef03ae06668f360654370a86a8461e7">openFile</a> (const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;fileSpec, bool autoWriteFixedIndex=false)</td></tr>
<tr class="separator:acef03ae06668f360654370a86a8461e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1451e3277ae56e63d37bb58160b16ea3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a1451e3277ae56e63d37bb58160b16ea3">isOpened</a> () const</td></tr>
<tr class="separator:a1451e3277ae56e63d37bb58160b16ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0697eaae250d06338ef03a53916ea23d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a0697eaae250d06338ef03a53916ea23d">setStreamPlayer</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer)</td></tr>
<tr class="separator:a0697eaae250d06338ef03a53916ea23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10599fa70f7bbb780176bbe3d8a140a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ab10599fa70f7bbb780176bbe3d8a140a">clearStreamPlayers</a> ()</td></tr>
<tr class="separator:ab10599fa70f7bbb780176bbe3d8a140a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106707a35c6b20f348b004b9359a5db7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a106707a35c6b20f348b004b9359a5db7">prefetchRecordSequence</a> (const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp;records, bool clearSequence=true)</td></tr>
<tr class="separator:a106707a35c6b20f348b004b9359a5db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c43261d5d6c42473a862542e8e68e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a13c43261d5d6c42473a862542e8e68e8">isRecordAvailableOrPrefetch</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;recordInfo)</td></tr>
<tr class="separator:a13c43261d5d6c42473a862542e8e68e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b4f29ef5a0a472641a9319378f132a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a87b4f29ef5a0a472641a9319378f132a">readRecord</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;recordInfo)</td></tr>
<tr class="separator:a87b4f29ef5a0a472641a9319378f132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad6cc15c4624918e05eb728d3eb78f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a7ad6cc15c4624918e05eb728d3eb78f1">readRecord</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;recordInfo, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer)</td></tr>
<tr class="separator:a7ad6cc15c4624918e05eb728d3eb78f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051665b6f64f0b0c33b806b157a3c103"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a051665b6f64f0b0c33b806b157a3c103">readAllRecords</a> ()</td></tr>
<tr class="separator:a051665b6f64f0b0c33b806b157a3c103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eee9036f7ed16beacb03a7d817a8ea"><td class="memItemLeft" align="right" valign="top">vector&lt; std::pair&lt; string, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a30eee9036f7ed16beacb03a7d817a8ea">getFileChunks</a> () const</td></tr>
<tr class="separator:a30eee9036f7ed16beacb03a7d817a8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e2e5fbd454c41535bd04d467d53ff"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ae33e2e5fbd454c41535bd04d467d53ff">getTotalSourceSize</a> () const</td></tr>
<tr class="separator:ae33e2e5fbd454c41535bd04d467d53ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffa8fc45e16e26dc2cac89d53089313"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a0ffa8fc45e16e26dc2cac89d53089313">closeFile</a> ()</td></tr>
<tr class="separator:a0ffa8fc45e16e26dc2cac89d53089313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a97a396f125c4fe2e1d23549d55492c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a5a97a396f125c4fe2e1d23549d55492c">hasIndex</a> () const</td></tr>
<tr class="separator:a5a97a396f125c4fe2e1d23549d55492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3dc0f6f30799e33abb8eb22f511f92"><td class="memItemLeft" align="right" valign="top">const set&lt; <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a0a3dc0f6f30799e33abb8eb22f511f92">getStreams</a> () const</td></tr>
<tr class="separator:a0a3dc0f6f30799e33abb8eb22f511f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb770d30ce7b22fac2c259e2430540bc"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#acb770d30ce7b22fac2c259e2430540bc">getStreams</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, const string &amp;flavor={}) const</td></tr>
<tr class="separator:acb770d30ce7b22fac2c259e2430540bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286fea5e9d8553ea36064d433719067b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a286fea5e9d8553ea36064d433719067b">getStreamForType</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, uint32_t indexNumber=0) const</td></tr>
<tr class="separator:a286fea5e9d8553ea36064d433719067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da8e7327759dbfe6a347b3a794dd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ad3da8e7327759dbfe6a347b3a794dd7c">getStreamForName</a> (const string &amp;name) const</td></tr>
<tr class="separator:ad3da8e7327759dbfe6a347b3a794dd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31723e14ae3e1498eaaf9624753305c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a31723e14ae3e1498eaaf9624753305c4">getStreamForFlavor</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, const string &amp;flavor, uint32_t indexNumber=0) const</td></tr>
<tr class="separator:a31723e14ae3e1498eaaf9624753305c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b17a801f4af270df7bf3e5a311d23e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ad5b17a801f4af270df7bf3e5a311d23e">getStreamForTag</a> (const string &amp;tagName, const string &amp;tag, <a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId=<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360">RecordableTypeId::Undefined</a>) const</td></tr>
<tr class="separator:ad5b17a801f4af270df7bf3e5a311d23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71cbe2b424994eb9fa7d791ee3d0809"><td class="memItemLeft" align="right" valign="top"><a id="ab71cbe2b424994eb9fa7d791ee3d0809"></a>
<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ab71cbe2b424994eb9fa7d791ee3d0809">getStreamForSerialNumber</a> (const string &amp;streamSerialNumber) const</td></tr>
<tr class="memdesc:ab71cbe2b424994eb9fa7d791ee3d0809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the stream with the specified stream serial number. <br /></td></tr>
<tr class="separator:ab71cbe2b424994eb9fa7d791ee3d0809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1e47d89a735c3246aa1c6c62a2f6b4"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a0b1e47d89a735c3246aa1c6c62a2f6b4">getIndex</a> () const</td></tr>
<tr class="separator:a0b1e47d89a735c3246aa1c6c62a2f6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8915ccc9dad60f6d0db4800b21fef690"><td class="memItemLeft" align="right" valign="top">const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a8915ccc9dad60f6d0db4800b21fef690">getIndex</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:a8915ccc9dad60f6d0db4800b21fef690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf4e571bbeb4b4b8405ca3e16cc5ddd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#afbf4e571bbeb4b4b8405ca3e16cc5ddd">getRecordCount</a> () const</td></tr>
<tr class="separator:afbf4e571bbeb4b4b8405ca3e16cc5ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606e0603dd333e75fe67b68f675cbb89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a606e0603dd333e75fe67b68f675cbb89">getRecordCount</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:a606e0603dd333e75fe67b68f675cbb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d9fccfdfac6dbae52c23bea78778be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a84d9fccfdfac6dbae52c23bea78778be">getRecordCount</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType) const</td></tr>
<tr class="separator:a84d9fccfdfac6dbae52c23bea78778be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51232c086edc4c6f87ede54fec0804"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a2a51232c086edc4c6f87ede54fec0804">getRecord</a> (uint32_t globalIndex) const</td></tr>
<tr class="separator:a2a51232c086edc4c6f87ede54fec0804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f682cf56f581abbcdb0ae95a70d86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a348f682cf56f581abbcdb0ae95a70d86">getRecord</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, uint32_t indexNumber) const</td></tr>
<tr class="separator:a348f682cf56f581abbcdb0ae95a70d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3213a61f8ad7c63ff8128762c6efb2dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a3213a61f8ad7c63ff8128762c6efb2dc">getRecord</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t indexNumber) const</td></tr>
<tr class="separator:a3213a61f8ad7c63ff8128762c6efb2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b1b3ece3bc93156576adedaa661316"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a59b1b3ece3bc93156576adedaa661316">getLastRecord</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType) const</td></tr>
<tr class="separator:a59b1b3ece3bc93156576adedaa661316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d95338eac87e2a492e72ea02e174f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#af9d95338eac87e2a492e72ea02e174f1">getRecordByTime</a> (double timestamp) const</td></tr>
<tr class="separator:af9d95338eac87e2a492e72ea02e174f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16d0524ed17d9ebdc183c065829d8b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ab16d0524ed17d9ebdc183c065829d8b2">getRecordByTime</a> (<a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, double timestamp) const</td></tr>
<tr class="separator:ab16d0524ed17d9ebdc183c065829d8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ea7fa61efba1f911f7a873b7693da3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a70ea7fa61efba1f911f7a873b7693da3">getRecordByTime</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, double timestamp) const</td></tr>
<tr class="separator:a70ea7fa61efba1f911f7a873b7693da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa239fd0ceaab5b484df3943034a6a220"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#aa239fd0ceaab5b484df3943034a6a220">getRecordByTime</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, double timestamp) const</td></tr>
<tr class="separator:aa239fd0ceaab5b484df3943034a6a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c63ad01eff3be54bfe10be4d93d98c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ac8c63ad01eff3be54bfe10be4d93d98c">getNearestRecordByTime</a> (double timestamp, double epsilon, <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId={}, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType=<a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2cea0db45d2a4141101bdfe48e3314cfbca3">Record::Type::UNDEFINED</a>) const</td></tr>
<tr class="separator:ac8c63ad01eff3be54bfe10be4d93d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377791597b3de59d33e67b85848d41c1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a377791597b3de59d33e67b85848d41c1">getRecordIndex</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *record) const</td></tr>
<tr class="separator:a377791597b3de59d33e67b85848d41c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6bd308cd42c001931badafef1da65c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#afc6bd308cd42c001931badafef1da65c">getRecordStreamIndex</a> (const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *record) const</td></tr>
<tr class="separator:afc6bd308cd42c001931badafef1da65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b30e9f882797610f5087b39b0533151"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a3b30e9f882797610f5087b39b0533151">getFirstDataRecordTime</a> () const</td></tr>
<tr class="separator:a3b30e9f882797610f5087b39b0533151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7851f34655359f9a6b202c5c336c091d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a7851f34655359f9a6b202c5c336c091d">readFirstConfigurationRecord</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer=nullptr)</td></tr>
<tr class="separator:a7851f34655359f9a6b202c5c336c091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61455e4da3366017413571d246a37eea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a61455e4da3366017413571d246a37eea">readFirstConfigurationRecords</a> (<a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer=nullptr)</td></tr>
<tr class="separator:a61455e4da3366017413571d246a37eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf76f4ffb73ac339bec3c09480d00111"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#acf76f4ffb73ac339bec3c09480d00111">readFirstConfigurationRecordsForType</a> (<a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a> typeId, <a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *streamPlayer=nullptr)</td></tr>
<tr class="separator:acf76f4ffb73ac339bec3c09480d00111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa3ace7d111cd87f6fb5200094a8a4"><td class="memItemLeft" align="right" valign="top">const map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a3cfa3ace7d111cd87f6fb5200094a8a4">getTags</a> () const</td></tr>
<tr class="separator:a3cfa3ace7d111cd87f6fb5200094a8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a306903b1d06bec809c9c347c4f7a5"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a13a306903b1d06bec809c9c347c4f7a5">getTag</a> (const string &amp;name) const</td></tr>
<tr class="separator:a13a306903b1d06bec809c9c347c4f7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39276082752cec88e4dde4a1b7f4452c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a39276082752cec88e4dde4a1b7f4452c">getTags</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:a39276082752cec88e4dde4a1b7f4452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0acd1edcc7a4e42b8657ec5d389ddf"><td class="memItemLeft" align="right" valign="top"><a id="ade0acd1edcc7a4e42b8657ec5d389ddf"></a>
const map&lt; <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>, <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ade0acd1edcc7a4e42b8657ec5d389ddf">getStreamTags</a> () const</td></tr>
<tr class="memdesc:ade0acd1edcc7a4e42b8657ec5d389ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tags for all the streams at once. <br /></td></tr>
<tr class="separator:ade0acd1edcc7a4e42b8657ec5d389ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770916f65184c8bb68d5b4e92b8e6ffc"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a770916f65184c8bb68d5b4e92b8e6ffc">getTag</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, const string &amp;name) const</td></tr>
<tr class="separator:a770916f65184c8bb68d5b4e92b8e6ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9447b11ac25de5ea70cb9b170ddb300"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#aa9447b11ac25de5ea70cb9b170ddb300">getOriginalRecordableTypeName</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:aa9447b11ac25de5ea70cb9b170ddb300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d77aa3800838c0e8da4068316c066c"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a24d77aa3800838c0e8da4068316c066c">getFlavor</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:a24d77aa3800838c0e8da4068316c066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a02b8899e92f93c54efd9e98b7615"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a0e9a02b8899e92f93c54efd9e98b7615">getSerialNumber</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:a0e9a02b8899e92f93c54efd9e98b7615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d050e7c1002a47bbdf755ae1ee8263"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ae0d050e7c1002a47bbdf755ae1ee8263">getStreamsSignature</a> () const</td></tr>
<tr class="separator:ae0d050e7c1002a47bbdf755ae1ee8263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ee554269ef5e43590070c735778fe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#aa8ee554269ef5e43590070c735778fe0">mightContainImages</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:aa8ee554269ef5e43590070c735778fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc3f6e58aba6d53e66dabeff41deb8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a6fc3f6e58aba6d53e66dabeff41deb8b">mightContainAudio</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId) const</td></tr>
<tr class="separator:a6fc3f6e58aba6d53e66dabeff41deb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ecb4050743d4cfb0d979a8d6184e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a35ecb4050743d4cfb0d979a8d6184e0d">getRecordFormat</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a> recordType, uint32_t formatVersion, <a class="el" href="classvrs_1_1_record_format.html">RecordFormat</a> &amp;outFormat) const</td></tr>
<tr class="separator:a35ecb4050743d4cfb0d979a8d6184e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02976fb2d32461f5ed9a469b0bc644ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a02976fb2d32461f5ed9a469b0bc644ac">getRecordFormats</a> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, <a class="el" href="namespacevrs.html#a04d155e698e82b4cd67ec9312fadefb0">RecordFormatMap</a> &amp;outFormats) const</td></tr>
<tr class="separator:a02976fb2d32461f5ed9a469b0bc644ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5968d413f0e3e7ad69854c765c178afd"><td class="memItemLeft" align="right" valign="top"><a id="a5968d413f0e3e7ad69854c765c178afd"></a>
std::unique_ptr&lt; <a class="el" href="classvrs_1_1_data_layout.html">DataLayout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDataLayout</b> (<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> streamId, const <a class="el" href="classvrs_1_1_content_block_id.html">ContentBlockId</a> &amp;blockId) const</td></tr>
<tr class="separator:a5968d413f0e3e7ad69854c765c178afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424ad10de5e63536f7f84338f76b08e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a424ad10de5e63536f7f84338f76b08e6">setOpenProgressLogger</a> (<a class="el" href="classvrs_1_1_progress_logger.html">ProgressLogger</a> *progressLogger)</td></tr>
<tr class="separator:a424ad10de5e63536f7f84338f76b08e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea8aa1242da01d7c84ebd7a5f6f52ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a9ea8aa1242da01d7c84ebd7a5f6f52ae">setCachingStrategy</a> (<a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a> cachingStrategy)</td></tr>
<tr class="separator:a9ea8aa1242da01d7c84ebd7a5f6f52ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ebf2a9c78c03470fcfcbe14cb902e6"><td class="memItemLeft" align="right" valign="top"><a id="a77ebf2a9c78c03470fcfcbe14cb902e6"></a>
<a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCachingStrategy</b> () const</td></tr>
<tr class="separator:a77ebf2a9c78c03470fcfcbe14cb902e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d0f022f92f9939090d18e824f4b312"><td class="memItemLeft" align="right" valign="top"><a id="aa8d0f022f92f9939090d18e824f4b312"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#aa8d0f022f92f9939090d18e824f4b312">setStatsCallback</a> (const FileHandler::CacheStatsCallbackFunction &amp;statsCallback)</td></tr>
<tr class="memdesc:aa8d0f022f92f9939090d18e824f4b312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for cache stats. <br /></td></tr>
<tr class="separator:aa8d0f022f92f9939090d18e824f4b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e29787a837db9844b460fb1aa38eca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a09e29787a837db9844b460fb1aa38eca">purgeFileCache</a> ()</td></tr>
<tr class="separator:a09e29787a837db9844b460fb1aa38eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc88304db2863c0ee09294e91c187dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#abdc88304db2863c0ee09294e91c187dd">setFileHandler</a> (std::unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt; fileHandler)</td></tr>
<tr class="separator:abdc88304db2863c0ee09294e91c187dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65bc014d94f6a18af61cc9f9ae09539"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#ac65bc014d94f6a18af61cc9f9ae09539">getFileHandler</a> () const</td></tr>
<tr class="separator:ac65bc014d94f6a18af61cc9f9ae09539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a39729fdb368d109746548f815bfc0184"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_record_file_reader.html#a39729fdb368d109746548f815bfc0184">vrsFilePathToFileSpec</a> (const string &amp;filePath, <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;outFileSpec, bool checkLocalFile=false)</td></tr>
<tr class="separator:a39729fdb368d109746548f815bfc0184"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class to read VRS files. </p>
<p>Recipe:</p><ul>
<li>open a VRS file using <a class="el" href="classvrs_1_1_record_file_reader.html#a4610b633871a23d53b95e50310d23ad1">openFile()</a>.</li>
<li>get info about the VRS file using <a class="el" href="classvrs_1_1_record_file_reader.html#a3cfa3ace7d111cd87f6fb5200094a8a4">getTags()</a>. (optional: the writer may provide recording context info).</li>
<li>find out which streams it contains using <a class="el" href="classvrs_1_1_record_file_reader.html#a0a3dc0f6f30799e33abb8eb22f511f92">getStreams()</a>.</li>
<li>attach record players to the streams you care about, using <a class="el" href="classvrs_1_1_record_file_reader.html#a0697eaae250d06338ef03a53916ea23d">setStreamPlayer()</a>.</li>
<li>playback records one-by-one using <a class="el" href="classvrs_1_1_record_file_reader.html#a87b4f29ef5a0a472641a9319378f132a">readRecord()</a>, or all at once using <a class="el" href="classvrs_1_1_record_file_reader.html#a051665b6f64f0b0c33b806b157a3c103">readAllRecords()</a>.</li>
<li>close the file. State, configuration &amp; data records handling is delegated to their stream id players. Player can 'process' the data in the callback made by the file reader's thread, or delegate the work by posting a PlaybackRecord to a PlaybackThread. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab10599fa70f7bbb780176bbe3d8a140a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10599fa70f7bbb780176bbe3d8a140a">&#9670;&nbsp;</a></span>clearStreamPlayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::clearStreamPlayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all registered stream players. </p><dl class="section return"><dt>Returns</dt><dd>O on success. </dd></dl>

</div>
</div>
<a id="a0ffa8fc45e16e26dc2cac89d53089313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffa8fc45e16e26dc2cac89d53089313">&#9670;&nbsp;</a></span>closeFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::closeFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the underlying file, if one is open. </p><dl class="section return"><dt>Returns</dt><dd>0 on success or if no file was open, or some file system error code. </dd></dl>

</div>
</div>
<a id="a30eee9036f7ed16beacb03a7d817a8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eee9036f7ed16beacb03a7d817a8ea">&#9670;&nbsp;</a></span>getFileChunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; string, int64_t &gt; &gt; vrs::RecordFileReader::getFileChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a list of the file's chunks, path + size in bytes. </p><dl class="section return"><dt>Returns</dt><dd>A vector of pairs path-file size. </dd></dl>

</div>
</div>
<a id="ac65bc014d94f6a18af61cc9f9ae09539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65bc014d94f6a18af61cc9f9ae09539">&#9670;&nbsp;</a></span>getFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt; vrs::RecordFileReader::getFileHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a clone of the current file handler, for use elsewhere. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the current file handler. </dd></dl>

</div>
</div>
<a id="a3b30e9f882797610f5087b39b0533151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b30e9f882797610f5087b39b0533151">&#9670;&nbsp;</a></span>getFirstDataRecordTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vrs::RecordFileReader::getFirstDataRecordTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timestamp for the first data record in the whole file. </p><dl class="section return"><dt>Returns</dt><dd>The timestamp for the file data record, or 0, if the file contains no data record. </dd></dl>

</div>
</div>
<a id="a24d77aa3800838c0e8da4068316c066c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d77aa3800838c0e8da4068316c066c">&#9670;&nbsp;</a></span>getFlavor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vrs::RecordFileReader::getFlavor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Streams using &lt;&lt; <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> Class &gt;&gt; ids require a &lt;&lt; flavor &gt;&gt;, which must be provided when the stream was created. Use this API to get the recordable flavor provided, if any, when the stream was created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flavor for the corresponding RecordableTypeId, or an empty string, if no flavor was provided when the stream was created. </dd></dl>

</div>
</div>
<a id="a0b1e47d89a735c3246aa1c6c62a2f6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1e47d89a735c3246aa1c6c62a2f6b4">&#9670;&nbsp;</a></span>getIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;<a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a>&gt;&amp; vrs::RecordFileReader::getIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index of the VRS file, which is an ordered array of RecordInfo, each describing the records, sorted by timestamp. </p><dl class="section return"><dt>Returns</dt><dd>The index. </dd></dl>

</div>
</div>
<a id="a8915ccc9dad60f6d0db4800b21fef690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8915ccc9dad60f6d0db4800b21fef690">&#9670;&nbsp;</a></span>getIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp; vrs::RecordFileReader::getIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a record index limited to a specific stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the file, with all the records. </dd></dl>

</div>
</div>
<a id="a59b1b3ece3bc93156576adedaa661316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b1b3ece3bc93156576adedaa661316">&#9670;&nbsp;</a></span>getLastRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getLastRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the last record for a specific stream and specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of the records to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr if the streamId or no record of the type was found. </dd></dl>

</div>
</div>
<a id="ac8c63ad01eff3be54bfe10be4d93d98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c63ad01eff3be54bfe10be4d93d98c">&#9670;&nbsp;</a></span>getNearestRecordByTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getNearestRecordByTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em> = <code><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2cea0db45d2a4141101bdfe48e3314cfbca3">Record::Type::UNDEFINED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the nearest record of a specific stream within the range of (timestamp - epsilon) - (timestamp + epsilon). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
    <tr><td class="paramname">epsilon</td><td>the threshold we search for the index. </td></tr>
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the stream to consider. Leave undefined to search all streams </td></tr>
    <tr><td class="paramname">recordType</td><td>record type to find, or <a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2cea0db45d2a4141101bdfe48e3314cfbca3" title="don&#39;t use.">Record::Type::UNDEFINED</a> for any record type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="aa9447b11ac25de5ea70cb9b170ddb300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9447b11ac25de5ea70cb9b170ddb300">&#9670;&nbsp;</a></span>getOriginalRecordableTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vrs::RecordFileReader::getOriginalRecordableTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RecordableTypeId text descriptions may change over time, so at the time of recording, we capture the text name, so that we can see what it was when the file was recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original text description for the corresponding RecordableTypeId. </dd></dl>

</div>
</div>
<a id="a3213a61f8ad7c63ff8128762c6efb2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3213a61f8ad7c63ff8128762c6efb2dc">&#9670;&nbsp;</a></span>getRecord() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a specific record for a specific stream and type, by index number. nullptr is returned if no record is found for that index number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of the records to consider. </td></tr>
    <tr><td class="paramname">indexNumber</td><td>Index of the record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr if the streamId or the indexNumber wasn't found for that specific type. </dd></dl>

</div>
</div>
<a id="a348f682cf56f581abbcdb0ae95a70d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348f682cf56f581abbcdb0ae95a70d86">&#9670;&nbsp;</a></span>getRecord() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a specific record for a specific stream, regardless of type, by index number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">indexNumber</td><td>Index of the record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr if the streamId, or a record with the indexNumber wasn't found. </dd></dl>

</div>
</div>
<a id="a2a51232c086edc4c6f87ede54fec0804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a51232c086edc4c6f87ede54fec0804">&#9670;&nbsp;</a></span>getRecord() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecord </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>globalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a specific record, regardless of its stream or type, by its absolute index number in the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalIndex</td><td>Index of the record to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr the index exceeds the total number of records. </dd></dl>

</div>
</div>
<a id="af9d95338eac87e2a492e72ea02e174f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d95338eac87e2a492e72ea02e174f1">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="ab16d0524ed17d9ebdc183c065829d8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16d0524ed17d9ebdc183c065829d8b2">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record of a specific type at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordtype</td><td>record type to find. </td></tr>
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="a70ea7fa61efba1f911f7a873b7693da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ea7fa61efba1f911f7a873b7693da3">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record of a specific stream at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the stream to consider. </td></tr>
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="aa239fd0ceaab5b484df3943034a6a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa239fd0ceaab5b484df3943034a6a220">&#9670;&nbsp;</a></span>getRecordByTime() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * vrs::RecordFileReader::getRecordByTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first record of a specific stream of a specific type at or after a timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the stream to consider. </td></tr>
    <tr><td class="paramname">recordtype</td><td>record type to find. </td></tr>
    <tr><td class="paramname">timestamp</td><td>timestamp to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the record info, or nullptr (timestamp is too big?). </dd></dl>

</div>
</div>
<a id="afbf4e571bbeb4b4b8405ca3e16cc5ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf4e571bbeb4b4b8405ca3e16cc5ddd">&#9670;&nbsp;</a></span>getRecordCount() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::RecordFileReader::getRecordCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of records in the whole file. </p><dl class="section return"><dt>Returns</dt><dd>The number of records in the whole VRS file, or 0, if no file is opened. </dd></dl>

</div>
</div>
<a id="a606e0603dd333e75fe67b68f675cbb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606e0603dd333e75fe67b68f675cbb89">&#9670;&nbsp;</a></span>getRecordCount() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::RecordFileReader::getRecordCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of records of a specific stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of records of the specified stream. </dd></dl>

</div>
</div>
<a id="a84d9fccfdfac6dbae52c23bea78778be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d9fccfdfac6dbae52c23bea78778be">&#9670;&nbsp;</a></span>getRecordCount() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::RecordFileReader::getRecordCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of records for a specific stream and specific record type. Attention: this computation has a linear complexity, so cache the result! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of records to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of records for the specified stream id &amp; record type. </dd></dl>

</div>
</div>
<a id="a35ecb4050743d4cfb0d979a8d6184e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ecb4050743d4cfb0d979a8d6184e0d">&#9670;&nbsp;</a></span>getRecordFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::getRecordFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record.html#a449931b6fc23eaef585e3c7a4c0ed2ce">Record::Type</a>&#160;</td>
          <td class="paramname"><em>recordType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>formatVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_record_format.html">RecordFormat</a> &amp;&#160;</td>
          <td class="paramname"><em>outFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> for a specific stream, record type &amp; record format version. Mostly useful for testing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">recordType</td><td>Type of the records to consider. </td></tr>
    <tr><td class="paramname">formatVersion</td><td>Version to consider. </td></tr>
    <tr><td class="paramname">outFormat</td><td><a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> reference to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if outFormat value was set, false if no <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> version was found. </dd></dl>

</div>
</div>
<a id="a02976fb2d32461f5ed9a469b0bc644ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02976fb2d32461f5ed9a469b0bc644ac">&#9670;&nbsp;</a></span>getRecordFormats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::RecordFileReader::getRecordFormats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#a04d155e698e82b4cd67ec9312fadefb0">RecordFormatMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outFormats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> description used in this VRS file. Mostly useful for tools like VRStool &amp; VRSplayer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">outFormats</td><td>Reference to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of formats found. </dd></dl>

</div>
</div>
<a id="a377791597b3de59d33e67b85848d41c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377791597b3de59d33e67b85848d41c1">&#9670;&nbsp;</a></span>getRecordIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::RecordFileReader::getRecordIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a record's index in the global index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>pointer of the record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in the global index, or <a class="el" href="classvrs_1_1_record_file_reader.html#afbf4e571bbeb4b4b8405ca3e16cc5ddd">getRecordCount()</a> is record is nullptr. </dd></dl>

</div>
</div>
<a id="afc6bd308cd42c001931badafef1da65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6bd308cd42c001931badafef1da65c">&#9670;&nbsp;</a></span>getRecordStreamIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vrs::RecordFileReader::getRecordStreamIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a record's index in the record's stream index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>pointer of the record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in the record's stream index, or <a class="el" href="classvrs_1_1_record_file_reader.html#afbf4e571bbeb4b4b8405ca3e16cc5ddd">getRecordCount()</a> is record is nullptr. </dd></dl>

</div>
</div>
<a id="a0e9a02b8899e92f93c54efd9e98b7615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9a02b8899e92f93c54efd9e98b7615">&#9670;&nbsp;</a></span>getSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vrs::RecordFileReader::getSerialNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a stream's serial number. When streams are created, they are assigned a unique serial number by their <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> object. That serial number is universally unique and it will be preserved during file copies, file processing, and other manipulations that preserve stream tags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream's serial number, or the empty string if the stream ID is not valid. When opening files created before stream serial numbers were introduced, <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> automatically generates a stable serial number for every stream based on the file tags, the stream's tags (both user and VRS internal tags), and the stream type and sequence number. This serial number is stable and preserved during copy and filtering operations that preserve stream tags. </dd></dl>

</div>
</div>
<a id="a31723e14ae3e1498eaaf9624753305c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31723e14ae3e1498eaaf9624753305c4">&#9670;&nbsp;</a></span>getStreamForFlavor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> vrs::RecordFileReader::getStreamForFlavor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>flavor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a stream of a specific flavor, by index number. Use isValid() to tell if a device was found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>The RecordableTypeId of the type of device to look for. </td></tr>
    <tr><td class="paramname">flavor</td><td>A recordable flavor to search for. </td></tr>
    <tr><td class="paramname">indexNumber</td><td>An index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>. Call isValid() to know if a matching <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> was actually found. </dd></dl>

</div>
</div>
<a id="ad3da8e7327759dbfe6a347b3a794dd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3da8e7327759dbfe6a347b3a794dd7c">&#9670;&nbsp;</a></span>getStreamForName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> vrs::RecordFileReader::getStreamForName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a stream from an absolute or relative numeric name. Absolute numeric names are in the form &lt;numeric_recordable_type_id&gt;-&lt;instance_id&gt;, eg 1201-1 Relative numeric names are in the form &lt;numeric_recordable_type_id&gt;+&lt;instance_id&gt;, eg 1201+1 Relative numeric names have instance ids interpreted as the nth stream of that type, eg 1201+3 is the 3rd stream with the recordable type id 1201 (if there is such a stream). In all cases, use isValid() to verify that the stream was found in the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>an absolute or relative numeric name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>, valid only if the numeric name exists in the file. </dd></dl>

</div>
</div>
<a id="ad5b17a801f4af270df7bf3e5a311d23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b17a801f4af270df7bf3e5a311d23e">&#9670;&nbsp;</a></span>getStreamForTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> vrs::RecordFileReader::getStreamForTag </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em> = <code><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360">RecordableTypeId::Undefined</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first stream with given tag name/value pair. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>The name of the tag to look for. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag value to look for. </td></tr>
    <tr><td class="paramname">typeId</td><td>The RecordableTypeId to limit the search to, or <a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360" title="Value used for default initializations and marking undefined situations.">RecordableTypeId::Undefined</a> to look for any device type. Note: if more than one stream match the criteria, the "first" one is returned, which means the one with the lowest RecordableTypeId enum value, or if equal, the one with the lowest <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> instanceId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>. Call isValid() to know if a matching <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> was actually found. </dd></dl>

</div>
</div>
<a id="a286fea5e9d8553ea36064d433719067b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286fea5e9d8553ea36064d433719067b">&#9670;&nbsp;</a></span>getStreamForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> vrs::RecordFileReader::getStreamForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a stream for a specific device type, by index number. Use isValid() to tell if a device was found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>The RecordableTypeId of the type of device to look for. </td></tr>
    <tr><td class="paramname">indexNumber</td><td>An index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a>. Call isValid() to know if a matching <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> was actually found. </dd></dl>

</div>
</div>
<a id="a0a3dc0f6f30799e33abb8eb22f511f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3dc0f6f30799e33abb8eb22f511f92">&#9670;&nbsp;</a></span>getStreams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const set&lt;<a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&gt;&amp; vrs::RecordFileReader::getStreams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the set of <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> for all the streams in the file. </p><dl class="section return"><dt>Returns</dt><dd>The set of stream IDs for which there are records. </dd></dl>

</div>
</div>
<a id="acb770d30ce7b22fac2c259e2430540bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb770d30ce7b22fac2c259e2430540bc">&#9670;&nbsp;</a></span>getStreams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvrs_1_1_stream_id.html">StreamId</a> &gt; vrs::RecordFileReader::getStreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>flavor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a set of <a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> for a specific type, and an optional flavor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>a recordable type id, maybe a <a class="el" href="classvrs_1_1_recordable.html" title="Class to override to implement a record producing device, or virtual device.">Recordable</a> Class. Use <a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5aec0fc0100c4fc1ce4eea230c3dc10360" title="Value used for default initializations and marking undefined situations.">RecordableTypeId::Undefined</a> to match any recordable type. </td></tr>
    <tr><td class="paramname">flavor</td><td>an option flavor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of stream ids of the given type, and of the provided flavor (if any). </dd></dl>

</div>
</div>
<a id="ae0d050e7c1002a47bbdf755ae1ee8263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d050e7c1002a47bbdf755ae1ee8263">&#9670;&nbsp;</a></span>getStreamsSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vrs::RecordFileReader::getStreamsSignature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a string describing the stream configuration, with stream type, serial number, and record counts, so it can be used to verify that the file looks a specific way without doing a full checksum. The stream Instance ID are NOT used, as they might be modified during copies. </p>

</div>
</div>
<a id="a13a306903b1d06bec809c9c347c4f7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a306903b1d06bec809c9c347c4f7a5">&#9670;&nbsp;</a></span>getTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; vrs::RecordFileReader::getTag </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a specific tag by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the tag to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag value, or the empty string if the tag wasn't found. </dd></dl>

</div>
</div>
<a id="a770916f65184c8bb68d5b4e92b8e6ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770916f65184c8bb68d5b4e92b8e6ffc">&#9670;&nbsp;</a></span>getTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; vrs::RecordFileReader::getTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a specific tag for a specific record stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the tag to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag value, or the empty string if the tag wasn't found. </dd></dl>

</div>
</div>
<a id="a3cfa3ace7d111cd87f6fb5200094a8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfa3ace7d111cd87f6fb5200094a8a4">&#9670;&nbsp;</a></span>getTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt;string, string&gt;&amp; vrs::RecordFileReader::getTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the tags map for the whole file. Does not include any stream tag. </p><dl class="section return"><dt>Returns</dt><dd>The file's tags map. </dd></dl>

</div>
</div>
<a id="a39276082752cec88e4dde4a1b7f4452c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39276082752cec88e4dde4a1b7f4452c">&#9670;&nbsp;</a></span>getTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvrs_1_1_stream_tags.html">StreamTags</a> &amp; vrs::RecordFileReader::getTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tags for a specific record stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tags for the stream. If the streamId doesn't exist in the file, the map returned will be an empty map. </dd></dl>

</div>
</div>
<a id="ae33e2e5fbd454c41535bd04d467d53ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33e2e5fbd454c41535bd04d467d53ff">&#9670;&nbsp;</a></span>getTotalSourceSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vrs::RecordFileReader::getTotalSourceSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the size of the whole file. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes of all the chunks combined. </dd></dl>

</div>
</div>
<a id="a5a97a396f125c4fe2e1d23549d55492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a97a396f125c4fe2e1d23549d55492c">&#9670;&nbsp;</a></span>hasIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::hasIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VRS might not have a valid index, for instance, if the format is too old, or if there was a crash while the file was being produced. If there is no index, one will be created when the file is opened, but it will cost time. Requirements: the file must be opened for this method to be valid. </p><dl class="section return"><dt>Returns</dt><dd>True if the actual file has an index. Either way, we always have an in-memory index. </dd></dl>

</div>
</div>
<a id="a1451e3277ae56e63d37bb58160b16ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1451e3277ae56e63d37bb58160b16ea3">&#9670;&nbsp;</a></span>isOpened()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::isOpened </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell if an actual file is being read </p><dl class="section return"><dt>Returns</dt><dd>True if the file is opened. </dd></dl>

</div>
</div>
<a id="a13c43261d5d6c42473a862542e8e68e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c43261d5d6c42473a862542e8e68e8">&#9670;&nbsp;</a></span>isRecordAvailableOrPrefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::isRecordAvailableOrPrefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>recordInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a file record is available for immediate loading (e.g. on disk or in-cache). If not, begin background prefetching at the requested frame (but do not wait for results). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordInfo</td><td>RecordInfo reference of the record to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if available, false if unavailable (e.g. would require a network fetch). </dd></dl>

</div>
</div>
<a id="a1fc82245fcc52a27bc2dc8810316d798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc82245fcc52a27bc2dc8810316d798">&#9670;&nbsp;</a></span>isVrsFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::isVrsFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSpec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a file is most probably a VRS file by checking its header for VRS file's format magic numbers. Note: will reset the object if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSpec</td><td>File spec of the local or remote file to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file is probably a VRS file, false otherwise (or if no file is found). </dd></dl>

</div>
</div>
<a id="a12b4fb530ccc1076a1a342afdea7d6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b4fb530ccc1076a1a342afdea7d6f0">&#9670;&nbsp;</a></span>isVrsFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::isVrsFile </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a file is most probably a VRS file by checking its header for VRS file's format magic numbers. Note: will reset the object if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Absolute or relative path of the file to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file is probably a VRS file, false otherwise (or if no file is found). </dd></dl>

</div>
</div>
<a id="a6fc3f6e58aba6d53e66dabeff41deb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc3f6e58aba6d53e66dabeff41deb8b">&#9670;&nbsp;</a></span>mightContainAudio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::mightContainAudio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell if a stream might contain some audio data (and probably will). This is a best guess effort, but it is still possible that no audio will actually be found! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one Data record <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> definition found in the stream has at least one audio content block, and the stream contains at least one data record. </dd></dl>

</div>
</div>
<a id="aa8ee554269ef5e43590070c735778fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ee554269ef5e43590070c735778fe0">&#9670;&nbsp;</a></span>mightContainImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::mightContainImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell if a stream might contain at least one image (and probably will). This is a best guess effort, but it is still possible that no images are actually found! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one Data record <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> definition found in the stream has at least one image content block, and the stream contains at least one data record. </dd></dl>

</div>
</div>
<a id="acef03ae06668f360654370a86a8461e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef03ae06668f360654370a86a8461e7">&#9670;&nbsp;</a></span>openFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::openFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoWriteFixedIndex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a record file. Use one <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> object per file you want to read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSpec</td><td>File spec of the local or remote file to check. </td></tr>
    <tr><td class="paramname">autoWriteFixedIndex</td><td>If the index was rebuilt, patch the original file in place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and you can read the file, or some non-zero error code, in which case, further read calls will fail. </dd></dl>

</div>
</div>
<a id="a4610b633871a23d53b95e50310d23ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4610b633871a23d53b95e50310d23ad1">&#9670;&nbsp;</a></span>openFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::openFile </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoWriteFixedIndex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a record file. Use one <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> object per file you want to read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Identifier of resource to open. Might be a file path, a URI, or a "JSON path". See <a class="el" href="classvrs_1_1_file_handler_factory.html#a8cc1b86d81f9a65dd1fc6a9caeaaa1e7">FileHandlerFactory::delegateOpen</a> for details. </td></tr>
    <tr><td class="paramname">autoWriteFixedIndex</td><td>If the index was rebuilt, patch the original file in place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and you can read the file, or some non-zero error code, in which case, further read calls will fail. </dd></dl>

</div>
</div>
<a id="a106707a35c6b20f348b004b9359a5db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106707a35c6b20f348b004b9359a5db7">&#9670;&nbsp;</a></span>prefetchRecordSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::prefetchRecordSequence </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearSequence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When streaming a VRS file from the cloud, it may be very beneficial to tell before hand which records will be read, in order, so that the data can be prefetched optimally. Note the only some FileHandlers implement this, others will just ignore the request, which is always safe to make. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">records</td><td>a sequence of records in the exact order they will be read. It's ok to skip one or more records, but:<ul>
<li>don't try to read "past" records, or you'll confuse the caching strategy, possibly leading to much worse performance.</li>
<li>if you read a single record out of the sequence, the prefetch list will be cleared. You may call this method as often as you like, and any previous read sequence will be cleared, but whatever is already in the cache will remain. </li>
</ul>
</td></tr>
    <tr><td class="paramname">clearSequence</td><td>Flag on whether to cancel any pre-existing custom read sequence upon caching starts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file handler backend supports this request, false if it was ignored. </dd></dl>

</div>
</div>
<a id="a09e29787a837db9844b460fb1aa38eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e29787a837db9844b460fb1aa38eca">&#9670;&nbsp;</a></span>purgeFileCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::purgeFileCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the underlying file handler caches data on reads, purge its caches to free memory. Sets the caching strategy to Passive, and clears any pending read sequence. </p><dl class="section return"><dt>Returns</dt><dd>True if the caches were purged, false if they weren't for some reason. Note: this is a best effort. If transactions are pending, their cache blocks won't be cleared. </dd></dl>

</div>
</div>
<a id="a051665b6f64f0b0c33b806b157a3c103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051665b6f64f0b0c33b806b157a3c103">&#9670;&nbsp;</a></span>readAllRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::readAllRecords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all the records of an open file. Call <a class="el" href="classvrs_1_1_record_file_reader.html#a0ffa8fc45e16e26dc2cac89d53089313">closeFile()</a> when you're done. Guaranties that records are read sorted by timestamp. </p><dl class="section return"><dt>Returns</dt><dd>0 if all records were read successfully, some other value otherwise. </dd></dl>

</div>
</div>
<a id="a7851f34655359f9a6b202c5c336c091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7851f34655359f9a6b202c5c336c091d">&#9670;&nbsp;</a></span>readFirstConfigurationRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::readFirstConfigurationRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function: Read a stream's first configuration record. This might be necessary to properly read records containing image or audio blocks, if their configuration is defined in a configuration record using datalayout conventions. Notes:</p><ul>
<li>a <a class="el" href="classvrs_1_1_record_format_stream_player.html" title="Specialized StreamPlayer designed to handle records which format is managed by RecordFormat,...">RecordFormatStreamPlayer</a> must be attached to the reader prior to making this call, so it can find the <a class="el" href="classvrs_1_1_record_format.html" title="Description of the format of a VRS record as a succession of typed blocks of content.">RecordFormat</a> and <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a> definitions.</li>
<li>if you provide a stream player, the caching happens in that stream player only.</li>
<li>if the stream contains more than one configuration record, the first configuration record probably won't be right for all the data records. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> of the record stream to consider. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td>(optional): provide a streamPlayer that will receive the records. If provided and a stream player was previously registered to receive records for that stream, only the provided stream player will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a config record was read for the given stream. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a61455e4da3366017413571d246a37eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61455e4da3366017413571d246a37eea">&#9670;&nbsp;</a></span>readFirstConfigurationRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::readFirstConfigurationRecords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function: Read every stream's first configuration record. See <a class="el" href="classvrs_1_1_record_file_reader.html#a7851f34655359f9a6b202c5c336c091d">readFirstConfigurationRecord()</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamPlayer</td><td>(optional): provide a stream player that will receive the records. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a config record was read for the given stream. </dd></dl>

</div>
</div>
<a id="acf76f4ffb73ac339bec3c09480d00111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf76f4ffb73ac339bec3c09480d00111">&#9670;&nbsp;</a></span>readFirstConfigurationRecordsForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::readFirstConfigurationRecordsForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#ae6fdfd6738201eddee4597c27fe31ac5">RecordableTypeId</a>&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function: Read the first configuration record of all the streams of a particular recordable type. See <a class="el" href="classvrs_1_1_record_file_reader.html#a7851f34655359f9a6b202c5c336c091d">readFirstConfigurationRecord()</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>The RecordableTypeId of the type of device to look for. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td>(optional): provide a stream player that will receive the records. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a configuration record was properly read for each matching stream. </dd></dl>

</div>
</div>
<a id="a87b4f29ef5a0a472641a9319378f132a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b4f29ef5a0a472641a9319378f132a">&#9670;&nbsp;</a></span>readRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::readRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>recordInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a file's record. Preferred way to read records. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordInfo</td><td>RecordInfo reference of the record to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a non-zero error code. If there is no <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> hooked up for the stream, no read operation is done and 0 is returned. </dd></dl>

</div>
</div>
<a id="a7ad6cc15c4624918e05eb728d3eb78f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad6cc15c4624918e05eb728d3eb78f1">&#9670;&nbsp;</a></span>readRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::readRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_index_record_1_1_record_info.html">IndexRecord::RecordInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>recordInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal: Read a record using a specific stream player. Prefer using setStreamPlayer and the single parameter version of <a class="el" href="classvrs_1_1_record_file_reader.html#a87b4f29ef5a0a472641a9319378f132a">readRecord()</a>. Avoid calling directly, as it won't work as expected unless the player was properly setup for decoding the stream before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordInfo</td><td>RecordInfo reference of the record to read. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td><a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> object to use for this operation only. The default stream player that might have been setup using <a class="el" href="classvrs_1_1_record_file_reader.html#a0697eaae250d06338ef03a53916ea23d">setStreamPlayer()</a> will not receive any callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or if streamPlayer is null, or a non-zero error code. </dd></dl>

</div>
</div>
<a id="a9ea8aa1242da01d7c84ebd7a5f6f52ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea8aa1242da01d7c84ebd7a5f6f52ae">&#9670;&nbsp;</a></span>setCachingStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vrs::RecordFileReader::setCachingStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevrs.html#acb1b4358038394407db2b2dc6200afae">CachingStrategy</a>&#160;</td>
          <td class="paramname"><em>cachingStrategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set &amp; get the current file handler's Caching strategy. This should be called <em>after</em> opening the file, as open might replace the file handler. </p>

</div>
</div>
<a id="abdc88304db2863c0ee09294e91c187dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc88304db2863c0ee09294e91c187dd">&#9670;&nbsp;</a></span>setFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileReader::setFileHandler </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classvrs_1_1_file_handler.html">FileHandler</a> &gt;&#160;</td>
          <td class="paramname"><em>fileHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Public yet methods that public API users should probably avoid, because there are better ways to get the same results. Maybe these are useful only for testing or for VRS' internal needs. Provide a different file handler, maybe to stream files off a network storage. By default, <a class="el" href="classvrs_1_1_record_file_reader.html" title="The class to read VRS files.">RecordFileReader</a> uses <a class="el" href="classvrs_1_1_disk_file.html" title="FileHandler implementation for disk files, with chunked file support.">DiskFile</a> to read/write files from/to a local disk. Prefer using URIs or <a class="el" href="structvrs_1_1_file_spec.html" title="Generalized file descriptor class, allowing the efficient representation of complex file objects,...">FileSpec</a> objects to specify a custom <a class="el" href="classvrs_1_1_file_handler.html" title="Class to abstract VRS file system operations, to enable support for alternate storage methods,...">FileHandler</a> when opening a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileHandler</td><td>File handler to access files using a different method than the default <a class="el" href="classvrs_1_1_disk_file.html" title="FileHandler implementation for disk files, with chunked file support.">DiskFile</a>, for instance, to directly access files off a network location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a424ad10de5e63536f7f84338f76b08e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424ad10de5e63536f7f84338f76b08e6">&#9670;&nbsp;</a></span>setOpenProgressLogger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileReader::setOpenProgressLogger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_progress_logger.html">ProgressLogger</a> *&#160;</td>
          <td class="paramname"><em>progressLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Option to control logging when opening a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progressLogger</td><td>a logger implementation, or nullptr, to disable logging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0697eaae250d06338ef03a53916ea23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0697eaae250d06338ef03a53916ea23d">&#9670;&nbsp;</a></span>setStreamPlayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vrs::RecordFileReader::setStreamPlayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_id.html">StreamId</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvrs_1_1_stream_player.html">StreamPlayer</a> *&#160;</td>
          <td class="paramname"><em>streamPlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hook a stream player to a specific stream after opening a file and before reading records. The file player does <em>not</em> take ownership of the <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a>. Using the same <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> instance for multiple streams is supported. So the caller is responsible for deleting the <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> objects after the file is read. Disconnect the <a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> by passing a nullptr for the stream id. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td><a class="el" href="classvrs_1_1_stream_id.html" title="VRS stream identifier class.">StreamId</a> to hook the stream player to. </td></tr>
    <tr><td class="paramname">streamPlayer</td><td><a class="el" href="classvrs_1_1_stream_player.html" title="Class designed to receive record data when reading a VRS file.">StreamPlayer</a> to attach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39729fdb368d109746548f815bfc0184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39729fdb368d109746548f815bfc0184">&#9670;&nbsp;</a></span>vrsFilePathToFileSpec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vrs::RecordFileReader::vrsFilePathToFileSpec </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvrs_1_1_file_spec.html">FileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>outFileSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkLocalFile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a path to a <a class="el" href="structvrs_1_1_file_spec.html" title="Generalized file descriptor class, allowing the efficient representation of complex file objects,...">FileSpec</a>, including resolution of local chunked files </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>a local file path, a URI, or a file spec in json format. </td></tr>
    <tr><td class="paramname">outFileSpec</td><td>on exit and on success, set to the resulting file spec. </td></tr>
    <tr><td class="paramname">checkLocalFile</td><td>only resolve links and look for additional chunks after validating that the local file is a VRS file, by reading the file's header and checking VRS signatures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code, 0 meaning success. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_record_file_reader_8h_source.html">RecordFileReader.h</a></li>
<li>vrs/RecordFileReader.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

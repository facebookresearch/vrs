"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[503],{3905:(e,a,t)=>{t.r(a),t.d(a,{MDXContext:()=>s,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>c,withMDXComponents:()=>m});var n=t(67294);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(){return i=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},i.apply(this,arguments)}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function d(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=n.createContext({}),m=function(e){return function(a){var t=c(a.components);return n.createElement(e,i({},a,{components:t}))}},c=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):d(d({},a),e)),t},p=function(e){var a=c(e.components);return n.createElement(s.Provider,{value:a},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},y=n.forwardRef((function(e,a){var t=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=c(t),p=o,u=m["".concat(r,".").concat(p)]||m[p]||h[p]||i;return t?n.createElement(u,d(d({ref:a},s),{},{components:t})):n.createElement(u,d({ref:a},s))}));function f(e,a){var t=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=y;var d={};for(var l in a)hasOwnProperty.call(a,l)&&(d[l]=a[l]);d.originalType=e,d[u]="string"==typeof e?e:o,r[1]=d;for(var s=2;s<i;s++)r[s]=t[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}y.displayName="MDXCreateElement"},85162:(e,a,t)=>{t.r(a),t.d(a,{default:()=>r});var n=t(67294),o=t(86010);const i={tabItem:"tabItem_Ymn6"};function r(e){let{children:a,hidden:t,className:r}=e;return n.createElement("div",{role:"tabpanel",className:(0,o.default)(i.tabItem,r),hidden:t},a)}},65488:(e,a,t)=>{t.r(a),t.d(a,{default:()=>p});var n=t(87462),o=t(67294),i=t(86010),r=t(72389),d=t(67392),l=t(7094),s=t(12466);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function c(e){const{lazy:a,block:t,defaultValue:r,values:c,groupId:p,className:u}=e,h=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),y=c??h.map((e=>{let{props:{value:a,label:t,attributes:n}}=e;return{value:a,label:t,attributes:n}})),f=(0,d.l)(y,((e,a)=>e.value===a.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const x=null===r?r:r??h.find((e=>e.props.default))?.props.value??h[0].props.value;if(null!==x&&!y.some((e=>e.value===x)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${x}" but none of its children has the corresponding value. Available values are: ${y.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:g,setTabGroupChoices:b}=(0,l.U)(),[N,v]=(0,o.useState)(x),C=[],{blockElementScrollPositionUntilNextRender:w}=(0,s.o5)();if(null!=p){const e=g[p];null!=e&&e!==N&&y.some((a=>a.value===e))&&v(e)}const D=e=>{const a=e.currentTarget,t=C.indexOf(a),n=y[t].value;n!==N&&(w(a),v(n),null!=p&&b(p,String(n)))},k=e=>{let a=null;switch(e.key){case"ArrowRight":{const t=C.indexOf(e.currentTarget)+1;a=C[t]??C[0];break}case"ArrowLeft":{const t=C.indexOf(e.currentTarget)-1;a=C[t]??C[C.length-1];break}}a?.focus()};return o.createElement("div",{className:(0,i.default)("tabs-container",m.tabList)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.default)("tabs",{"tabs--block":t},u)},y.map((e=>{let{value:a,label:t,attributes:r}=e;return o.createElement("li",(0,n.Z)({role:"tab",tabIndex:N===a?0:-1,"aria-selected":N===a,key:a,ref:e=>C.push(e),onKeyDown:k,onFocus:D,onClick:D},r,{className:(0,i.default)("tabs__item",m.tabItem,r?.className,{"tabs__item--active":N===a})}),t??a)}))),a?(0,o.cloneElement)(h.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},h.map(((e,a)=>(0,o.cloneElement)(e,{key:a,hidden:e.props.value!==N})))))}function p(e){const a=(0,r.default)();return o.createElement(c,(0,n.Z)({key:String(a)},e))}},53182:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>c});var n=t(87462),o=(t(67294),t(3905)),i=t(65488),r=t(85162);const d={sidebar_position:6,title:"Record Format"},l=void 0,s={unversionedId:"RecordFormat",id:"RecordFormat",title:"Record Format",description:"Record Format Version",source:"@site/docs/RecordFormat.md",sourceDirName:".",slug:"/RecordFormat",permalink:"/vrs/docs/RecordFormat",draft:!1,editUrl:"https://github.com/facebookresearch/vrs/edit/main/website/docs/RecordFormat.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Record Format"},sidebar:"tutorialSidebar",previous:{title:"File Playback",permalink:"/vrs/docs/FilePlayback"},next:{title:"Image Support",permalink:"/vrs/docs/ImageSupport"}},m={},c=[{value:"Record Format Version",id:"record-format-version",level:2},{value:"<code>RecordFormat</code>",id:"recordformat",level:2},{value:"<code>ContentBlock</code>",id:"contentblock",level:3},{value:"Datalayout Content Blocks",id:"datalayout-content-blocks",level:3},{value:"<code>DataLayout</code> Format Resilience",id:"datalayout-format-resilience",level:3},{value:"<code>DataLayout</code> Examples",id:"datalayout-examples",level:3},{value:"Image, Audio, and Custom Content Blocks",id:"image-audio-and-custom-content-blocks",level:3},{value:"Registering your <code>RecordFormat</code> and <code>DataLayout</code> Definitions",id:"registering-your-recordformat-and-datalayout-definitions",level:2},{value:"Reading Records",id:"reading-records",level:2},{value:"Reading a Datalayout",id:"reading-a-datalayout",level:3},{value:"Datalayout Conventions",id:"datalayout-conventions",level:3},{value:"Mistakes to Avoid",id:"mistakes-to-avoid",level:2},{value:"Additional samples",id:"additional-samples",level:2},{value:"Why Reinvent the Wheel?",id:"why-reinvent-the-wheel",level:2},{value:"What is <code>DataLayout</code> \u201creally\u201d good at?",id:"what-is-datalayout-really-good-at",level:3},{value:"What is <code>DataLayout</code> not good at?",id:"what-is-datalayout-not-good-at",level:3}],p={toc:c},u="wrapper";function h(e){let{components:a,...t}=e;return(0,o.mdx)(u,(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,o.mdx)("h2",{id:"record-format-version"},"Record Format Version"),(0,o.mdx)("p",null,"Each record in a stream has its own format version number, which is a ",(0,o.mdx)("inlineCode",{parentName:"p"},"uint32_t")," value. However, because records belong to a single stream and each has a record type (Configuration, State, or Data), format version numbers are only meaningful within that stream and for that record type. You do not need to worry about format version collisions between streams and record types."),(0,o.mdx)("p",null,"Before ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," was available, record format versioning was critical, because it was the only information about how the record's data was formatted. You were responsible for interpreting every byte of data. You also had to manually manage all data format changes. Since record data formats were not self-described within the file, each time you needed to add, remove, or change a field, you had to change the format version, and handle a growing number of format versions explicitly in the code. This was unmanageable."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," were designed to solve this challenge, and since, record format version changes are very rarely needed. ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," abstracts the description of a record as a succession of typed blocks, embedding descriptions, including ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions, in the stream itself. VRS uses these embedded descriptions to interpret records, calculate content block boundaries using DataLayout Conventions, and pass parsed content blocks to callbacks."),(0,o.mdx)("h2",{id:"recordformat"},(0,o.mdx)("inlineCode",{parentName:"h2"},"RecordFormat")),(0,o.mdx)("p",null,"Use ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," to describe records as a sequence of typed content blocks. This structure applies to configuration, state, and data records alike."),(0,o.mdx)("h3",{id:"contentblock"},(0,o.mdx)("inlineCode",{parentName:"h3"},"ContentBlock")),(0,o.mdx)("p",null,"The content block types are: ",(0,o.mdx)("inlineCode",{parentName:"p"},"image"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"audio"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"datalayout"),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},"custom"),". VRS saves ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," definitions as a string that is generated and parsed for you, but which was designed to be very expressive and compact. Content block descriptions may contain additional information, specific to the content type. Here are some examples of single content block ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," definitions:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image/png")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image/raw")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image/raw/640x480/pixel=grb8")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image/raw/640x480/pixel=grey8/stride=648")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image/video")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"image/video/codec=H.264")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"audio")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"audio/pcm")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"audio/pcm/uint24be/rate=32000/channels=1")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout/size=48")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"custom")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"custom/size=160"))),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"image")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"audio")," content blocks are pretty much what you expect when you read their text description. ",(0,o.mdx)("inlineCode",{parentName:"p"},"datalayout")," blocks contain structured metadata information. ",(0,o.mdx)("inlineCode",{parentName:"p"},"custom")," content blocks are blocks of raw data, which format is known only to you, and which you are responsible for interpreting."),(0,o.mdx)("p",null,"You can assemble as many content blocks as you like in a record, which might look like this:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout+image/raw")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout+datalayout+audio/pcm"))),(0,o.mdx)("p",null,"Again, these text descriptions are generated and parsed for you, so you don't need to worry about their syntax."),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," descriptions of a stream's records are stored in the VRS tags of the stream. You will only see these text descriptions when you are using tools to dump a stream's VRS tags. VRS tags are associated with each stream for VRS internal usage, and are kept separate from the user stream tags."),(0,o.mdx)("p",null,"In practice, the majority of the records used in VRS today use one of the following record formats:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout"),": for records containing a single metadata content block, which is typical of configuration records."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout+image/raw"),": for records containing some image specific metadata and the raw pixel data of an image."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout+image/jpg")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"datalayout+image/video"),": for records containing some image specific metadata and compressed image data.")),(0,o.mdx)("h3",{id:"datalayout-content-blocks"},"Datalayout Content Blocks"),(0,o.mdx)("p",null,"Datalayout content blocks, commonly referred to as datalayouts, are ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," objects that hold containers of ",(0,o.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Passive_data_structure"},"POD values")," and strings. If you have never seen a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definition, look at the ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyDataLayout")," definition in the ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("inlineCode",{parentName:"strong"},"DataLayout")," Examples")," section below."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," are ",(0,o.mdx)("inlineCode",{parentName:"p"},"struct")," objects containing ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceXXX")," member variables, that each have their own text label. The supported ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceXXX")," types are:"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceValue"),", a single value of POD type ",(0,o.mdx)("inlineCode",{parentName:"p"},"T"),":"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"template <class T> DataPieceValue<T>;")),(0,o.mdx)("li",{parentName:"ul"},"Example: ",(0,o.mdx)("inlineCode",{parentName:"li"},'DataPieceValue<int32_t> exposure{"exposure"};'))),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceEnum"),", a single value of enum ",(0,o.mdx)("inlineCode",{parentName:"p"},"ENUM_TYPE")," with the underlying type ",(0,o.mdx)("inlineCode",{parentName:"p"},"POD_TYPE"),":"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"template <typename ENUM_TYPE, typename POD_TYPE> DataPieceEnum<ENUM_TYPE, POD_TYPE>")),(0,o.mdx)("li",{parentName:"ul"},"Example: ",(0,o.mdx)("inlineCode",{parentName:"li"},'DataPieceEnum<PixelFormat, uint32_t> pixelFormat{"pixel_format"};'))),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceArray"),", a fixed size array of values of POD type ",(0,o.mdx)("inlineCode",{parentName:"p"},"T"),":"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"template <class T> DataPieceArray<T>;")),(0,o.mdx)("li",{parentName:"ul"},"Example: ",(0,o.mdx)("inlineCode",{parentName:"li"},'DataPieceArray<float> calibration{"calibration", 25};'))),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceVector"),", a vector of values of type ",(0,o.mdx)("inlineCode",{parentName:"p"},"T"),", which size may change for each record:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"template <class T> DataPieceVector<T>")),(0,o.mdx)("li",{parentName:"ul"},"Example: ",(0,o.mdx)("inlineCode",{parentName:"li"},'DataPieceVector<int8_t> udpPayload{"udp_payload"};'))),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceStringMap"),", the equivalent of ",(0,o.mdx)("inlineCode",{parentName:"p"},"std::map<std::string, T>"),":"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"template <class T> DataPieceStringMap<T>")),(0,o.mdx)("li",{parentName:"ul"},"Example: ",(0,o.mdx)("inlineCode",{parentName:"li"},'DataPieceStringMap<Point2Di> labelledPoints{"labelled_points"};'))),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceString"),", a ",(0,o.mdx)("inlineCode",{parentName:"p"},"std::string")," value:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataPieceString")),(0,o.mdx)("li",{parentName:"ul"},"Example: ",(0,o.mdx)("inlineCode",{parentName:"li"},'DataPieceString message{"message"};'))),(0,o.mdx)("p",null,"Template class ",(0,o.mdx)("inlineCode",{parentName:"p"},"T")," can be any of these built-in POD types:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Boolean (use ",(0,o.mdx)("inlineCode",{parentName:"li"},"vrs::Bool"),")"),(0,o.mdx)("li",{parentName:"ul"},"Signed or unsigned integer (8, 16, 32, or 64 bits)"),(0,o.mdx)("li",{parentName:"ul"},"32 bit float"),(0,o.mdx)("li",{parentName:"ul"},"64 bit double")),(0,o.mdx)("p",null,"Template class ",(0,o.mdx)("inlineCode",{parentName:"p"},"T")," can also be any of these vector types (using ",(0,o.mdx)("inlineCode",{parentName:"p"},"float"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"double")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"int32_t")," for coordinates):"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"2, 3, or 4D points"),(0,o.mdx)("li",{parentName:"ul"},"3 or 4D matrices")),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"std::string")," can be used with ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceVector<T>")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceStringMap<T>"),", but cannot be used with the other template types."),(0,o.mdx)("admonition",{type:"note"},(0,o.mdx)("p",{parentName:"admonition"},"Always use ",(0,o.mdx)("inlineCode",{parentName:"p"},"<cstdint>")," definitions. Never use platform dependent types like ",(0,o.mdx)("inlineCode",{parentName:"p"},"short"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"int"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"long"),", or ",(0,o.mdx)("inlineCode",{parentName:"p"},"size_t"),". The actual size will vary depending on the architecture or the compiler configuration.")),(0,o.mdx)("h3",{id:"datalayout-format-resilience"},(0,o.mdx)("inlineCode",{parentName:"h3"},"DataLayout")," Format Resilience"),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," objects are structs, so it is very simple to add, remove, and reorder ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceXXX")," fields. But datalayouts definitions are very resilient to definition changes, so that even when making such changes, newer code can read older files, and older code can read newer files."),(0,o.mdx)("p",null,"Datalayouts format resilience is possible, because each ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceXXX")," object is identified by a unique combination of these elements:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"DataPiece")," type"),(0,o.mdx)("li",{parentName:"ul"},"Label"),(0,o.mdx)("li",{parentName:"ul"},"Template class ",(0,o.mdx)("inlineCode",{parentName:"li"},"T"),", except for ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataPieceString"))),(0,o.mdx)("p",null,"This unique combination is critical to providing datalayout forward/backward compatibility, without worrying about the actual placement of the data. If you change the type or the label of a field, you will change its signature, and it won't be recognized in older files. The modified field will look like a new field, and the data from older files will no longer be accessible using the updated definition."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions do not support other types of containers or nested containers, because that would make it impossible to guarantee forward/backward compatibility. However, it is possible to use repeated and nested structs, using ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayoutStruct"),", as shown in the second example below."),(0,o.mdx)("p",null,"In some situations, such as when you need to save space, it is desirable to store some fields only in some conditions. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"OptionalDataPieces")," template makes it easy to specify and control if a group of fields should be saved or not, but the choice must be made once for the whole file."),(0,o.mdx)("p",null,"If you need more freedom, you can use a free form container such as JSON in a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceString")," field. If you have binary data, you can use a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceVector<uint8_t>")," field."),(0,o.mdx)("p",null,"We recommend that you use lowercase ",(0,o.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Snake_case"},"snake_case")," as your naming convention for labels. This will limit problems if these names are used as keys in a Python dictionary, in particular when using ",(0,o.mdx)("strong",{parentName:"p"},"pyvrs")," to create or read datalayouts."),(0,o.mdx)("h3",{id:"datalayout-examples"},(0,o.mdx)("inlineCode",{parentName:"h3"},"DataLayout")," Examples"),(0,o.mdx)(i.default,{mdxType:"Tabs"},(0,o.mdx)(r.default,{value:"example_1",label:"Example 1: standard case",default:!0,mdxType:"TabItem"},(0,o.mdx)("p",null,"Here is a sample ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definition:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},'struct MyDataLayout : public AutoDataLayout {\n\n  // Fixed size pieces: std::string is NOT supported as a template type.\n  DataPieceValue<double> exposureTime{"exposure_time"};\n  DataPieceValue<uint64_t> frameCounter{"frame_counter"};\n  DataPieceValue<float> cameraTemperature{"camera_temperature"};\n  DataPieceEnum<PixelFormat, uint32_t> pixelFormat{"pixel_format"};\n  DataPieceArray<Matrix3Dd> arrayOfMatrix3Dd{"matrices", 3}; // array size = 3\n\n  // Variable size pieces: std::string is supported as a template type.\n  DataPieceVector<Point3Df> vectorOfPoint3Df{"points"};\n  DataPieceVector<string> vectorOfString{"strings"};\n  DataPieceString description{"description"}; // Any string. Could be json.\n  DataPieceStringMap<Matrix4Dd> aStringMatrixMap{"some_string_to_matrix4d_map"};\n  DataPieceStringMap<string> aStringStringMap{"some_string_to_string_map"};\n\n  AutoDataLayoutEnd endLayout;\n};\n')),(0,o.mdx)("p",null,"Notice that this struct must derive from ",(0,o.mdx)("inlineCode",{parentName:"p"},"AutoDataLayout"),", and finish with an ",(0,o.mdx)("inlineCode",{parentName:"p"},"AutoDataLayoutEnd")," field. This is required to make the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," magic happen. Under the hood, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceXXX")," constructors will register themselves to the enclosing ",(0,o.mdx)("inlineCode",{parentName:"p"},"AutoDataLayout"),". As we will generally only create a single ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," instance, the overhead is minimal and does not matter. Also, notice that each field has a unique label.")),(0,o.mdx)(r.default,{value:"example_2",label:"Example 2: nested definitions",mdxType:"TabItem"},(0,o.mdx)("admonition",{type:"note"},(0,o.mdx)("p",{parentName:"admonition"},"This option is not commonly needed.")),(0,o.mdx)("p",null,"It is possible to define structs that can be nested in a DataLayout definition. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},'struct Pose : public DataLayoutStruct {\n  DATA_LAYOUT_STRUCT(Pose) // repeat the name of the struct\n  DataPieceVector<vrs::Matrix4Dd> orientation{"orientation"};\n  DataPieceVector<vrs::Matrix3Dd> translation{"translation"};\n};\n\nstruct MyDataLayout : public AutoDataLayout {\n  Pose leftHand{"left_hand"};\n  Pose rightHand{"right_hand"};\n  AutoDataLayoutEnd endLayout;\n};\n')),(0,o.mdx)("p",null,"The name of each field in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayoutStruct")," is prepended by the name of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayoutStruct")," itself, with a \u2018",(0,o.mdx)("inlineCode",{parentName:"p"},"/"),"\u2019 added to make it look like a path. This also makes it unique at the datalayout level."),(0,o.mdx)("p",null,"Effectively, the declaration above creates the same ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPiece")," fields and the same datalayout definition as the datalayout definition below, which requires different member variable names to avoid conflicts at the struct level:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},'struct MyDataLayout: public AutoDataLayout {\n  DataPieceVector<vrs::Matrix4Dd> leftHandOrientation{"left_hand/orientation"};\n  DataPieceVector<vrs::Matrix3Dd> leftHandTranslation{"left_hand/translation"};\n  DataPieceVector<vrs::Matrix4Dd> rightHandOrientation{"right_hand/orientation"};\n  DataPieceVector<vrs::Matrix3Dd> rightHandTranslation{"right_hand/translation"};\n  AutoDataLayoutEnd endLayout;\n};\n')),(0,o.mdx)("p",null,"It is possible to nest a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayoutStruct")," within other ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayoutStruct")," definitions as often as makes sense. The resulting ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPiece")," fields will have labels similarly constructed, with deeper nesting. However, it is not possible to use ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayoutStruct")," definitions in template containers.")),(0,o.mdx)(r.default,{value:"example_3",label:"Example 3: optional definitions",mdxType:"TabItem"},(0,o.mdx)("admonition",{type:"note"},(0,o.mdx)("p",{parentName:"admonition"},"This option is only very rarely needed.")),(0,o.mdx)("p",null,"You can define fields that are used only when some recording conditions are met, or with some devices. This helps to save space, and makes the records less ambiguous, since they will only show these fields if they were actually used while recording."),(0,o.mdx)("p",null,"For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},'/// Sample sensor not always available on all devices\nstruct TemperatureData {\n  DataPieceValue<float> cameraTemperature{"camera_temperature"};\n};\n\nstruct MyDataLayout : public AutoDataLayout {\n  MyDataLayout(bool allocateOptionalFields = false)\n      : optionalFields(allocateOptionalFields) {}\n\n  DataPieceValue<double> exposureTime{"exposure_time"};\n  DataPieceValue<uint64_t> frameCounter{"frame_counter"};\n\n  const OptionalDataPieces<TemperatureData> optionalTemperature;\n\n  AutoDataLayoutEnd endLayout;\n};\n')),(0,o.mdx)("p",null,"When recording a file, you need to decide upfront, at runtime, whether the optional fields are needed for this recording, and then select the appropriate constructor. This is because the optional fields must be allocated during the datalayout construction."),(0,o.mdx)("p",null,"When reading a file, you can try to use the appropriate constructor, or you can always include the optional fields and test if data is present by checking the ",(0,o.mdx)("inlineCode",{parentName:"p"},"isAvailable()")," method for each optional field."))),(0,o.mdx)("h3",{id:"image-audio-and-custom-content-blocks"},"Image, Audio, and Custom Content Blocks"),(0,o.mdx)("p",null,"Image, audio, and custom content blocks directly contain their payload, and no additional metadata. In some cases, such as for ",(0,o.mdx)("inlineCode",{parentName:"p"},"image/jpg")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"image/png")," data, no other information is needed to interpret the data. In other cases, such with ",(0,o.mdx)("inlineCode",{parentName:"p"},"images/raw")," images, which are raw pixel buffers, image dimensions, pixel format and possibly stride information are required to know how to interpret the image content block. If that information never changes, it may provided directly in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," definition, otherwise, it might need to be provided in a configuration record, or in the data records themselves, using what we call the Datalayout Conventions."),(0,o.mdx)(i.default,{mdxType:"Tabs"},(0,o.mdx)(r.default,{value:"example_1",label:"Image Content Block Examples",default:!0,mdxType:"TabItem"},(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"ContentBlock(ContentType::IMAGE); // Image content block, without any detail\nContentBlock(ContentType::JPG); // A jpeg image\nContentBlock(ContentType::JPG, 640, 480); // A 640x480 jpeg image\nContentBlock(ContentType::RAW); // A raw pixel buffer image\nContentBlock(PixelFormat::GREY8, 640, 480); // A raw pixel buffer image, 640x480 large, with 8 bit greyscale pixels.\n")),(0,o.mdx)("p",null,"Please refer to the Image Support section for more details on how to manage image content blocks.")),(0,o.mdx)(r.default,{value:"example_2",label:"Audio Content Block Examples",mdxType:"TabItem"},(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"ContentBlock(ContentType::AUDIO); // Audio content block, without any detail\nContentBlock(AudioFormat::PCM); // PCM audio data\nContentBlock(AudioSampleFormat::S16_LE, 2, 48000); // PCM audio data, int16 little endian samples, 2 channels, 48 kHz\n")),(0,o.mdx)("p",null,"Audio blocks are analog to image blocks, and are handled the same way.")),(0,o.mdx)(r.default,{value:"example_3",label:"Custom Content Block Examples",mdxType:"TabItem"},(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"ContentBlock(ContentType::CUSTOM); // No details at all\nContentBlock(ContentType::CUSTOM, 256); // 256 byte custom content block\n")),(0,o.mdx)("p",null,"If they are not the last content block in the record, custom content blocks may need to have their size provided using the Datalayout conventions."))),(0,o.mdx)("h2",{id:"registering-your-recordformat-and-datalayout-definitions"},"Registering your ",(0,o.mdx)("inlineCode",{parentName:"h2"},"RecordFormat")," and ",(0,o.mdx)("inlineCode",{parentName:"h2"},"DataLayout")," Definitions"),(0,o.mdx)("p",null,"When you create a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Recordable")," object to record a stream, you need to register the ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," for its records. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Assuming your recordable has a member variable declared like so:\nMyDataLayout config_;\n\n// in your Recordable's constructor, call:\naddRecordFormat(\n  Record::Type::CONFIGURATION, // record types are defined separately\n  kConfigurationRecordFormatVersion, // only change when the RecordFormat changes\n  config_.getContentBlock(), // RecordFormat definition: a single datalayout block\n  {&config_}); // DataLayout definition for the first block\n")),(0,o.mdx)("p",null,"Here is an example of a record that contains a datalayout block, followed by an image block (\u201c",(0,o.mdx)("inlineCode",{parentName:"p"},"datalayout+image/raw"),"\u201d):"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Assuming your recordable has a member variable declared like so:\nMyDataLayoutForDataRecords data_;\n\n// in your Recordable's constructor, call:\naddRecordFormat(\n  Record::Type::DATA, // record types are defined separately\n  kDataRecordFormatVersion, // only change when RecordFormat changes\n  data_.getContentBlock() + ContentBlock(ImageFormat::RAW), // RecordFormat definition\n  {&data_}); // DataLayout definition for the first block, nothing for the image block\n")),(0,o.mdx)("p",null,"Each record has a record format version number. Each ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat"),", its record format version number, and its ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions are tied to a particular stream. Therefore, it is possible to have records using different ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat"),"/",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions within a particular stream, by using different record format version numbers."),(0,o.mdx)("admonition",{type:"note"},(0,o.mdx)("p",{parentName:"admonition"},(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions fully describe what is stored in a datalayout content block. So, you can freely change ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions without changing the record format version.")),(0,o.mdx)("h2",{id:"reading-records"},"Reading Records"),(0,o.mdx)("p",null,"To read records described using ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," conventions, attach a ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormatStreamPlayer")," to your ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFileReader"),". Then, hook code to whichever of these virtual methods is appropriate for your records:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"onDataLayoutRead()")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"onImageRead()")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"onAudioRead()")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"onCustomBlockRead()"))),(0,o.mdx)("p",null,"You will get one callback per content block, until one of the callbacks returns ",(0,o.mdx)("inlineCode",{parentName:"p"},"false"),", signaling that the end of the record should not be decoded."),(0,o.mdx)("h3",{id:"reading-a-datalayout"},"Reading a Datalayout"),(0,o.mdx)("p",null,"When reading a ",(0,o.mdx)("inlineCode",{parentName:"p"},"datalayout")," content block, you will get an ",(0,o.mdx)("inlineCode",{parentName:"p"},"onDataLayoutRead")," callback in your ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormatStreamPlayer")," object, with the datalayout already loaded. In the ",(0,o.mdx)("inlineCode",{parentName:"p"},"onDataLayoutRead")," callback, you will want to handle records differently, depending on their record type."),(0,o.mdx)("p",null,"For each record type, you will have a specific ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definition, describing the latest version of the datalayout you are using. But you cannot know if that definition matches what was read, since the file could be using an older or newer version of the datalayout definition. Use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"getExpectedLayout<MyDataLayout>")," API to get a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," instance of the type your code is looking for. You can then access each of its fields safely, with the caveat that each field may or may not find actual data in the datalayout that was read from disk."),(0,o.mdx)("p",null,"Each data field is mapped according to its data type and label only. So, you do not need to worry whether fields have been added, removed, or moved. Mapping is cached per file/stream/type. So, after the first record is mapped, mapping is extremely cheap, and fields are read in constant time, no matter how complicated the datalayouts are."),(0,o.mdx)("admonition",{type:"tip"},(0,o.mdx)("p",{parentName:"admonition"},"When debugging, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout::printLayout(std::cout)")," to print the incoming datalayout. This will show the field names, their type, and their value, as they are in the record read.")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"class MyCameraStreamPlayer : public RecordFormatStreamPlayer {\nbool onDataLayoutRead(const CurrentRecord& record, size_t blockIndex, DataLayout& data) override {\n  switch (record.recordType) {\n    case Record::Type::CONFIGURATION: {\n      MyCameraConfigRecordDataLayout& myConfig =\n          getExpectedLayout<MyCameraConfigRecordDataLayout>(data, blockIndex);\n      // use the data...\n      myConfig.cameraRole.get(); // access the data...\n    } break;\n\n    case Record::Type::DATA: {\n      // Here are the fields written & expected in the latest version\n      MyCameraDataRecordDataLayout& myData =\n          getExpectedLayout<MyCameraDataRecordDataLayout>(data, blockIndex);\n      // use the data...\n      myData.cameraTemperature.get();\n\n      // Rare case: access field that were removed or renamed\n      // e.g., frame_counter's type was changed: fetch the old version if necessary\n      uint64_t frameCounter = 0;\n      if (myData.frameCounter.isAvailable()) {\n        frameCounter = myData.frameCounter.get();\n      } else {\n        // MyCameraLegacyFields contains removed fields definitions\n        MyCameraLegacyFields& legacyData =\n            getLegacyLayout<MyCameraLegacyFields>(data, blockIndex);\n        frameCounter = myConversionLogic(legacyData.frameCounter.get());\n      }\n    } break;\n\n    default:\n      assert(false); // should not happen, but you want to know if it does!\n      break;\n  }\n  return true; // read next content blocks, if any\n}\n")),(0,o.mdx)("h3",{id:"datalayout-conventions"},"Datalayout Conventions"),(0,o.mdx)("p",null,"Datalayout Conventions are a set of names and types that VRS uses to find missing ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," specifications, such as the resolution and pixel format, if they are missing in the definition of an ",(0,o.mdx)("inlineCode",{parentName:"p"},"\u201cimage/raw\u201d")," content block. Datalayout Conventions can also be used to specify the size of a content block when it is ambiguous. Refer to the source header ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebookresearch/vrs/blob/main/vrs/DataLayoutConventions.h"},(0,o.mdx)("inlineCode",{parentName:"a"},"<vrs/DataLayoutConventions.h>"))," to see the actual Datalayout Conventions."),(0,o.mdx)("p",null,"In the examples above, you can determine the size of the datalayout blocks by looking at the actual ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definition. However, that only works if only fixed type pieces are used. When only fixed type pieces are used, the datalayout size is constant no matter what the content is. Look again at the definition of ",(0,o.mdx)("inlineCode",{parentName:"p"},"MyDataLayout")," above to see the difference between fixed size pieces and variable size pieces."),(0,o.mdx)("p",null,"When only fixed size pieces are used, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"getContentBlock()")," API generates ",(0,o.mdx)("inlineCode",{parentName:"p"},'"datalayout/size=XXX"'),", with ",(0,o.mdx)("inlineCode",{parentName:"p"},"XXX")," being the number of bytes. If the datalayout contains any variable size pieces, the size of the datalayout can change from record to record, and the ",(0,o.mdx)("inlineCode",{parentName:"p"},"getContentBlock()")," API will return ",(0,o.mdx)("inlineCode",{parentName:"p"},'"datalayout"'),"."),(0,o.mdx)("p",null,"If any variable size pieces are present, the datalayout will include an index, which has a fixed size. The index's size depends only on the number of variable size pieces declared, not on their actual values. This index makes it possible for VRS to determine the overall size of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," in two successive reads. The first read includes the data for all the fixed size pieces and the index for the variable size pieces. The added sizes found in the variable size index tells the total size of the variable size pieces, which VRS can now read with a second file read call. Therefore, VRS can always read a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," block, because we can always determine its actual size."),(0,o.mdx)("p",null,"In the second ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," example above, we have a datalayout block followed by an image block (",(0,o.mdx)("inlineCode",{parentName:"p"},"\u201cdatalayout+image/raw\u201d"),"). Since the image block is the last content block of the record, and VRS knows the overall size of the record, and how to figure out the size of the datalayout, we can see that all the remaining bytes must belong to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"\u201cimage/raw\u201d")," block. However, this is not sufficient to interpret the image pixel data. This is when we need the Datalayout Conventions."),(0,o.mdx)("p",null,"When working with a device such as a camera, typically, during the hardware initialization/setup, before the data collection begins, the software stack will configure the camera to function in a particular mode, which includes parameters such as resolution, color mode, exposure mode, and frame rate. These parameters will never change unless the configuration of the camera is changed, which is extremely rare in practice. These parameters all belong to a configuration record and can easily be saved in a datalayout block."),(0,o.mdx)("p",null,"In a more advanced system, a camera\u2019s resolution and color mode may change for each frame, as when driven by a computer vision algorithm or some other heuristic. When you save only a sub-region of a whole image (the way Portal does when it tracks a target and crops the image received from the sensor), the crop size of the image might change in every frame. In such cases, the image parameters should not be placed in a configuration record. Those parameters should be specified in the datalayout block preceding the image block."),(0,o.mdx)("p",null,"VRS uses the following heuristics:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Search each datalayout block before the ambiguous block, in the same record, in reverse content block order. If the ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," is ",(0,o.mdx)("inlineCode",{parentName:"p"},"\u201cdatalayout+datalayout+image/raw+datalayout\u201d"),", to disambiguate the ",(0,o.mdx)("inlineCode",{parentName:"p"},"\u201cimage/raw\u201d")," block, VRS ignores the last datalayout block (because it comes after the image/raw block), and searches the second datalayout block first. If that is not enough, it then searches the first datalayout block.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"If the resolution and pixel format values cannot be found in the same record, VRS will search the last read configuration record in that stream."))),(0,o.mdx)("admonition",{type:"note"},(0,o.mdx)("p",{parentName:"admonition"},"This look-up uses cached data. The configuration record must have been read before the data record. Reading a record will not cause another record to be read implicitly.")),(0,o.mdx)("p",null,"Using cached data works because ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormatStreamPlayer")," caches the data of the last record of each type of record it has read."),(0,o.mdx)("p",null,"The Datalayout Conventions make ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormatStreamPlayer")," work very efficiently. For example, you get an ",(0,o.mdx)("inlineCode",{parentName:"p"},"onImageRead()")," callback, and the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ContentBlock")," object is fully fleshed out, with the resolution and pixel format, which might have been specified in a configuration record a long time ago."),(0,o.mdx)("p",null,"If VRS cannot determine, unambiguously, how the image block is formatted, it does not send an ",(0,o.mdx)("inlineCode",{parentName:"p"},"onImageRead()")," callback. It sends an ",(0,o.mdx)("inlineCode",{parentName:"p"},"onUnsupportedBlock()")," callback instead."),(0,o.mdx)("p",null,"Datalayout Conventions can also be used to specify the size of a content block coming right after a datalayout content block. Refer to ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebookresearch/vrs/blob/main/vrs/DataLayoutConventions.h"},(0,o.mdx)("inlineCode",{parentName:"a"},"<vrs/DataLayoutConventions.h>"))," for implementation details."),(0,o.mdx)("h2",{id:"mistakes-to-avoid"},"Mistakes to Avoid"),(0,o.mdx)("p",null,"While ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," are designed to resolve a large number of backward and forward compatibility issues, you still need to be aware of the following potential problems:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"Do not persist any raw ",(0,o.mdx)("inlineCode",{parentName:"strong"},"struct"),", always copy fields one by one.")," If you are receiving a data structure, such as data a C ",(0,o.mdx)("inlineCode",{parentName:"p"},"struct")," from a driver, you need to copy each field needed in that data structure into a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout"),", one by one, no matter how tedious. You will also have to adjust the fields in your ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," structure when the incoming ",(0,o.mdx)("inlineCode",{parentName:"p"},"struct")," changes. You might be tempted to save the whole memory block to your VRS records, to spare yourself the work. However, doing that would make your file format vulnerable to any changes made to the struct definition, which is controlled and updated by the maintainers of that data structure. It would make it extremely difficult to understand why data read from older files look corrupt, and even harder to be able to read those files. C/C++ ",(0,o.mdx)("inlineCode",{parentName:"p"},"struct"),"s do not have any data format introspection capability, and this is why VRS does not, and will not, support the use of any arbitrary ",(0,o.mdx)("inlineCode",{parentName:"p"},"<class T>")," in its template ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPiece")," containers. Doing so would be a massive design blunder. ",(0,o.mdx)("em",{parentName:"p"},"Writing the tedious code that copies each field, one by one, from a received data structure to a copycat ",(0,o.mdx)("inlineCode",{parentName:"em"},"DataLayout")," protects your data from unexpected data format changes, and will save you hours, maybe even days, of work and frustration."))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"Do not use ",(0,o.mdx)("inlineCode",{parentName:"strong"},"short"),", ",(0,o.mdx)("inlineCode",{parentName:"strong"},"int"),", or ",(0,o.mdx)("inlineCode",{parentName:"strong"},"size_t"))," directly in any ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPiece")," template, because their size is architecture and compiler dependent, and using them can result in files that cannot be read as expected if the reading code is compiled with different configuration settings than the writing code. You should always use fully sized types, such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"uint8_t")," instead. Do not use ",(0,o.mdx)("inlineCode",{parentName:"p"},"size_t")," either, because ",(0,o.mdx)("a",{parentName:"p",href:"https://stackoverflow.com/questions/918787/whats-sizeofsize-t-on-32-bit-vs-the-various-64-bit-data-models"},"its size is not dependable"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"Do not persist enums using ",(0,o.mdx)("inlineCode",{parentName:"strong"},"DataPieceValue<ENUM_TYPE>"))," because the type of the enum is captured in the file format (",(0,o.mdx)("inlineCode",{parentName:"p"},"int")," by default), and if the underlying type associated with the enum is ever changed, the data will no longer be accessible. Instead, use ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceEnum<ENUM_TYPE, T>"),", which captures the underlying type and performs casting. For the underlying type ",(0,o.mdx)("inlineCode",{parentName:"p"},"T"),", use a fixed-size integral type from ",(0,o.mdx)("inlineCode",{parentName:"p"},"<cstdint>"),", such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"int32_t")," rather than ambiguous types like ",(0,o.mdx)("inlineCode",{parentName:"p"},"int"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"Be very careful when persisting external enums")," when casting them as integers to store them, because you might not control external enum definitions. You should convert external enums to text or to your own version of these enums. If the definition of an external enum changes, the code will start to misinterpret data, and it will be very difficult to fix. If you convert enums to text or create your own enums, whose evolution you control, you will avoid difficult debugging issues. If you really want to persist enums by casting their numeric value, you should create a unit test that will break when the enum values change, or you can simply add ",(0,o.mdx)("inlineCode",{parentName:"p"},"static_assert"),"s to your code.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Creating ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," objects is relatively expensive, as they use external memory buffers and indexes, but they usually do not consume too much memory. The amount of memory used is directly proportional to the number of fields in your layout, and their size. Prefer ",(0,o.mdx)("strong",{parentName:"p"},"reusing a single instance of each ",(0,o.mdx)("inlineCode",{parentName:"strong"},"DataLayout")," type")," that you need. Update its fields before creating the record, rather than creating a new ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," object on the stack each time you need to create a record.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"If you are using ",(0,o.mdx)("inlineCode",{parentName:"p"},"AutoDataLayout")," to build your ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," objects (like virtually everyone), be aware that their constructor uses a synchronization lock, which could potentially compromise multi-threading performance. Therefore, you ",(0,o.mdx)("em",{parentName:"p"},"really")," should be ",(0,o.mdx)("strong",{parentName:"p"},"reusing a single instance of each ",(0,o.mdx)("inlineCode",{parentName:"strong"},"DataLayout")," type")," that you need.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"When using containers (such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceVector")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceStringMap"),"), ",(0,o.mdx)("strong",{parentName:"p"},"use ",(0,o.mdx)("inlineCode",{parentName:"strong"},"stagedValues()")," to update the containers"),", rather than creating a new container each time and calling ",(0,o.mdx)("inlineCode",{parentName:"p"},"stage()"),". This will avoid doing a new container allocation and copy each time. For most use cases, successive records are very similar, often with an identical memory footprint, and updating containers will be significantly faster this way."))),(0,o.mdx)("h2",{id:"additional-samples"},"Additional samples"),(0,o.mdx)("p",null,"You can find examples of how to create and read records using ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," here: ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebookresearch/vrs/blob/main/sample_code/SampleRecordFormatDataLayout.cpp"},"Datalayout sample code"),"."),(0,o.mdx)("h2",{id:"why-reinvent-the-wheel"},"Why Reinvent the Wheel?"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"What's so special about DataLayout? Why did you not use JSON, Thrift, or some other existing serialized containers?")),(0,o.mdx)("p",null,"Historically, ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," was designed to be backward compatible with our early VRS files, which used straight-up structures of POD data. However, we now have better reasons than that. ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," leverages a specific pattern of sensor data collection, for which VRS was designed, where records are remarkably regular throughout a recording. For each device and record type, the exact same content blocks, using the same ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout"),"s are recorded over and over again, often many millions of times."),(0,o.mdx)("p",null,"For each record type in a stream, there is one ",(0,o.mdx)("inlineCode",{parentName:"p"},"RecordFormat"),", with its own set of ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions, which is the dictionary of field types and labels in the datalayout content blocks of the stream. Each ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," block in the record contains only its own data, in raw binary form, which reduces processing overhead to a minimum. Therefore, the marginal cost of a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataPieceValue<uint8_t>"),", before compression, is one byte per record, regardless of its label, and even if it is the only field in the datalayout content block."),(0,o.mdx)("p",null,"When reading and writing records, no binary-ascii conversions are made, only binary copies, and no pre or post processing of the source code is required. ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definitions are as readable as possible, since they are ",(0,o.mdx)("inlineCode",{parentName:"p"},"struct")," definitions. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," definition is interpreted only once when the file is read, and the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," that the reader expects is mapped only once to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," that is actually present in the stream. Therefore, reading the fields of a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," happens in amortized constant time, with no parsing of any kind, since only pointer and size checks are required. If a field is not available in a record, the default value for that type is returned, and the ",(0,o.mdx)("inlineCode",{parentName:"p"},"isAvailable()")," method can be used to check."),(0,o.mdx)("h3",{id:"what-is-datalayout-really-good-at"},"What is ",(0,o.mdx)("inlineCode",{parentName:"h3"},"DataLayout")," \u201creally\u201d good at?"),(0,o.mdx)("p",null,"All the power of ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," lies in its ability to amortize costs. Amortized, ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," objects..."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"...store one byte of payload at the cost of 1 byte of storage (or less, because of record level compression)."),(0,o.mdx)("li",{parentName:"ul"},"...have zero serialization/deserialization overhead, both on read and write, including when handling data version mismatch (that\u2019s when the data stored in a file and the definition you have when reading that file don\u2019t match)."),(0,o.mdx)("li",{parentName:"ul"},"...have constant field access time, no matter how many you have."),(0,o.mdx)("li",{parentName:"ul"},"...are pure binary containers (no string conversions, unlike json)."),(0,o.mdx)("li",{parentName:"ul"},"...require no pre-processor/code generation: ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataLayout")," definitions are directly compiled by a C++ compiler."),(0,o.mdx)("li",{parentName:"ul"},"...minimize memory allocations overhead. It\u2019s possible to create and read records without memory allocations beyond record management, even when dealing with variable size arrays (vectors). Again, amortized."),(0,o.mdx)("li",{parentName:"ul"},"...look, behave, and feel like a simple C++ struct: they are very readable, very easy and efficient to read and write to.")),(0,o.mdx)("p",null,"The key assumption VRS makes is that data collected within each stream is extremely repetitive throughout a particular file, and everything is done to leverage that property to the fullest. So ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," stores definitions once per file, parses them once per file-read, maps the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," format expected to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"DataLayout")," found in the stream once, so all the relatively expensive operations are done only once."),(0,o.mdx)("h3",{id:"what-is-datalayout-not-good-at"},"What is ",(0,o.mdx)("inlineCode",{parentName:"h3"},"DataLayout")," not good at?"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"seamless integration with existing data representations. You will need to write converters to copy your data source(s) to your ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataLayout")," definitions, field by field."),(0,o.mdx)("li",{parentName:"ul"},"Nested definitions are supported, but with limitations. See ",(0,o.mdx)("a",{parentName:"li",href:"https://facebookresearch.github.io/vrs/docs/RecordFormat#datalayout-examples"},"this documentation (in the \u201cExample 2: nested definitions\u201d tab) for details"),". For 99% of sensor data use cases, ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataLayout")," works great and this limitation isn\u2019t even apparent, but for advanced use cases with more structured data and variable formats, of when you have nested definitions with variable size data, ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataLayout")," conversion becomes a pain point."),(0,o.mdx)("li",{parentName:"ul"},"complex data structures, in particular, arbitrary data structures that might change with every record, or not be known at compile time, so that converter code can not be written. In that case, you might need to use a self-described container, such as json or msgpack (which is a binary version of json). Looking at the needs of sensor data collection, this should be rare, or needed only for configuration records, which is fine, because it\u2019s typically a one record need, and the trade offs are radically different when you need to do an operation once during setup vs. N million times in realtime. For instance, camera calibration is often stored as json in a ",(0,o.mdx)("inlineCode",{parentName:"li"},"DataLayout")," of a configuration record, and there is no reason to change that.")))}h.isMDXComponent=!0}}]);
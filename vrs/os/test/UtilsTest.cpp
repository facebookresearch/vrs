// Copyright (c) Facebook, Inc. and its affiliates. Confidential and proprietary.

#include <fstream>

#include <gtest/gtest.h>

#include <TestDataDir/TestDataDir.h>
#include <test_helpers/UniqueTemporaryDirectory.h>
#include <vrs/os/Platform.h>
#include <vrs/os/Utils.h>

// This test verifies that the following definitions are available for... tests!!
// Note: the file is generated by cmake, so do not run this when building from a solution file...

using namespace std;
using namespace vrs;

struct FileTest : testing::Test {
  FileTest() {}

// getTestDataDir() does not work on XROS yet. Exclude for now until this is fixed,
// since it is not strictly required to get XROS functionality going.
#if !IS_XROS_PLATFORM()
  string testDataDir = coretech::getTestDataDir();
#else
  string testDataDir;
#endif

  void testFileName(const string& filename) {
    string path = os::pathJoin(os::getTempFolder(), os::sanitizeFileName(filename));
    int status = os::makeDir(path);
    if (status != 0) {
      EXPECT_EQ(path, ""); // make sure the bad path is  printed
    }
    EXPECT_EQ(status, 0);
  }
};

#if !IS_ANDROID_PLATFORM() && !IS_XROS_PLATFORM()
TEST_F(FileTest, testDataDirExistsTest) {
  EXPECT_TRUE(os::isDir(testDataDir));
}
#endif // !IS_ANDROID_PLATFORM()

TEST_F(FileTest, testOsIsDir) {
#if IS_ANDROID_PLATFORM()
  EXPECT_TRUE(os::isDir("/system/bin"));
  EXPECT_FALSE(os::isDir("/system/super_dummy_name_that_should_not_ever_exist_let_me_tell_you"));
#elif IS_XROS_PLATFORM()
  // TBD
#else
  EXPECT_TRUE(os::isDir(testDataDir));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/a.txt")));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "filetest/b.txt")));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "filetest", "d.txt"))); // does not exist
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest", "x/y/z.txt")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest/x")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest", "x")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, os::pathJoin("/filetest", "x"))));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "filetest", "x", "y")));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/z"))); // does not exist

  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/c.txt"))); // symlink
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/w/z.txt"))); // through symlink
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest/w"))); // symlink to x/y
#endif // !IS_WINDOWS_PLATFORM()

#endif
}

#if !IS_ANDROID_PLATFORM() && !IS_XROS_PLATFORM()

TEST_F(FileTest, testIsFile) {
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/a.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/b.txt")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/d.txt"))); // does not exist
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/x/y/z.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest", "x", "y/z.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/x", "y/z.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest", "x", "y", "z.txt")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/x")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/x/y")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/z"))); // does not exist

  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/c.txt"))); // symlink
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/w/z.txt"))); // through symlink
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/w"))); // symlink to x/y
#endif // !IS_WINDOWS_PLATFORM()
}

TEST_F(FileTest, testPathExists) {
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/a.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/b.txt")));
  EXPECT_FALSE(os::pathExists(os::pathJoin(testDataDir, "/filetest/d.txt"))); // does not exist
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x/y/z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest", "x", "y/z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x", "y/z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest", "x", "y", "z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x/y")));
  EXPECT_FALSE(os::pathExists(os::pathJoin(testDataDir, "/filetest/z"))); // does not exist

  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_TRUE(os::pathExists(testDataDir + "/filetest/c.txt")); // symlink
  EXPECT_TRUE(os::pathExists(testDataDir + "/filetest/w/z.txt")); // through symlink
  EXPECT_TRUE(os::pathExists(testDataDir + "/filetest/w")); // symlink to x/y
#endif // !IS_WINDOWS_PLATFORM()
}

TEST_F(FileTest, testGetFileSize) {
  EXPECT_EQ(0, os::getFileSize(os::pathJoin(testDataDir, "/filetest/a.txt"))); // empty
  EXPECT_EQ(10, os::getFileSize(os::pathJoin(testDataDir, "/filetest/b.txt"))); // something
  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_EQ(5, os::getFileSize(os::pathJoin(testDataDir, "/filetest/c.txt"))); // through symlink
#endif // !IS_WINDOWS_PLATFORM()
}

#endif // !IS_ANDROID_PLATFORM() && !IS_XROS_PLATFORM()

#if !IS_XROS_PLATFORM()
struct GetCurrentExecutablePathTest : testing::Test {
  GetCurrentExecutablePathTest() {}

  string currentExectable = os::getCurrentExecutablePath();
};

TEST_F(GetCurrentExecutablePathTest, testGetCurrentExecutablePath) {
  EXPECT_TRUE(os::getFileSize(currentExectable) > 0);
  EXPECT_TRUE(os::isDir(os::getParentFolder(currentExectable)));
}
#endif

TEST_F(FileTest, testSanitize) {
  vector<const char*> goodNames = {"All good name.txt", "abcdefg", "~.txt"};
  for (const char* goodName : goodNames) {
    EXPECT_EQ(os::sanitizeFileName(goodName), goodName);
    testFileName(goodName);
  }
  const string allChars1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const string allChars2 = "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F";
  testFileName(allChars1);
  testFileName(allChars2);
#if IS_WINDOWS_PLATFORM()
  EXPECT_EQ(
      os::sanitizeFileName(allChars1),
      " !%22#$%&'()%2A+,-.%2F0123456789%3A;%3C=%3E%3F@ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  EXPECT_EQ(os::sanitizeFileName(allChars2), "[%5C]^_`abcdefghijklmnopqrstuvwxyz{%7C}~%7F");
  EXPECT_EQ(os::sanitizeFileName("con"), "~con");
  EXPECT_EQ(os::sanitizeFileName("con."), "~con.");
  EXPECT_EQ(os::sanitizeFileName("COM9.txt"), "~COM9.txt");
  EXPECT_EQ(os::sanitizeFileName("LPT9.txt.txt"), "LPT9.txt.txt");
  EXPECT_EQ(os::sanitizeFileName("LPT9"), "~LPT9");
#else
  EXPECT_EQ(
      os::sanitizeFileName(allChars1),
      " !\"#$%&'()*+,-.%2F0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  EXPECT_EQ(os::sanitizeFileName(allChars2), "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~%7F");
  EXPECT_EQ(os::sanitizeFileName("con"), "con");
#endif
  EXPECT_EQ(os::sanitizeFileName("."), "~.");
  EXPECT_EQ(os::sanitizeFileName(".."), "~..");
}

TEST_F(FileTest, testGetFilename) {
  EXPECT_EQ("file.txt", os::getFilename("some/path/file.txt"));
  EXPECT_EQ("path", os::getFilename("some/path/"));
  EXPECT_EQ("path", os::getFilename("/some/path/"));
  EXPECT_EQ("path", os::getFilename("/some/path\\")); // Windows path separator
  EXPECT_EQ("path", os::getFilename("/some/path//")); // multiple path separators
}

TEST_F(FileTest, testFileResize) {
  // NOTE: not using osGetTempFolder() since the UniqueTemporaryDirectory code is already ported to
  // XROS.
  string tempDir = arvr::test_helpers::getUniqueTemporaryDirectory().string();
  string testFilePath = os::pathJoin(tempDir, "a.txt");

  { // Create a dummy file in the temp dir that we can grow and shrink.
    ofstream strm(testFilePath);
    strm << "Test\n";
  }

  if constexpr (IS_WINDOWS_PLATFORM()) {
    EXPECT_EQ(6, os::getFileSize(testFilePath)); // \r\n
  } else {
    EXPECT_EQ(5, os::getFileSize(testFilePath)); // \n
  }
  FILE* file = os::fileOpen(testFilePath, "w");
  // Resizing the file will show up immediately
  EXPECT_EQ(0, os::fileSetSize(file, 1000));
  EXPECT_EQ(1000, os::getFileSize(testFilePath));

  // Stream pointer is still at position zero, so writing to it won't change the file size.
  char value = 'a';
  EXPECT_EQ(1, os::fileWrite(&value, 1, 1, file));
  EXPECT_EQ(0, fflush(file));
  EXPECT_EQ(1000, os::getFileSize(testFilePath));

  // Write one bye at the end of the file, this will increase the file
  EXPECT_EQ(0, os::fileSeek(file, 1000, SEEK_SET));
  EXPECT_EQ(1, os::fileWrite(&value, 1, 1, file));
  EXPECT_EQ(0, fflush(file));
  EXPECT_EQ(1001, os::getFileSize(testFilePath));

  // Shrinking the file to 500 bytes won't modify the stream pointer (is this UB?)
  EXPECT_EQ(0, os::fileSetSize(file, 500));
  EXPECT_EQ(1001, os::fileTell(file));

  // Writing one byte at the end will increase the file size again.
  EXPECT_EQ(0, os::fileSeek(file, 500, SEEK_SET));
  EXPECT_EQ(1, os::fileWrite(&value, 1, 1, file));
  os::fileClose(file);
  EXPECT_EQ(501, os::getFileSize(testFilePath));

  // File does not exist - osGetFileSize will return -1
  EXPECT_EQ(0, os::remove(testFilePath));
  EXPECT_EQ(-1, os::getFileSize(testFilePath));
}

/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "vrs/os/Utils.h"

#include <algorithm>
#include <fstream>
#include <vector>

#include <gtest/gtest.h>

#include <TestDataDir/TestDataDir.h>

#include <vrs/os/Platform.h>
#include <vrs/os/System.h>
#include <vrs/os/Utils.h>

// This test verifies that the following definitions are available for... tests!!
// Note: the file is generated by cmake, so do not run this when building from a solution file...

using namespace std;
using namespace vrs;

struct FileTest : testing::Test {
  FileTest() = default;

  string testDataDir = coretech::getTestDataDir();

  static void testFileName(const string& filename) {
    string path = os::pathJoin(os::makeUniqueFolder(), os::sanitizeFileName(filename));
    int status = os::makeDir(path);
    if (status != 0) {
      EXPECT_EQ(path, ""); // make sure the bad path is  printed
    }
    EXPECT_EQ(status, 0);
  }
};

#if !IS_ANDROID_PLATFORM()
TEST_F(FileTest, testDataDirExistsTest) {
  EXPECT_TRUE(os::isDir(testDataDir));
}
#endif // !IS_ANDROID_PLATFORM()

TEST_F(FileTest, testOsIsDir) {
#if IS_ANDROID_PLATFORM()
  EXPECT_TRUE(os::isDir("/system/bin"));
  EXPECT_FALSE(os::isDir("/system/super_dummy_name_that_should_not_ever_exist_let_me_tell_you"));
#else
  EXPECT_TRUE(os::isDir(testDataDir));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/a.txt")));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "filetest/b.txt")));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "filetest", "d.txt"))); // does not exist
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest", "x/y/z.txt")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest/x")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest", "x")));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, os::pathJoin("/filetest", "x"))));
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "filetest", "x", "y")));
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/z"))); // does not exist

  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/c.txt"))); // symlink
  EXPECT_FALSE(os::isDir(os::pathJoin(testDataDir, "/filetest/w/z.txt"))); // through symlink
  EXPECT_TRUE(os::isDir(os::pathJoin(testDataDir, "/filetest/w"))); // symlink to x/y
#endif // !IS_WINDOWS_PLATFORM()

#endif
}

#if !IS_ANDROID_PLATFORM()

TEST_F(FileTest, testIsFile) {
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/a.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/b.txt")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/d.txt"))); // does not exist
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/x/y/z.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest", "x", "y/z.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/x", "y/z.txt")));
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest", "x", "y", "z.txt")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/x")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/x/y")));
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/z"))); // does not exist

  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/c.txt"))); // symlink
  EXPECT_TRUE(os::isFile(os::pathJoin(testDataDir, "/filetest/w/z.txt"))); // through symlink
  EXPECT_FALSE(os::isFile(os::pathJoin(testDataDir, "/filetest/w"))); // symlink to x/y
#endif // !IS_WINDOWS_PLATFORM()
}

TEST_F(FileTest, testPathExists) {
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/a.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/b.txt")));
  EXPECT_FALSE(os::pathExists(os::pathJoin(testDataDir, "/filetest/d.txt"))); // does not exist
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x/y/z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest", "x", "y/z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x", "y/z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest", "x", "y", "z.txt")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x")));
  EXPECT_TRUE(os::pathExists(os::pathJoin(testDataDir, "/filetest/x/y")));
  EXPECT_FALSE(os::pathExists(os::pathJoin(testDataDir, "/filetest/z"))); // does not exist

  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_TRUE(os::pathExists(testDataDir + "/filetest/c.txt")); // symlink
  EXPECT_TRUE(os::pathExists(testDataDir + "/filetest/w/z.txt")); // through symlink
  EXPECT_TRUE(os::pathExists(testDataDir + "/filetest/w")); // symlink to x/y
#endif // !IS_WINDOWS_PLATFORM()
}

TEST_F(FileTest, testGetFileSize) {
  EXPECT_EQ(0, os::getFileSize(os::pathJoin(testDataDir, "/filetest/a.txt"))); // empty
  EXPECT_EQ(10, os::getFileSize(os::pathJoin(testDataDir, "/filetest/b.txt"))); // something
  // Windows does not have symlinks
#if !IS_WINDOWS_PLATFORM()
  EXPECT_EQ(5, os::getFileSize(os::pathJoin(testDataDir, "/filetest/c.txt"))); // through symlink
#endif // !IS_WINDOWS_PLATFORM()
}

#endif // !IS_ANDROID_PLATFORM()

struct GetCurrentExecutablePathTest : testing::Test {
  GetCurrentExecutablePathTest() = default;

  string currentExectable = os::getCurrentExecutablePath();
};

TEST_F(GetCurrentExecutablePathTest, testGetCurrentExecutablePath) {
  EXPECT_TRUE(os::getFileSize(currentExectable) > 0);
  EXPECT_TRUE(os::isDir(os::getParentFolder(currentExectable)));
}

TEST_F(FileTest, testSanitize) {
  vector<const char*> goodNames = {"All good name.txt", "abcdefg", "~.txt"};
  for (const char* goodName : goodNames) {
    EXPECT_EQ(os::sanitizeFileName(goodName), goodName);
    testFileName(goodName);
  }
  const string allChars1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const string allChars2 = "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F";
  testFileName(allChars1);
  testFileName(allChars2);
#if IS_WINDOWS_PLATFORM()
  EXPECT_EQ(
      os::sanitizeFileName(allChars1),
      " !%22#$%&'()%2A+,-.%2F0123456789%3A;%3C=%3E%3F@ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  EXPECT_EQ(os::sanitizeFileName(allChars2), "[%5C]^_`abcdefghijklmnopqrstuvwxyz{%7C}~%7F");
  EXPECT_EQ(os::sanitizeFileName("con"), "~con");
  EXPECT_EQ(os::sanitizeFileName("con."), "~con.");
  EXPECT_EQ(os::sanitizeFileName("COM9.txt"), "~COM9.txt");
  EXPECT_EQ(os::sanitizeFileName("LPT9.txt.txt"), "LPT9.txt.txt");
  EXPECT_EQ(os::sanitizeFileName("LPT9"), "~LPT9");
#else
  EXPECT_EQ(
      os::sanitizeFileName(allChars1),
      " !\"#$%&'()*+,-.%2F0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  EXPECT_EQ(os::sanitizeFileName(allChars2), "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~%7F");
  EXPECT_EQ(os::sanitizeFileName("con"), "con");
#endif
  EXPECT_EQ(os::sanitizeFileName("."), "~.");
  EXPECT_EQ(os::sanitizeFileName(".."), "~..");
}

TEST_F(FileTest, testGetFilename) {
  EXPECT_EQ("file.txt", os::getFilename("some/path/file.txt"));
  EXPECT_EQ("path", os::getFilename("some/path/"));
  EXPECT_EQ("path", os::getFilename("/some/path/"));
  EXPECT_EQ("path", os::getFilename("/some/path\\")); // Windows path separator
  EXPECT_EQ("path", os::getFilename("/some/path//")); // multiple path separators
}

TEST_F(FileTest, testFileResize) {
  string tempDir = os::makeUniqueFolder();
  string testFilePath = os::pathJoin(tempDir, "a.txt");

  { // Create a dummy file in the temp dir that we can grow and shrink.
    ofstream strm(testFilePath);
    strm << "Test\n";
  }

  if constexpr (IS_WINDOWS_PLATFORM()) {
    EXPECT_EQ(6, os::getFileSize(testFilePath)); // \r\n
  } else {
    EXPECT_EQ(5, os::getFileSize(testFilePath)); // \n
  }
  FILE* file = os::fileOpen(testFilePath, "w");
  // Resizing the file will show up immediately
  EXPECT_EQ(0, os::fileSetSize(file, 1000));
  EXPECT_EQ(1000, os::getFileSize(testFilePath));

  // Stream pointer is still at position zero, so writing to it won't change the file size.
  char value = 'a';
  EXPECT_EQ(1, os::fileWrite(&value, 1, 1, file));
  EXPECT_EQ(0, fflush(file));
  EXPECT_EQ(1000, os::getFileSize(testFilePath));

  // Write one bye at the end of the file, this will increase the file
  EXPECT_EQ(0, os::fileSeek(file, 1000, SEEK_SET));
  EXPECT_EQ(1, os::fileWrite(&value, 1, 1, file));
  EXPECT_EQ(0, fflush(file));
  EXPECT_EQ(1001, os::getFileSize(testFilePath));

  // Shrinking the file to 500 bytes won't modify the stream pointer (is this UB?)
  EXPECT_EQ(0, os::fileSetSize(file, 500));
  EXPECT_EQ(1001, os::fileTell(file));

  // Writing one byte at the end will increase the file size again.
  EXPECT_EQ(0, os::fileSeek(file, 500, SEEK_SET));
  EXPECT_EQ(1, os::fileWrite(&value, 1, 1, file));
  os::fileClose(file);
  EXPECT_EQ(501, os::getFileSize(testFilePath));

  // File does not exist - osGetFileSize will return -1
  EXPECT_EQ(0, os::remove(testFilePath));
  EXPECT_EQ(-1, os::getFileSize(testFilePath));
}

TEST_F(FileTest, testListDir) {
  string testDir = os::pathJoin(os::makeUniqueFolder(), "filetest", "testlistdir");
  ASSERT_EQ(os::makeDirectories(testDir), 0);
  vector<string> expectedFiles = {
      os::pathJoin(testDir, "a.txt"),
      os::pathJoin(testDir, "b.txt"),
      os::pathJoin(testDir, "c.txt")};
  for (const string& name : expectedFiles) {
    ASSERT_EQ(os::fileClose(os::fileOpen(name, "w")), 0);
  }
  vector<string> files = os::listDir(testDir);
  for (string& name : files) {
    // Need to normalize the path to make the comparison work correctly on
    // Windows platforms.
    std::replace(name.begin(), name.end(), '\\', '/');
  }
  sort(files.begin(), files.end());
  sort(expectedFiles.begin(), expectedFiles.end());
  EXPECT_EQ(files, expectedFiles);
}

TEST(System, getTerminalWidthTest) {
  EXPECT_EQ(os::getTerminalWidth(120), 120); // set the value
  EXPECT_EQ(os::getTerminalWidth(), 120); // get the value back
  EXPECT_EQ(os::getTerminalWidth(80), 80); // change the value
  EXPECT_EQ(os::getTerminalWidth(), 80); // get the updated value
}

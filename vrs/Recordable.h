/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <functional>
#include <iostream>
#include <map>
#include <utility>

#include "DataSource.h"
#include "ForwardDefinitions.h"
#include "RecordManager.h"
#include "StreamId.h"

namespace vrs {

using std::map;
using std::string;
using std::vector;

class DataSource;

/// Container for a stream's tags, both user and VRS controlled.
struct StreamTags {
  map<string, string> user; ///< User controlled tags.
  map<string, string> vrs; ///< VRS tags, for internal use.

  bool operator==(const StreamTags& rhs) const {
    return user == rhs.user && vrs == rhs.vrs;
  }
};

/// \brief Class to override to implement a record producing device, or virtual device.
///
/// Recordables are meant to be attached to a single RecordFileWriter, that will write its records.
/// Each instance maps one-to-one with a RecordFileWriter's record stream.
class Recordable {
 protected:
  /// A recordable has a fixed recordable type id, set at construction and immutable.
  /// The instance id is generated by VRS and not user controlled.
  /// @see StreamId
  /// @param typeId: an id telling which type of stream this is.
  /// @param flavor: a flavor required when using << recordable class >> type ids.
  /// Note: you may always provide a flavor, but you are required to with << recordable class> ids.
  Recordable(RecordableTypeId typeId, const string& flavor = {});

 public:
  virtual ~Recordable();

  /// Get a readable name for the recordable, based on its StreamId.
  /// @return The instance's StreamId name.
  string getRecordableName() const {
    return getStreamId().getName();
  }

  /// Get this instance's recordable type. Can never change for this instance.
  /// @return The instance's RecordableTypeId.
  RecordableTypeId getRecordableTypeId() const {
    return typeId_;
  }

  /// Get the unique instance id for this particular recordable.
  /// @return The object's instance id.
  uint16_t getRecordableInstanceId() const {
    return instanceId_;
  }

  /// Get the recordable's StreamId.
  /// @return The recordable's StreamId.
  StreamId getStreamId() const {
    return StreamId{typeId_, instanceId_};
  }

  /// Activate a recordable to enable recording. Must be enabled for pre-record buffering.
  /// Recording a device's records can be enabled and disabled on the fly during recording.
  /// Recordables can't be added or removed from a RecordFileWriter while a file is being written,
  /// but recordables can be activated and deactivated instead.
  void setRecordableIsActive(bool isActive) {
    isActive_ = isActive;
  }

  /// Tell if the recordable is active for recording.
  /// @return True if records will be recorded the next time the record file writer will look for
  /// records to write.
  bool isRecordableActive() const {
    return isActive_;
  }

  /// Override default compression preset for this recordable.
  /// @param preset: The compression preset to use when writing the next records.
  void setCompression(CompressionPreset preset);

  /// To manage the records of this recordable with RecordFormat, define a RecordFormat for each
  /// type of record. It is possible for the same recordable to produce multiple type of records of
  /// the same type, using a different formatVersion for each. For each, a different RecordFormat
  /// must be defined.
  ///
  /// Attention! when you provide a RecordFormat for a record type & formatVersion,
  /// all of the streams' records of that type & formatVersion must comply with that RecordFormat.
  /// @param recordType: The Record::Type to define.
  /// @param formatVersion: The format version to define.
  /// @param format: The RecordFormat for the records of the type and format version.
  /// @param layouts: A vector of pointers to DataLayouts and nullptr. For each DataLayout content
  /// block of the RecordFormat, a pointer to a DataLayout must be provided for the matching index.
  /// @return True if the RecordFormat and the layouts match as expected. Otherwise, false is
  /// returned and errors will be logged to help debug the problem.
  bool addRecordFormat(
      Record::Type recordType,
      uint32_t formatVersion,
      const RecordFormat& format,
      vector<const DataLayout*> layouts = {});

  /// Configuration records describe how the device recorded is configured/setup.
  /// The configuration of a recordable is probably not changed by data flowing through.
  /// A framerate, a resolution, are probably part of the configuration.
  /// An exposure setting as well, unless it is automatically adjusted as data flows through.
  /// The RecordFileWriter will call this method to make sure a configuration record is captured,
  /// when a record file is created asynchronously.
  virtual const Record* createConfigurationRecord() = 0;

  /// State records describe the internal state of the device, if it's stateful.
  /// It is probably the result of previous calculation/processing of data.
  ///
  /// State records should not to be confused with the configuration of the device.
  /// A position tracking algorithm probably has a state: the last position it determined, which
  /// will be used to calculate the next state when the next data come in. State data typically
  /// changes as data flows, according to that data. A camera probably has no state, but probably
  /// has a configuration.
  /// The RecordFileWriter will call this method to make sure a configuration record is captured,
  /// when a record file is created asynchronously.
  virtual const Record* createStateRecord() = 0;

  /// Record creation delegate function, to change the record creation behavior without having to
  /// override the class.
  /// Note that it is valid to deny a record creation request by simply returning a nullptr.
  using CreateRecordDelegate = std::function<const Record*(
      StreamId streamId,
      double timestamp,
      Record::Type recordType,
      uint32_t recordFormatVersion,
      const DataSource& data)>;

  /// Record creation requests may be intercepted by setting a CreationRecordDelegate.
  /// Using this method, as opposed to making createRecord virtual, can allow interception of record
  /// creation requests, for instance, if you want to redirect record creations to another process,
  /// without having to change the class inheritance hierarchy.
  /// Note that you normally do not need to do this.
  /// @param delegate: an external function that will handed data when a record needs to be created.
  /// You can unset the delegate by using a empty function.
  void setCreateRecordDelegate(CreateRecordDelegate delegate) {
    createRecordDelegate_ = std::move(delegate);
  }

  /// Set tags for each Recordable, so that you reconfigure the system when reading.
  /// Note: tags are written when the file is *created*, so you need to create them early enough.
  /// @param tagName: The name of the tag.
  /// @param tagValue: The value of the tag.
  void setTag(const string& tagName, const string& tagValue);
  /// Add file tags in bulk.
  /// @param newTags: A map of string name/value pairs.
  void addTags(const map<string, string>& newTags);
  /// Add many tags at once, both internal & user tags.
  /// This method is meant for record stream copy operations, when all the tags of a read record
  /// stream need to be copied to a recordable capturing the copy of the stream.
  /// @param tags: User and VRS tags to set, probably coming from RecordFileReader::getTag(id).
  void addTags(const StreamTags& tags);
  /// Get the user tags, all at once.
  /// @return Map of tag-name/tag-value pairs.
  const map<string, string>& getTags() const {
    return tags_.user;
  }
  /// Get all the tags at once, both internal & user tags.
  /// @return All the user and VRS tags.
  const StreamTags& getStreamTags() const {
    return tags_;
  }

  /// Get the stream's unique serial number generated on stream creation.
  /// That serial number is universaly unique and it will be preserved during file copies, file
  /// processing, and other manipulations that preserve stream tags, whereas the stream's streamID
  /// may change.
  /// Note that VRS internal tags might be overwritten, in particular during file copy operations,
  /// so this serial number might be intentionally replaced (by design).
  const string& getSerialNumber() const {
    return getTag(tags_.vrs, getSerialNumberTagName());
  }

  /// Get the name of the VRS tag used to store the original name of the recordable.
  /// @internal
  static const string& getOriginalNameTagName() {
    static const string sOriginalRecordableNameTagName("VRS_Original_Recordable_Name");
    return sOriginalRecordableNameTagName;
  }

  /// Get the name of the VRS tag used to store recordable flavors.
  /// @internal
  static const string& getFlavorTagName() {
    static const string sFlavorTagName("VRS_Recordable_Flavor");
    return sFlavorTagName;
  }

  /// Get the recordable's RecordManager. Not meant for client code use.
  /// @internal
  RecordManager& getRecordManager() {
    return recordManager_;
  }

  /// Get the name of the VRS tag used to store the stream's serial number.
  static const string& getSerialNumberTagName() {
    static const string sSerialNumberTagName("VRS_Serial_Number");
    return sSerialNumberTagName;
  }

  /// Recordable instance ids are automatically assigned when Recordable objects are created.
  /// This guarantees that each Recordable gets a unique ID.
  /// WARNING! If your code relies on specific instance IDs, your design is weak, and you are
  /// setting up your project for a world of pain in the future.
  /// Use flavors and tag pairs to identify your streams instead.
  /// However, when many files are generated successively, it can lead to high instance
  /// id values, which can be confusing, and even problematic for unit tests.
  /// Use this API to reset the instance counters for each device type, so that the next devices
  /// will get an instance id of 1.
  /// ATTENTION! if you call this API at the wrong time, you can end up with multiple devices with
  /// the same id, and end up in a messy situation. Avoid this API if you can!
  static void resetNewInstanceIds();

 protected:
  /// Create a new record for this recordable. That's the only client API to do so.
  ///
  /// When the call returns:
  ///  - a record has been created and is fully owned and managed by the recordable's RecordManager,
  ///  despite returning a pointer to it.
  ///  - the data referenced by DataSource has fully been copied in the record, so that the caller
  ///  is immediately entirely free to reuse or delete the source data as desired.
  ///
  /// @param timestampSec: Timestamp of the record. *All the records of all the recordables*
  /// attached to the same RecordFileWriter must have timestamps in *the same time domain*, or they
  /// won't be managed & sorted in a sensible way. Respecting this requirement is essential, as
  /// records will be ordered on disk and played back sorted by their timestamp.
  /// Timestamps are a count of seconds since some arbitrary point in time, EPOCH or not (usually).
  /// @param recordType: The type of the record.
  /// @param formatVersion: Each record specifies how it encodes its data using a formatVersion.
  /// This format version may reference a RecordFormat definition that has been provided using
  /// RecordFormat::addRecordFormat() (new/better API), or reference a data format managed manually
  /// by the user of the API (early API, before RecordFormat & DataLayout).
  /// The version number only need to be unique for this device and record type, but needs to be
  /// carefully managed over time, or you won't be able to interpret files created in the past.
  /// @param data: A DataSource that points to the record's actual data payload.
  /// @return record: A pointer to the created record, that's owned & managed by the recordable's
  /// RecordManager. Client code probably shouldn't do much with that pointer.
  /// Attention! This pointer may be null, in particular when a delegate intercepts the request!
  const Record* createRecord(
      double timestampSec,
      Record::Type recordType,
      uint32_t formatVersion,
      const DataSource& data = DataSource()) {
    return createRecordDelegate_
        ? createRecordDelegate_(getStreamId(), timestampSec, recordType, formatVersion, data)
        : recordManager_.createRecord(timestampSec, recordType, formatVersion, data);
  }

  /// When direct edits of VRS tags is conventient (record filters)
  map<string, string>& getVRSTags() {
    return tags_.vrs;
  }

 private:
  const RecordableTypeId typeId_;
  const uint16_t instanceId_;
  StreamTags tags_;
  RecordManager recordManager_;
  CreateRecordDelegate createRecordDelegate_;
  bool isActive_;

  friend class RecordFileWriter;

  /// Get a new instance id for this recordable type id, so as to be sure that recordables are
  /// uniquely identified throughout the app.
  /// @param typeId: The recordable type for which a new instance needs to be created.
  /// Each type is counted separately. The default value is used to reset Ids during tests.
  /// @internal
  static uint16_t getNewInstanceId(RecordableTypeId typeId = static_cast<RecordableTypeId>(0));

  const string& getTag(const map<string, string>& tags, const string& name) const;
};

} // namespace vrs

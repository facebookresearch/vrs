// Copyright (c) Meta Platforms, Inc. and affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cstring>

#include <gtest/gtest.h>

#include <vrs/utils/converters/Raw10ToGrey10Converter.h>

// clang-format off
constexpr uint8_t kContiguousInput[40] = {
  0x01, 0x82, 0x03, 0x84, 0xff, 0x05, 0x96, 0x07, 0x98, 0x00,
  0x09, 0xaa, 0x0b, 0xac, 0xff, 0x0d, 0xbe, 0x0f, 0xb0, 0x00,
  0x11, 0xc2, 0x13, 0xc4, 0xff, 0x15, 0xd6, 0x17, 0xd8, 0x00,
  0x19, 0xea, 0x1b, 0xec, 0xff, 0x1d, 0xfe, 0x1f, 0xf0, 0x00
};

constexpr uint8_t kNonContiguousInput[60] = {
  0x01, 0x82, 0x03, 0x84, 0xff, 0x05, 0x96, 0x07, 0x98, 0x00,
  0x09, 0xaa, 0x0b, 0xac, 0xff, 0x0d, 0xbe, 0x0f, 0xb0, 0x00,
  // Extra row that is to be ignored by the converter
  0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,
  0x11, 0xc2, 0x13, 0xc4, 0xff, 0x15, 0xd6, 0x17, 0xd8, 0x00,
  0x19, 0xea, 0x1b, 0xec, 0xff, 0x1d, 0xfe, 0x1f, 0xf0, 0x00,
  // Extra row that is to be ignored by the converter
  0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,
};

// Note: little endian.
constexpr uint8_t kExpectedResult[64] = {
  0x07, 0x00, 0x0b, 0x02, 0x0f, 0x00, 0x13, 0x02, 0x14, 0x00, 0x58, 0x02, 0x1c, 0x00, 0x60, 0x02,
  0x27, 0x00, 0xab, 0x02, 0x2f, 0x00, 0xb3, 0x02, 0x34, 0x00, 0xf8, 0x02, 0x3c, 0x00, 0xc0, 0x02,
  0x47, 0x00, 0x0b, 0x03, 0x4f, 0x00, 0x13, 0x03, 0x54, 0x00, 0x58, 0x03, 0x5c, 0x00, 0x60, 0x03,
  0x67, 0x00, 0xab, 0x03, 0x6f, 0x00, 0xb3, 0x03, 0x74, 0x00, 0xf8, 0x03, 0x7c, 0x00, 0xc0, 0x03,
};

constexpr uint8_t kNonContiguousInputMultiple4[40] = {
  0x01, 0xa2, 0x03, 0xa4, 0xff, 0x05, 0xb6, 0x07, 0xb8, 0x00, 0x09, 0xca, 0x0b, 0xcc, 0xff,
  // Padding that is to be ignored by the converter
  0xff, 0xff, 0xff, 0xff, 0xff,
  0x11, 0xd2, 0x13, 0xd4, 0xff, 0x15, 0xe6, 0x17, 0xe8, 0x00, 0x19, 0xfa, 0x1b, 0xfc, 0xff,
  // Padding that is to be ignored by the converter
  0xff, 0xff, 0xff, 0xff, 0xff,
};

// Note: little endian.
constexpr uint8_t kExpectedResultMultiple4[48] = {
  0x07, 0x00, 0x8b, 0x02, 0x0f, 0x00, 0x93, 0x02, 0x14, 0x00, 0xd8, 0x02,
  0x1c, 0x00, 0xe0, 0x02, 0x27, 0x00, 0x2b, 0x03, 0x2f, 0x00, 0x33, 0x03,
  0x47, 0x00, 0x4b, 0x03, 0x4f, 0x00, 0x53, 0x03, 0x54, 0x00, 0x98, 0x03,
  0x5c, 0x00, 0xa0, 0x03, 0x67, 0x00, 0xeb, 0x03, 0x6f, 0x00, 0xf3, 0x03,
};
// clang-format on

TEST(Raw10ToGrey10Converter, ContiguousImages) {
  uint8_t outBuffer[64];

  EXPECT_TRUE(vrs::utils::convertRaw10ToGrey10(outBuffer, kContiguousInput, 16, 2, 20));

  for (int i = 0; i < 64; ++i) {
    EXPECT_EQ(kExpectedResult[i], outBuffer[i]);
  }
}

TEST(Raw10ToGrey10Converter, NonContiguousImages) {
  uint8_t outBuffer[64];
  EXPECT_TRUE(vrs::utils::convertRaw10ToGrey10(outBuffer, kNonContiguousInput, 16, 2, 30));

  for (int i = 0; i < 64; ++i) {
    EXPECT_EQ(kExpectedResult[i], outBuffer[i]);
  }
}

TEST(Raw10ToGrey10Converter, InvalidInput) {
  uint8_t outBuffer[64];
  // Width not a multiple of 8
  EXPECT_FALSE(vrs::utils::convertRaw10ToGrey10(outBuffer, kContiguousInput, 15, 2, 30));
  // Stride too short
  EXPECT_FALSE(vrs::utils::convertRaw10ToGrey10(outBuffer, kContiguousInput, 16, 2, 19));
}

TEST(Raw10ToGrey10Converter, ContiguousImagesMultipleOf4) {
  uint8_t outBuffer[64];

  // 32 pixels
  memset(outBuffer, 0, 64);
  EXPECT_TRUE(vrs::utils::convertRaw10ToGrey10(outBuffer, kContiguousInput, 4, 8, 5));

  for (int i = 0; i < 64; ++i) {
    EXPECT_EQ(kExpectedResult[i], outBuffer[i]);
  }

  // 28 pixels
  memset(outBuffer, 0, 64);
  EXPECT_TRUE(vrs::utils::convertRaw10ToGrey10(outBuffer, kContiguousInput, 4, 7, 5));

  for (int i = 0; i < 56; ++i) {
    EXPECT_EQ(kExpectedResult[i], outBuffer[i]);
  }
}

TEST(Raw10ToGrey10Converter, NonContiguousImagesMultipleOf4) {
  uint8_t outBuffer[48];

  // 24 pixels, using the continuous input.
  memset(outBuffer, 0, 48);
  EXPECT_TRUE(vrs::utils::convertRaw10ToGrey10(outBuffer, kNonContiguousInputMultiple4, 12, 2, 20));

  for (int i = 0; i < 48; ++i) {
    EXPECT_EQ(kExpectedResultMultiple4[i], outBuffer[i]);
  }
}
